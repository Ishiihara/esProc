<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<funcs>
<normal>
<F1 desc="The COUNT item in a cell expression." displaystr="" majortype="102" name="#@" postfix="" returntype="101">
<options/>
<params/>
</F1>
<F2 desc="Get members of a sequence according to the sequence numbers of members of an integer sequence to create a new sequence." displaystr="" majortype="102" name="A" postfix="" returntype="101">
<options/>
<params>
<P1 desc="p (An integer sequence; the range of its member values is ≥0 and ≤n. If P is an empty sequence, then return an empty sequence.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F2>
<F3 desc="Define a cell name." displaystr="" majortype="101" name="Cr" postfix="" returntype="101">
<options/>
<params/>
</F3>
<F4 desc="Convert a string, two-level sequence, table sequence or record sequence to a specific type" displaystr="" majortype="102" name="E" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Do not use headers" optionchar="b"/>
<O2 defaultselect="false" description="Transpose the two-level sequence" optionchar="p"/>
<O3 defaultselect="false" description="Return a string separated by carriage return or tab when parameter x is a table sequence" optionchar="s"/>
</options>
<params>
<P1 desc="x(A sequence/string/table sequence/record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F4>
<F5 desc="Switch between an Excel date/time value and a numeric value." displaystr="" majortype="102" name="E" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (A numeric/date/time value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F5>
<F6 desc="The function equals the Excel ACCRINT function" displaystr="" majortype="102" name="Faccrint" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="first_interest    ( The security's first interest date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="settlement (The security's settlement date, i.e. the date after the issue date by which a buyer must pay for the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The issue date of the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="par (The security's par value. If omitted, it takes the default value of zero for ￥100)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F6>
<F7 desc="The function equals the Excel ACCRINTM function" displaystr="" majortype="102" name="Faccrintm" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="maturity  (The security's maturity date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="issue (The security'’s issue date )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="par (The security's par value. If omitted, it takes the default value of zero for 100 yuan)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F7>
<F8 desc="The function equals the Excel COUPNCD function" displaystr="" majortype="102" name="Fcoupcd" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F8>
<F9 desc="The function equals the Excel COUPNND function" displaystr="" majortype="102" name="Fcoupcd" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPNND function. It returns the previous coupon date before the settlement date for a security. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="p"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F9>
<F10 desc="The function equals the Excel COUPNUN function" displaystr="" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F10>
<F11 desc="The function equals the Excel COUPDAYS function" displaystr="" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPDAYS function. It returns the number of days in a coupon period that contains the settlement date. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F11>
<F12 desc="The function equals the Excel COUPDAYBS function" displaystr="" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="It is equivalent to Excel COUPDAYS function and returns the number of days in a coupon period that contains the settlement date. Annually. The day count basis method is US (NASD) 30/360." optionchar="b"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter." optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter." optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter." optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter." optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter." optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter." optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F12>
<F13 desc="The function equals the Excel COUPDAYSNC function" displaystr="" majortype="102" name="Fcoups" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel COUPDAYSNC function. It returns the number of days from the settlement date to the next coupon date. Annually. Specify the day count basis method US (NASD) 30/360" optionchar="n"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity    (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F13>
<F14 desc="The function equals the Excel DB function" displaystr="" majortype="102" name="Fdb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost      (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period number for which you want to calculate the depreciation (it must has the same unit with life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="month (The number of the months used in the calculation of the first year of depreciation. If omitted, it takes the value of 12 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F14>
<F15 desc="The function equals the Excel DDB function" displaystr="" majortype="102" name="Fddb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost    (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period number for which you want to calculate the depreciation (It must has the same unit with life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="factor (The rate of balance declining. If omitted, it takes on the default value of 2 (specifying the double-declining balance method))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F15>
<F16 desc="The function equals the Excel DISC function" displaystr="" majortype="102" name="Fdisc " postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity  (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F16>
<F17 desc="The function equals the Excel DURATION function" displaystr="" majortype="102" name="Fduration " postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="coupon (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="yld (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F17>
<F18 desc="The function equals the Excel INTRATE function" displaystr="" majortype="102" name="Fintrate" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity   (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="investment (The initial amount invested into the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F18>
<F19 desc="The function equals the Excel IRR function" displaystr="" majortype="102" name="Firr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="values (A sequence containing the values of a series of cash flows used to calculate the internal rate of return. It must contain at least one periodic payment (negative value) and at least one periodic income (positive value))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="guess (An estimated value for IRR function’s calculation. If omitted, it will take on the default value of 0.1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F19>
<F20 desc="The function equals the Excel MIRR function" displaystr="" majortype="102" name="Fmirr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="values (A sequence containing the values of payment (negative value) and income (positive value) at each of the regular periods . At least one negative value and at least one positive value must be contained)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="finance_rate (The interest rate paid on the money invested)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="reinvest_rate (The interest rate paid on the reinvested cash which is the net income from the regular periods)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F20>
<F21 desc="The function equals the Excel NPER function" displaystr="" majortype="102" name="Fnper" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F21>
<F22 desc="Equivalent to Excel NPVfunction" displaystr="" majortype="102" name="Fnpv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rate (The discount rate over one period (that is equal to inflation rate and the rate of competitive investment); it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="values (A sequence of values representing payments and income that must occur at regular time intervals and at the end of each period)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F22>
<F23 desc="Equivalent to Excel XNPVfunction" displaystr="" majortype="102" name="Fnpv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rate (The discount rate over one period (that is equal to inflation rate and the rate of competitive investment); it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="values (A sequence of values representing payments and income that must occur at regular time intervals and at the end of each period)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dates (A sequence of dates corresponding to the array of cash payments. The first date of payment denotes the beginning of the payments for the investment)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F23>
<F24 desc="The function equals the Excel PMT function" displaystr="" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0." optionchar="t"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F24>
<F25 desc="The function equals the Excel IPMT function" displaystr="" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel IPMT function. It enables to calculate the interest payment for a given period, with constant periodic payment and a constant interest rate" optionchar="i"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="per (The number of period in which the principal appears. Its value must between 1 and nper)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F25>
<F26 desc="The function equals the Excel PPMT  function" displaystr="" majortype="102" name="Fpmt" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel PPMT function. It enables to calculate the principal amount during a specific period of an investment or loan that is paid in constant periodic payments, with a constant interest rate" optionchar="p"/>
</options>
<params>
<P1 desc="rate   (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="per (The number of period in which the principal appears. Its value must between 1 and nper)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, its value will be assumed as zero (for example the future value of a loan can be zero))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F26>
<F27 desc="The function equals the Excel PRICE function" displaystr="" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="yld  (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F27>
<F28 desc="The function equals the Excel PRICEDISC function" displaystr="" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel PRICEDISC function. It calculates the price per ¥100 par value of a discounted security. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="discount (The security's discount rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="0" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F28>
<F29 desc="The function equals the Excel PRICEMAT function" displaystr="" majortype="102" name="Fprice" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel PRICEMAT function. It calculates the price per ¥100 par value of a security that pays interest at maturity. Specify the day count basis method US (NASD) 30/360" optionchar="m"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The security’s issue date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="yld  (The security's annual yield)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F29>
<F30 desc="The function equals the Excel RATE function" displaystr="" majortype="102" name="Frate" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="@t corresponds to Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="nper (The number of periods over which the investment or loan is to be paid)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pmt (The payment amount per period, including the principal and the interest)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or the total amount of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The future value of the loan/investment, or the cash balance you hope to achieve after the final payment. If omitted, it will take on the default value of zero)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="guess (An estimated interest rate. If omitted, it will take on the assumed value of 10%. Both guess and nper must use the same unit)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F30>
<F31 desc="The function equals the Excel RECEIVED function" displaystr="" majortype="102" name="Freceived" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O2 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O4 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="investment (The initial amount invested into the security)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="discount (The security's discount rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F31>
<F32 desc="The function equals the Excel SLN function" displaystr="" majortype="102" name="Fsln" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F32>
<F33 desc="The function equals the Excel SYD function" displaystr="" majortype="102" name="Fsyd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cost   (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="period (The period for which the asset’s depreciation is calculated (it must use the same unit as life))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F33>
<F34 desc="The function equals the Excel FV function" displaystr="" majortype="102" name="Fv" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="@t corresponds to the Excel type parameter. If using the option, choose type 1; if not, choose type 0" optionchar="t"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or an accumulated sum of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F34>
<F35 desc="The function equals the Excel PV function" displaystr="" majortype="102" name="Fv" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="This option makes the function equivalent to Excel PV function. It enables to calculate the present value of an investment that is the total amount of a series of future payments. For example the amount of borrower’s borrowed money is the present value of the loan delivered by the lender." optionchar="p"/>
</options>
<params>
<P1 desc="rate (The interest rate per period; it is a fixed value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nper (The number of periods over which the investment (or loan) requires or is to be paid)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pmt (The amount paid per period, which keeps unchanged during the whole period of paying off the loan. To omit it, pv must exist)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="fv (The present value of the loan /investment, a.k.a. the principal, that is the money that already exist when the payment for an investment (or a loan) begins, or an accumulated sum of present values of a series of future payments)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F35>
<F36 desc="The function equals the Excel VDB function" displaystr="" majortype="102" name="Fvdb" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Do not switch to the straight-line depreciation method when depreciation is greater than the declining balance calculation" optionchar="s"/>
</options>
<params>
<P1 desc="cost  (The initial cost of the asset)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="salvage (The value of the asset at the end of the depreciation (also known as asset residual value))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="life (The number of periods over which the asset is to be depreciated (sometimes called expected useful life of the asset))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="start_period (The starting period for which you want to calculate the depreciation. It must use the same unit as life.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="end_period (The ending period for which you want to calculate the depreciation. It must use the same unit as life.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="factor (The rate of depreciation. If omitted, it takes on the default value of 2, specifying the double-declining balance method)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F36>
<F37 desc="The function equals the Excel YIELD function" displaystr="" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O2 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O3 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O6 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F37>
<F38 desc="The function equals the Excel YIELDDISC function" displaystr="" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel YIELDDISC function. It calculates the annual yield rate of a discounted security. Specify the day count basis method US (NASD) 30/360" optionchar="d"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="0" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="redemption (The security's redemption value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F38>
<F39 desc="The function equals the Excel YIELDMAT function" displaystr="" majortype="102" name="Fyield" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Equivalent to Excel YIELDMAT function. It calculates the yield rate of a security that pays interest at maturity. Specify the day count basis method US (NASD) 30/360" optionchar="m"/>
<O2 defaultselect="false" description="Semi-annually. It corresponds to the Excel frequency parameter" optionchar="2"/>
<O3 defaultselect="false" description="Quaterly. It corresponds to the Excel frequency parameter" optionchar="4"/>
<O4 defaultselect="false" description="Specify the day count basis method Actual/Actual. It corresponds to the Excel basis parameter" optionchar="1"/>
<O5 defaultselect="false" description="Specify the day count basis method Actual/360. It corresponds to the Excel basis parameter" optionchar="0"/>
<O6 defaultselect="false" description="Specify the day count basis method Actual/365. It corresponds to the Excel basis parameter" optionchar="5"/>
<O7 defaultselect="false" description="Specify the day count basis method European 30/360. It corresponds to the Excel basis parameter" optionchar="e"/>
</options>
<params>
<P1 desc="settlement (The security's settlement date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="maturity (The security's maturity date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="issue (The security’s issue date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rate (The security's annual coupon rate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="pr (The security's price)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F39>
<F40 desc="Generate an identity matrix of a specified size." displaystr="" majortype="101" name="I" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s(A separator if the data file is of text format; it is the sheet name if the file is in format of xls or xlsx; can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F40>
<F41 desc="Request QVA through QVS to access QVM" displaystr="" majortype="102" name="Qconnect" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Clear buffer when QVM is closed" optionchar="r"/>
</options>
<params>
<P1 desc="url(QVS address, whose format is http://host:port/QVSServerName)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="v(Validation string)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="wt(Maximum wait time (unit: second))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="it(QVM’s maximum idle time (unit: second), whose default is 120；QVM will automatically close when the max idle time is reached, and will close permanently when its value is specified as 0)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F41>
<F42 desc="Get a list file names that have the specified prefix from the cloud storage." displaystr="" majortype="102" name="Qdirectory" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Display the path" optionchar="p"/>
</options>
<params>
<P1 desc="path(Storage bucket name; should not be omitted when both of the other two parameters are absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="p(Prefix string, which is case-sensitive and can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="d(The delimiter; support different delimiters for different cloud storage services)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F42>
<F43 desc="Set or get global variable for/from QVS." displaystr="" majortype="102" name="Qenv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="v(Global variable name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(Global variable value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F43>
<F44 desc="Retrieve file(s)/homo-name files group from storage bucket in the cloud storage platform." displaystr="" majortype="102" name="Qfile" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Force to cache all cache blocks to the cache directory; by default, only cache certain cache blocks containing data to be retrieved to the directory according to their positions " optionchar="c"/>
</options>
<params>
<P1 desc="fd(File(s) on the cloud storage platform)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(Specify this parameter when parameter fd is a homo-name files group, this parameter is zone table number or a sequence of zone table numbers)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F44>
<F45 desc="Retrieve file(s) from storage bucket in the cloud storage." displaystr="" majortype="102" name="Qfile" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Force to cache all cache blocks to the directory cachePath; by default, only certain cache blocks could be cached to the directory " optionchar="c"/>
</options>
<params>
<P1 desc="fd(File(s) on the cloud storage)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set; support JVM’s built-in character sets; default is the one in the OS)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F45>
<F46 desc="Upload file(s)/homo-name files group to or download them from cloud storage." displaystr="" majortype="102" name="Qload" postfix="" returntype="101">
<options/>
<params>
<P1 desc="lfn(A local file, whose format is “storageBucket/fileObjectName”; means download when omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(Specify this parameter when parameter lfn/rfn is a homo-name files group, the parameter is a zone table number or a sequence of zone table number)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="rfn(A file in the storage bucket, whose format is the same as parameter lfn; means upload when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="z(Specify this parameter when parameter lfn/rfn is a homo-name files group, the parameter is a zone table number or a sequence of zone table number)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F46>
<F47 desc="Implement global lock through QVS" displaystr="" majortype="102" name="Qlock" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Open the global lock" optionchar="u"/>
</options>
<params>
<P1 desc="n(Global lock name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s(Locking time-out (Unit: second))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F47>
<F48 desc="Delete or rename files/homo-name files group in the cloud storage." displaystr="" majortype="102" name="Qmove" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(File(s) in storage bucket, whose format is “storageBucket/fileObjectName”)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(It is zone table number or a sequence of zone table numbers; specify this parameter when fn is a homo-name files group)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="path(New name for parameter fn and has same format as fn; when bucketName is omitted from this parameter, use bucketName value specified in parameter fn)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F48>
<F49 desc="Read in content of a file according to file extension and return result as a table sequence." displaystr="" majortype="102" name="T" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Won’t read in the column headers; will read in them by default" optionchar="b"/>
<O2 defaultselect="false" description="Read in the file content as a cursor" optionchar="c"/>
</options>
<params>
<P1 desc="fn (A data file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A (A record sequence/cursor; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="Fi (A column header in the data file, which can be represented by #1,#2,… (column 1, column 2, …); can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="s (A separator that can be absent if the data file is of text format; it is the sheet name, which should not exceed 31 characters and contain special characters []:/\?*, if the file is of format of xls or xlsx)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F49>
<F50 desc="Compute the absolute value of the parameter." displaystr="" majortype="102" name="abs" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data for which you want to compute the absolute value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F50>
<F51 desc="Compute the arc cosine value of the parameter." displaystr="" majortype="102" name="acos" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to compute the arc cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F51>
<F52 desc="Return the inverse hyperbolic cosine" displaystr="" majortype="102" name="acosh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the inverse hyperbolic cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F52>
<F53 desc="Compute the number of whole years between two specified time points." displaystr="" majortype="102" name="age" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The result is accurate to the year" optionchar="y"/>
<O2 defaultselect="false" description="The result is accurate to the month" optionchar="m"/>
</options>
<params>
<P1 desc="dateExp1 (Date expression whose result is the date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="formatExp (Format expression, such as &quot;yyyyMMdd&quot;,&quot;yyyy-MM-dd&quot;)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="dateExp2 (Date expression whose result is the date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="formatExp (Format expression, such as &quot;yyyyMMdd&quot;,&quot;yyyy-MM-dd&quot;)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F53>
<F54 desc="Close connection to Alibaba Cloud." displaystr="" majortype="102" name="ali_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ali_client (A connection to Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F54>
<F55 desc="Connect to Albaba Cloud and return result as a cursor." displaystr="" majortype="102" name="ali_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="ali_url (The URL for accessing Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user (The Access ID for Alibaba Cloud.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="password (The Access Key for Alibaba Cloud.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F55>
<F56 desc="Return a table sequence." displaystr="" majortype="102" name="ali_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option closes the connection to Alibaba Cloud after the query finishes." optionchar="x"/>
<O2 defaultselect="false" description="The option initiates a query on a certain part of data in reverse order." optionchar="z"/>
</options>
<params>
<P1 desc="ali_client (An object to be connected on Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (A table name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyName (For a one-field key, the parameter is the key name; for a composite key, it is a sequence consisting of field names.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyValue (Primary key value. If it is a single value, query one record; if it is a sequence, perform batch query on multiple records. When it is a sequence of single values, query one record; when it is sequence of sequences, perform batch query on multiple records.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="selectCol (The column(s) to be returned. The parameter will be a column name when the target is a single column; and a sequence of column names when multiple columns are desired. All fields will be selected when the parameter isn’t supplied.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="filter (A filtering expression, which can be omitted. In the expression, following operators are allowed: Logical operators including &amp;&amp;, ||, and ! Relational operators including  &gt;, &gt;=, ==, &lt;, &lt;=, and != The format of the expression is like this: &lt;field name&gt; relational operator &lt;value expression&gt; For instance: col1 &gt; arg1 &amp;&amp; col1 &lt; arg2 || col2 != arg3 A boolean field needs to be written in a format like this: &lt;boolean field == false&gt;, instead of &lt;!boolean field&gt;.  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F56>
<F57 desc="Query a certain part of a table and return the result as a cursor." displaystr="" majortype="102" name="ali_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option closes the connection to Alibaba Cloud after the query finishes." optionchar="x"/>
<O2 defaultselect="false" description="The option initiates a query on a certain part of data in reverse order." optionchar="z"/>
</options>
<params>
<P1 desc="ali_client (An object to be connected on Alibaba Cloud.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (A table name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyName (For a one-field key, the parameter is the key name; for a composite key, it is a sequence consisting of field names.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="startValue (The starting value of the primary key values. When it is null or omitted, it represents an infinitesimal; and the colon shouldn’t be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="endValue (The ending value of the primary key values. When it is null or omitted, it represents an infinite value; and the colon shouldn’t be omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="selectCol (The column(s) to be returned. The parameter will be a column name when the target is a single column; and a sequence of column names when multiple columns are desired. All fields will be selected when the parameter isn’t supplied.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="filter (A filtering expression, which can be omitted. In the expression, following operators are allowed: Logical operators including &amp;&amp;, ||, and ! Relational operators including  &gt;, &gt;=, ==, &lt;, &lt;=, and != The format of the expression is like this: &lt;field name&gt; relational operator &lt;value expression&gt; For instance: col1 &gt; arg1 &amp;&amp; col1 &lt; arg2 || col2 != arg3 A boolean field needs to be written in a format like this: &lt;boolean field == false&gt;, instead of &lt;!boolean field&gt;.  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F57>
<F58 desc="Align records of a record sequence to a sequence" displaystr="" majortype="101" name="align" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Return all records of P that match members of A in order and group the result sequence; by default, the function returns only the first matching record" optionchar="a"/>
<O2 defaultselect="false" description="Use binary search when A is an ordered sequence" optionchar="b"/>
<O3 defaultselect="false" description="When this option is present, y is an integer sequence, where each member is an alignment position, and the function groups records of P and puts them repeatedly to positions specified by n" optionchar="r"/>
<O4 defaultselect="false" description="Return a sequence of ordinal numbers of members in P" optionchar="p"/>
<O5 defaultselect="false" description="Return all members of P that match members of A and put non-matching members in the result set’s last group" optionchar="n"/>
<O6 defaultselect="false" description="Sort records of P according to the order of members of A and put non-matching records in the last" optionchar="s"/>
<O7 defaultselect="false" description="Return a pure table sequence when P is a pure table sequence" optionchar="v"/>
</options>
<params>
<P1 desc="A (A sequence or record sequence to which records are aligned, which is usually the primary table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(A field or field expression according to which association is achieved; by default it is interpreted as ~)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y(Alignment expression in P, which is by default interpreted as P.~)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F58>
<F59 desc="Align the records of a record sequence to a sequence, so as to group the record sequence.  Equivalent to P.align (to(n),y), and support @r." displaystr="" majortype="101" name="align" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Of P records, return all members which are aligned according to the members of A, and group the resulting sequence. By default, only the first member will be returned." optionchar="a"/>
<O2 defaultselect="false" description="If A is an ordered sequence, the binary search will be used." optionchar="b"/>
<O3 defaultselect="false" description="y is an integer sequence, and every member of y is taken as the alignment position for aligning P to A. P will be aligned to the designated position of n overlappedly" optionchar="r"/>
<O4 defaultselect="false" description="The return value is composed of the sequence numbers of members in the P" optionchar="p"/>
<O5 defaultselect="false" description="Return all members of P whose records can be aligned to members of A. Of the result sets, there is an extra group to hold those members whose records fail to be aligned." optionchar="n"/>
<O6 defaultselect="false" description="In P, sort members by the same order as members of A, and put non-corresponding member(s) to A at the tail." optionchar="s"/>
<O7 defaultselect="false" description="Return a pure table sequence when P is a pure table sequence; by default return a pure sequence" optionchar="v"/>
</options>
<params>
<P1 desc="n (Integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (The alignment expression of P;iIt is interpreted as P if omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F59>
<F60 desc="Add a column to or modify a column in a table sequence" displaystr="" majortype="101" name="alter" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Fi(Name of a column to be added)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F`i(Name of a column in the table sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F60>
<F61 desc="The function alters fields in a table sequence. " displaystr="" majortype="101" name="alter" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="Fi(Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F61>
<F62 desc="Alter one or more fields in an entity table" displaystr="" majortype="101" name="alter" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F(Name of the to-be-added field)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F62>
<F63 desc="Perform bitwise operation on integers" displaystr="" majortype="102" name="and" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The numerical expression based on which you perform the bitwise AND operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F63>
<F64 desc="Perform bitwise operation on integers" displaystr="" majortype="102" name="and" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F64>
<F65 desc="Append records in cursor/table sequence cs to an entity table." displaystr="" majortype="101" name="append" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Real-time appending whenever a retrieval happens; force an appending when a composite table is closed; by default an appending is executed only when there is a specified number of new records" optionchar="i"/>
<O2 defaultselect="false" description="It is possible that the data in a single cursor corresponds to multiple zones in a multi-zone composite table. In that case the zone expression needs to be calculated at each append" optionchar="x"/>
<O3 defaultselect="false" description="Write data through merge-append; append data after the last record by default; do not support attached tables for the time being" optionchar="m"/>
<O4 defaultselect="false" description="Read records of cs to form an in-memory zone table but do not write the data to the external storage; mutually exclusive with other options; Return a multizone composite table consisting of the existing composite table and the in-memory zone table when T is a uni-composite table " optionchar="y"/>
</options>
<params>
<P1 desc="cs(A cursor/table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F65>
<F66 desc="Append-write records of a cursor to a pseudo table" displaystr="" majortype="101" name="append" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Append-write immediately at exit of the program or at retrieval while, by default, perform the operation when the number of records reaches to a specified number" optionchar="i"/>
<O2 defaultselect="false" description="Calculate the zone table expression is at each append when append-writing data in a single cursor to a pseudo table whose source composite table is a multi-zone one because the cursor could correspond to multiple zones" optionchar="x"/>
<O3 defaultselect="false" description="Write the appended records to the memory instead of keeping it in the external memory" optionchar="y"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F66>
<F67 desc="Return a list of the pecified script file’s argument names." displaystr="" majortype="102" name="arguments" postfix="" returntype="101">
<options/>
<params>
<P1 desc="spl(Name of a script file in the format of .dfx/.splx/.spl)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F67>
<F68 desc="Get the field values from a record respectively and return them as a sequence" displaystr="" majortype="101" name="array" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="Fi (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F68>
<F69 desc="Transform each record of a table sequence/record sequence and return a sequence of sequences" displaystr="" majortype="101" name="array" postfix="P" returntype="101">
<options/>
<params/>
</F69>
<F70 desc="To abtain the unicode value of the character at the specified position, if it is ASCII character, then return its ASCII code" displaystr="" majortype="102" name="asc" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (The given strings )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nPos  (Integer expression, the default is 1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F70>
<F71 desc="Compute the arc sine value of the parameter." displaystr="" majortype="102" name="asin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to compute the arcsine value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F71>
<F72 desc="Return the inverse hyperbolic sine" displaystr="" majortype="102" name="asinh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the inverse hyperbolic sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F72>
<F73 desc="Compute the arc tangent value of the parameter." displaystr="" majortype="102" name="atan" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Real number for which you want to compute the arctangent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F73>
<F74 desc="Return the inverse hyperbolic tangent" displaystr="" majortype="102" name="atanh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Any real number between -1 and 1)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F74>
<F75 desc="Retrieve an attached table from a cluster composite table." displaystr="" majortype="101" name="attach" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="T`(An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F75>
<F76 desc="Add an attached table to the base table of a composite table." displaystr="" majortype="101" name="attach" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="T`(An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C(Attached table column, can be omitted; return an attached table named T’ if it is absent; a C preceded by # is a dimension )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F76>
<F77 desc="Open a composite table’s attached table" displaystr="" majortype="101" name="attach" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F77>
<F78 desc="Compute the average value of the non-null members in a sequence.Equivalent to avg(x1,…,xn)" displaystr="" majortype="101" name="avg" postfix="A." returntype="101">
<options/>
<params/>
</F78>
<F79 desc="Compute x on each member of the sequence and then compute the average value of the non-null sequence members.Equivalent to A.(x).avg()" displaystr="" majortype="101" name="avg" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F79>
<F80 desc="Read and Avro data file." displaystr="avro(avrofile,schemafile;Fi...)" majortype="102" name="avro" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a cursor." optionchar="c"/>
</options>
<params>
<P1 desc="avrofile(Avro file object; cannot be omitted.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="schemafile(The avsc file object describing data structure.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi(Field name.)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F80>
<F81 desc="Base64-encode the given data" displaystr="" majortype="102" name="base64" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (BLOB data or an ordinary string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Charset)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="cs`(Charset)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F81>
<F82 desc="Check if Parameter1 is between Parameter 2 and Parameter 3 according to a passed-in parameter." displaystr="" majortype="102" name="between" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The interval is left-open and right-closed" optionchar="l"/>
<O2 defaultselect="false" description="The interval is right-open and left-closed " optionchar="r"/>
<O3 defaultselect="false" description="Make the function returns -1 if x&lt;a; returns 1 if b&lt;x; and retrun 0 for the rest of the cases" optionchar="b"/>
</options>
<params>
<P1 desc="x (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (An expression that returns value of any data type that is capable of being compared, including numbers, strings, dates, and sequences.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F82>
<F83 desc="Split a low-frequency categorical enumerated sequence variable that contains a number of categories not greater than 6 into multiple binary variables during modeling" displaystr="" majortype="101" name="bi" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="Rec(A sequence of splitting process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F83>
<F84 desc="Split a low-frequency categorical enumerated table sequence/record sequence variable that contains a number of categories not greater than 6 into multiple binary variables during modeling" displaystr="" majortype="101" name="bi" postfix="P." returntype="101">
<options/>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of splitting process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F84>
<F85 desc="Get the number of 1s in a specified number’s complement binary" displaystr="" majortype="102" name="bit1" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x(A long integer or a sequence of long integers)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F85>
<F86 desc="Calculate bitwise XOR on the specified numbers and get the number of 1s in the result’s complement binary" displaystr="" majortype="102" name="bit1" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x(A long integer or a sequence of long integers)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(A long integer or a sequence of long integers)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F86>
<F87 desc="Convert a sequence of bit values to a sequence of long numeric values" displaystr="" majortype="101" name="bits" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="When A consists of Boolean members, convert to 1 for true and to 0 for false " optionchar="b"/>
</options>
<params/>
</F87>
<F88 desc="The inverse operation of A.bits() function; get value of the nth bit" displaystr="" majortype="101" name="bits" postfix="B." returntype="101">
<options>
<O1 defaultselect="false" description="Judge whether value of the nth bit in sequence B is 1; the function returns true when the bit value is 1; and returns false when it is 0" optionchar="b"/>
</options>
<params>
<P1 desc="n(An integer representing the nth bit)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F88>
<F89 desc="Judge whether value of the nth bit in sequence B is 1; the function returns true when the bit value is 1; and returns false when it is 0" displaystr="" majortype="102" name="bits" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Convert xi to integer decimal number according to the rules of hexadecimal numeral system if it is the string" optionchar="h"/>
<O2 defaultselect="false" description="First convert xi to an integer if it is the string and then calculate according to the rules of decimal numeral system " optionchar="d"/>
<O3 defaultselect="false" description="Convert to 0 if parameter xi is false and to 1 if the parameter is true, and then convert them to a decimal number according to the rules of binary system " optionchar="b"/>
<O4 defaultselect="false" description="Won’t convert to a decimal number and should work with another option to return the string forming the number of the corresponding numeral system" optionchar="s"/>
<O5 defaultselect="false" description="Enable returning a long integer" optionchar="n"/>
<O6 defaultselect="false" description="Enable putting lower bits before higher bits" optionchar="r"/>
</options>
<params>
<P1 desc="xi(An integer/string )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F89>
<F90 desc="Convert a blob object into an integer sequence, or vice versa." displaystr="" majortype="102" name="blob" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Every 4 bytes correspond to one int" optionchar="4"/>
<O2 defaultselect="false" description="Every 8 bytes correspond to one int" optionchar="8"/>
<O3 defaultselect="false" description="Every 4 bytes correspond to one float" optionchar="f"/>
<O4 defaultselect="false" description="Every 8 bytes correspond to one double" optionchar="d"/>
<O5 defaultselect="false" description="All the above options use little-endian; by default, use big-endian" optionchar="r"/>
</options>
<params>
<P1 desc="b(A blob object or an integer sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F90>
<F91 desc="Convert a data object to a boolean value" displaystr="" majortype="102" name="bool" postfix="" returntype="101">
<options/>
<params>
<P1 desc="expression (A constant or an expression that you want to convert to a boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F91>
<F92 desc="Compute an expression against a specified record and return the result.Compute x against the kth member of A" displaystr="" majortype="101" name="calc" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="k (an integer, specifying which record it is)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (an expression, which is generally a field name or a legal expression composed of field names, and &quot;~&quot; is used to reference the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F92>
<F93 desc="Compute an expression against a specified record and return the result. Compute x against the members of A specified by the integer sequence p " displaystr="" majortype="101" name="calc" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p   (an integer sequence, specifying which records they are)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x   (an expression, which is generally a field name or a legal expression composed of field names, and &quot;~&quot; is used to reference the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F93>
<F94 desc="Call a script file and return the first result set." displaystr="" majortype="102" name="call" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Disable the default buffer call" optionchar="r"/>
<O2 defaultselect="false" description="Generate a new task space and execute the script file using a new thread, and return the task space without waiting for the result to return; usually, the option is used to execute a script file that performs timed tasks or loop operations" optionchar="n"/>
</options>
<params>
<P1 desc="spl (A script file or scrpt file object in the format of .dfx/.splx/.spl)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="arg1 (Parameters)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F94>
<F95 desc="Allocate tasks among a sequence of nodes, execute the script, and return a sequence of values returned by all tasks." displaystr="" majortype="102" name="callx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable a random allocation " optionchar="a"/>
<O2 defaultselect="false" description="Enable allocating one task to all available nodes; the task is completed as long as one of the nodes does it successfully, and other nodes are thus terminated" optionchar="l"/>
</options>
<params>
<P1 desc="spl (A script file .dfx/.splx, for which an absolute or a relative path can be set. The relative path is the Search Path under the Tool-&gt;Option-&gt; [Environment] menu.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="...(The parameter for passing value to dfx. It is usually in the form of a sequence. The number of parameters to be passed to dfx is the number of the sequences. The parallel algorithm will divide a computational task into multiple subtasks according to the length of the parameter sequence and pass each member of the sequence to the corresponding subtask as the parameter value of dfx.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs (The server sequence in which each server is represented by a string in the form of &quot;address:port number&quot;, like &quot;192. 168. 0. 86: 4001&quot;. The absence of IP address means another process in the current physical machine; the absence of both IP address and port number while maintaining &quot;:&quot; means the current process )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="rdfx(A dfx script used that uses two parameters; it is used to perform reduce action, and can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F95>
<F96 desc="Perform the logical AND operation over members of a table sequence" displaystr="" majortype="102" name="cand" postfix="A." returntype="102">
<options/>
<params/>
</F96>
<F97 desc="Create canvas object" displaystr="" majortype="102" name="canvas" postfix="" returntype="101">
<options/>
<params/>
</F97>
<F98 desc="Return the value of the expression that satisfies the specified condition." displaystr="" majortype="102" name="case" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (Judge expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (Value expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="yi (result expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="y  (Default expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F98>
<F99 desc="Truncate the data at the specified position, and carry the remaining part if any." displaystr="" majortype="102" name="ceil" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be truncated)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (Integer number for specifying the truncation position;taken as 0 when it is omitted＞0: Move the decimal point to the right for nExp places,＜0: Move the decimal point to the left for nExp places,=0: Indicate the current decimal places)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F99>
<F100 desc="Return an Excel cell name according to specific row and column" displaystr="" majortype="102" name="cellname" postfix="" returntype="101">
<options/>
<params>
<P1 desc="r(The rth row in an Excel sheet, which is an integer greater than 0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c(The cth column in an Excel sheet, which is an integer greater than 0)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F100>
<F101 desc="Perform grouping &amp; aggregation using the composite table/multizone composite table’s preaggregation file." displaystr="" majortype="101" name="cgroup" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="@m(…;n),Enable parallel processing; parameter n is the number of parallel threads, which is the “max number of parallel threads” specified in the designer by default or parallelNum value configured in raqsoftConfig.xml by default when esProc is used by being integrated in the third-party application " optionchar="m"/>
</options>
<params>
<P1 desc="Fi(Grouping field)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(Aggregate expression)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Gi(Aggregate field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="w(Filtering condition; cannot omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="f(T’s preaggregation file; find the suitable one when there are multiple preaggregation files (f,…))" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F101>
<F102 desc="Create a channel." displaystr="" majortype="101" name="channel" postfix="" returntype="101">
<options/>
<params/>
</F102>
<F103 desc="Create a channel/cluster channel and push data in another cluster channel into it; equivalent to cs.push(channel())" displaystr="" majortype="101" name="channel" postfix="" returntype="101">
<options/>
<params>
<P1 desc="cs (A cursor or A cluster cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F103>
<F104 desc="Create a channel/cluster channel and push data in another cluster channel into it; equivalent to ch.push(channel())" displaystr="" majortype="102" name="channel" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ch (A channel or A cluster channel)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F104>
<F105 desc="According to the given Unicode or ASCII code, get the corresponding characters" displaystr="" majortype="102" name="char" postfix="" returntype="101">
<options/>
<params>
<P1 desc="int (Integer expression, Unicode code or ASCII code)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F105>
<F106 desc="Auto-identify the characer set used for a string or a text file." displaystr="" majortype="102" name="chardetect" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Get the character set from fn if it is a string or a binary variable" optionchar="v"/>
<O2 defaultselect="false" description="Return the list of all eligible character sets; return the first eligible one by default" optionchar="a"/>
</options>
<params>
<P1 desc="fn(The to-be-identified string or binary vlaue, name of the text file to be identified, or object/URL of the text file to be identified)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(The list of available character sets; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F106>
<F107 desc="Generate the binary value of a string according to the character set the latter uses, or vice versa." displaystr="" majortype="102" name="charencode" postfix="" returntype="102">
<options/>
<params>
<P1 desc="str(A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="rawtest(A binary value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="charset(A character set, such as UTF-8 and GB2312; default is the one currently used by the system)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F107>
<F108 desc="A chi-square inverse cumulative distribution function." displaystr="" majortype="102" name="chi2inv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(The p-value within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="v(Degrees of freedom (DF))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F108>
<F109 desc="Calculate p-value of chi-square test" displaystr="" majortype="101" name="chi_p" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence, which is a binary target)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence, which is a binary variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F109>
<F110 desc=" Write a number with the Chinese numerals" displaystr="" majortype="102" name="chn" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Write the specific number with the Chinese numeral system in the format of billion, ten thousand, thousand, hundred, ten in order" optionchar="a"/>
<O2 defaultselect="false" description="Write the specific number with upper case Chinese numerals" optionchar="u"/>
<O3 defaultselect="false" description="Write the specific number using Chinese characers used for numbers on renminbi banknotes" optionchar="b"/>
</options>
<params>
<P1 desc="x(If a function doesn’t work with an option or uses @a and @u options, parameter x should be an integer; if it cooperate with @b option, parameter x should be a float)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F110>
<F111 desc="Set system clipboard content." displaystr="" majortype="101" name="clipboard" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="If the clipboard content comes from Excel, record it to return; otherwise the function will return the content previously copied." optionchar="e"/>
</options>
<params>
<P1 desc="s (The content to be copied to clipboard, whose data type can be table sequence, string, numeric, date, time, and datetime; can be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F111>
<F112 desc="Close a cursor." displaystr="" majortype="101" name="close" postfix="cs." returntype="101">
<options/>
<params/>
</F112>
<F113 desc="Close a datasource connection." displaystr="" majortype="1" name="close" postfix="db." returntype="102">
<options/>
<params/>
</F113>
<F114 desc="Close a composite table or a cluster table." displaystr="" majortype="1" name="close" postfix="T." returntype="102">
<options/>
<params/>
</F114>
<F115 desc="Close a pseudo table." displaystr="" majortype="101" name="close" postfix="T." returntype="102">
<options/>
<params/>
</F115>
<F116 desc="Close QVM" displaystr="" majortype="102" name="close" postfix="qvm." returntype="102">
<options/>
<params/>
</F116>
<F117 desc="Compare the value of two expressions x and y.When comparing the value of two expressions x and y, return 0 if they are equal; return 1 if x is greater than y; return -1 if x is less than y. Note:An error will be reported if x and y cannot be compared." displaystr="" majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F117>
<F118 desc="Compare  two sequences A and B.When comparing two sequences A and B, compare the two members in the same position of A and B one by one. Return 0 if all the members are equal; for the first members those are not equal, return 1 if the one in A is larger and return -1 if the one in A is smaller.An error will be reported if A and B cannot be compared. If the members in the sequence A and B are not the same, and their beginning members are the same, then the value with less members will be smaller." displaystr="" majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A   (an n sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B   (an m sequence. If sequence B does not exist, then it will be taken as a 0 sequence by default, that is, comparison will be done between sequences A and [0…0])" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F118>
<F119 desc="When the lengths of sequences A and B are equal, compare members of them in normal order; return 1 if a member in A is larger and return -1 if a member in A is smaller and return 0 if all members are equal. If the length of sequence A is less than that of sequence B, return 1 if a member in A is larger and return -1 if a member in A is smaller; return -1 if members of sequence A are equal to their counterparts in sequence B.  When sequences A and B have same number of members, return 0 if all members are equal, otherwise compare members of them in a normal order; for the first members that are not equal, return 1 if the one in A is larger and return -1 if the one in A is smaller. Return 0 if the number of members in the two sequences are not the same and if the length of sequence A is greater than or equal to that of sequence B and if members in sequence B are equal to their counterparts in sequence A. " displaystr="" majortype="102" name="cmp" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A (A sequence whose length is n; can be a single value which is regarded as a sequence having one member)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B (A sequence whose length is m; can be a single value which is regarded as a sequence having one member )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F119>
<F120 desc="When parameter B is absent, sequence B is by default a sequence having members of 0s, then the comparison becomes one happening between sequence A and sequence [0…0] of the same lengh." displaystr="" majortype="101" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (A sequence whose length is n; can be a single value which is regarded as a sequence having one member)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="0" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F120>
<F121 desc="Compare two records r1 and r2. An error will be reported if r1 and r2 cannot be compared." displaystr="" majortype="102" name="cmp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="r1 (Record)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r2 (Record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F121>
<F122 desc="Calculate the modulus of a sequence of complex numbers" displaystr="" majortype="101" name="comabs" postfix="A." returntype="101">
<options/>
<params/>
</F122>
<F123 desc="Calculate the phase angle of complex numbers" displaystr="" majortype="101" name="comangle" postfix="A." returntype="101">
<options/>
<params/>
</F123>
<F124 desc="Return the number of combinations." displaystr="" majortype="102" name="combin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n (An integer that is the number of given objects)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (An integer that is the number of elements you want to pick from the given set of objects)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F124>
<F125 desc="Calculate a complex number’s complex conjugate" displaystr="" majortype="101" name="comconj" postfix="A." returntype="101">
<options/>
<params/>
</F125>
<F126 desc="Create complex exponentials" displaystr="" majortype="101" name="comexp" postfix="A." returntype="101">
<options/>
<params/>
</F126>
<F127 desc="Get a complex number’s imaginary part" displaystr="" majortype="102" name="comimage" postfix="A." returntype="102">
<options/>
<params/>
</F127>
<F128 desc="Commit the database transaction manually." displaystr="" majortype="1" name="commit" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params/>
</F128>
<F129 desc="Sort complex numbers in the form of complex conjugate pairs" displaystr="" majortype="101" name="compair" postfix="A." returntype="101">
<options/>
<params/>
</F129>
<F130 desc="Create a sequence of complex numbers using sequence A of real parts and sequence B of imaginary parts; if A and B do not have same length, automatically use 0 to fill the absent part." displaystr="" majortype="101" name="complex" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="A(A sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F130>
<F131 desc="Use sequence C of number pairs to create a sequence of complex numbers; if a member of C is a single value, take it as the real part by default and use 0 as the imaginary part." displaystr="" majortype="101" name="complex" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="C(A second-level sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F131>
<F132 desc="Get a complex number’s real part" displaystr="" majortype="101" name="comreal" postfix="A." returntype="101">
<options/>
<params/>
</F132>
<F133 desc="A sign function that only handles complex number" displaystr="" majortype="101" name="comsign" postfix="A." returntype="101">
<options/>
<params/>
</F133>
<F134 desc="Output complex numbers as strings in the form of a+bi" displaystr="" majortype="101" name="comstr" postfix="A." returntype="101">
<options/>
<params/>
</F134>
<F135 desc="Shift phase angles" displaystr="" majortype="102" name="comunwrap" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence of complex numbers)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tol(The jump threshold value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dim(Dimension; unwrap by column when its value is 1 and by row when its value is 2)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F135>
<F136 desc="Concatenate parameters into a string." displaystr="" majortype="102" name="concat" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (Any value that can be converted to a string; if it is a sequence, it will be broken up before concatenation.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F136>
<F137 desc="Concatenate members of a sequence with the delimiter and return result as a string." displaystr="" majortype="101" name="concat" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Add quotation marks to string members when concatenating them into a string. If this option is omitted, do not use the quotation marks." optionchar="q"/>
<O2 defaultselect="false" description="Concatenate with the comma" optionchar="c"/>
<O3 defaultselect="false" description="Enclose string members to be concatenated with single quotes" optionchar="i"/>
<O4 defaultselect="false" description="If members of the sequence are also sequences, create a newl line after concatenate members of each sequence members with the delimiter. The operations are equivalent to A.(~.concat(d)).concat(&quot;\n&quot;). If there are other options, perform the concatenation in the inner layer of the function. " optionchar="n"/>
</options>
<params>
<P1 desc="d (Delimiter)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F137>
<F138 desc="Use a delimiter to concatenate values of an aggregation field" displaystr="" majortype="102" name="concat" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Concatenate with the comma" optionchar="c"/>
<O2 defaultselect="false" description="Enclose each to-be-concatenated value with the single quotation marks" optionchar="i"/>
<O3 defaultselect="false" description="Enclose each to-be-concatenated value with the double quotation marks; won’t quote them when the option is absent" optionchar="q"/>
</options>
<params>
<P1 desc="x(Aggregation field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="d(A delimiter.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F138>
<F139 desc="Union the members of a cursor sequence, and return result as a multicursor." displaystr="" majortype="101" name="conj" postfix="CS." returntype="101">
<options/>
<params/>
</F139>
<F140 desc="Get concatenation of all sequence-type members" displaystr="" majortype="101" name="conj" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Recursively concatenate members until there isn’t any sequence members" optionchar="r"/>
<O2 defaultselect="false" description="Return a pure sequence when members of A are pure sequences/pure table sequences" optionchar="v"/>
</options>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F140>
<F141 desc="Split each of the records in a channel, union the members and return the resulting union as a channel." displaystr="" majortype="101" name="conj" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="...  (An expression that returns a record sequence/table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F141>
<F142 desc="Attach the action of splitting each of the records to a cursor and unioning the result members and return the original cursor." displaystr="" majortype="101" name="conj" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (An expression that returns a record sequence (or a table sequence))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F142>
<F143 desc="Split each record of a pseudo table and concatenate the splitting results" displaystr="" majortype="101" name="conj" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="...(An expression that returns a record sequence or a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F143>
<F144 desc="Establish a connection to a database." displaystr="" majortype="102" name="connect" postfix="" returntype="1">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params>
<P1 desc="dataSource (The name of a data source)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F144>
<F145 desc="Connect to a database through its driver and url in which the user name and password are written" displaystr="" majortype="102" name="connect" postfix="" returntype="1">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to  none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to  commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params>
<P1 desc="drv (Database driver class)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="url (Database driver connection URL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F145>
<F146 desc="Return the connection to a data source in the file system" displaystr="" majortype="102" name="connect" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Return field names and table names in lower case; by default it’s the database that handles the cases" optionchar="l"/>
<O2 defaultselect="false" description="If there is an error, return an error message to be processed automatically with the code; without the option, an interrupt occurs. " optionchar="e"/>
<O3 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to none" optionchar="n"/>
<O4 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to commit" optionchar="c"/>
<O5 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to uncommit" optionchar="u"/>
<O6 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to repeatable" optionchar="r"/>
<O7 defaultselect="false" description="Transaction isolation levels for the connection, corresponding respectively to serializable" optionchar="s"/>
</options>
<params/>
</F146>
<F147 desc="Check whether a given data object is a member of a certain sequence." displaystr="" majortype="101" name="contain" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="The option means that sequence A is ordered, based on which a binary search is performed in an ascending or descending order" optionchar="b"/>
<O2 defaultselect="false" description="Use HASH method to increase computing efficiency; for scenarios where the sequence has a large amount of data" optionchar="h"/>
</options>
<params>
<P1 desc="xi  (Data object, which can be a number, a string or a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F147>
<F148 desc="Perform logical OR operation over members of a sequence." displaystr="" majortype="101" name="cor" postfix="A." returntype="101">
<options/>
<params/>
</F148>
<F149 desc="Correct skewness of a numeric sequence" displaystr="" majortype="101" name="corskew" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the corrected result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(A sequence of correction and handling process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F149>
<F150 desc="Correct skewness of a numeric variable" displaystr="" majortype="101" name="corskew" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the corrected result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of correction and handling process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F150>
<F151 desc="Compute the cosine value" displaystr="" majortype="102" name="cos" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (The radian number of the cosine to be computed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F151>
<F152 desc="Return the hyperbolic cosine" displaystr="" majortype="102" name="cosh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the hyperbolic cosine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F152>
<F153 desc="Compute x with each member of the sequence and then count the number of non-null sequence members of the new sequence.  Equivalent to A.(x).count()" displaystr="" majortype="101" name="count" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x  (Generally an expression of a single field name, or a legal expression composed of multiple field names.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F153>
<F154 desc="Count the number of non-null members in a sequence.Equivalent to count(x1,…,xn)" displaystr="" majortype="101" name="count" postfix="A." returntype="101">
<options/>
<params/>
</F154>
<F155 desc="Calculate the covariance between two vectors." displaystr="" majortype="101" name="cov" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F155>
<F156 desc="Calculate the covariance matrix for a matrix." displaystr="" majortype="101" name="covm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F156>
<F157 desc="Create an empty table sequence." displaystr="" majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Fi    (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F157>
<F158 desc="Create an empty table sequence with one or more keys set." displaystr="" majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="#Fi  (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F158>
<F159 desc="Open a composite table." displaystr="" majortype="102" name="create" postfix="" returntype="101">
<options/>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="p (Write password/read password)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F159>
<F160 desc="Create a composite table from a corresponding file." displaystr="" majortype="2" name="create" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Do not compress the file; default is to compress it" optionchar="u"/>
<O2 defaultselect="false" description="Generate a rowwise file while default is columnar storage, which does not support the multicursor" optionchar="r"/>
<O3 defaultselect="false" description="Force to re-create the file even if the target file already exists; defalut is to terminate computation " optionchar="y"/>
<O4 defaultselect="false" description="Use the first field as the grouping key" optionchar="p"/>
<O5 defaultselect="false" description="When columnar storage is used to generate the composite table, check whether each of its columns is pure during data maintenance and save the data type" optionchar="v"/>
<O6 defaultselect="false" description="Create key for the composite table (including multizone composite table) using dimensions and the last key field is the time key; in this case no attached table is allowed " optionchar="t"/>
<O7 defaultselect="false" description="Used on a multizone composite table; the first field after key fields is regarded as the deletion mark field, whose values are Boolean type; a deletion mark value that is true means the record is deleted and is used for judging whether the current record is deleted or not when data is retrieved from a multizone composite table" optionchar="d"/>
</options>
<params>
<P1 desc="C(A column of the would-be composite table)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(A zone table expression, whose result is the integer representing the corresponding zone table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b(Block size, whose unit is byte. Default value is the “Composite table block size” configured in the configuration options; when esProc is integrated into a third-party application, the parameter’s default value is value of blockSize configured in raqsoftConfig.xml file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F160>
<F161 desc="Create an empty table sequence by duplicating the data structure of table sequence T." displaystr="" majortype="101" name="create" postfix="T." returntype="101">
<options/>
<params/>
</F161>
<F162 desc="Create a table sequence by copying the data structure of a specified record." displaystr="" majortype="101" name="create" postfix="r." returntype="101">
<options/>
<params/>
</F162>
<F163 desc="Generate a new empty table sequence by copying data structure of a specific record sequence" displaystr="" majortype="101" name="create" postfix="P." returntype="101">
<options/>
<params/>
</F163>
<F164 desc="Create a new composite table file using the data structure of an existing composite table" displaystr="" majortype="101" name="create" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Do not compress data; use compression by default" optionchar="u"/>
<O2 defaultselect="false" description="Generate a row-oriented file while by default generate a column-oriented one; a row-oriented composite table cannot use multicursor; do not compress a row-oriented file" optionchar="r"/>
<O3 defaultselect="false" description="Forcibly to create the file even if a namesake one already exists; by default terminate the computation" optionchar="y"/>
</options>
<params>
<P1 desc="f(A composite table file or a file group)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b(Block size, whose unit is byte and whose default value is 【composite table block size】configured through menu option; when esProc is integrated in the third-party application, use blockSize value configured in raqsoftConfig.xml by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(An integer, which is the zone table expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F164>
<F165 desc="Generate preaggregation file for a composite table/multizone composite table" displaystr="" majortype="101" name="cuboid" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="f(Preaggregation file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi(Grouping field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="y(Aggregate expression; aggregate functions supported are sum/count/avg/max/min/top/)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F165>
<F166 desc="An interative loop to get a cumulative value over records in which one of its fields has same values." displaystr="" majortype="102" name="cum" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F166>
<F167 desc="Compute sum of members of a sequence" displaystr="" majortype="101" name="cumulate" postfix="A." returntype="101">
<options/>
<params/>
</F167>
<F168 desc="Call a cellset file and return the resut set returned from the execution of the file as a cursor." displaystr="" majortype="102" name="cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The dfx can be represented by a cell that corresponds to a subroutine defined by func() function" optionchar="c"/>
</options>
<params>
<P1 desc="dfx (cellset file name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="... (dfx parameter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F168>
<F169 desc="Generate a cursor from a sequence." displaystr="" majortype="101" name="cursor" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Assume data is ordered by the first field and the division won’t put records having same first field to different segments; ignore parameters k and n when this option works" optionchar="p"/>
</options>
<params>
<P1 desc="k (Segment number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of data segments; retrieve all data out when both k and n are omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F169>
<F170 desc="Create a database cursor by executing an SQL statement" displaystr="" majortype="1" name="cursor" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="If the result set has only one column, the content of the returned cursor is a sequence" optionchar="i"/>
<O2 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type" optionchar="d"/>
<O3 defaultselect="false" description="Disconnect from the database automatically when the cursor is closed; this option applies to connect -mode database connection only; with this option, the cursor the function returns is irreversible" optionchar="x"/>
<O4 defaultselect="false" description="Generate a cursor of pure table sequence or pure sequence" optionchar="v"/>
</options>
<params>
<P1 desc="sql  (A SQL query statement)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args(Parameters passed to SQL, which can be values or names defined; separate multiple parameters with comma)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F170>
<F171 desc="Create a cursor based on a file." displaystr="" majortype="2" name="cursor" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameters Fi, k and n, and with no support for parameters type and s. Ignore options @t, @s, @i, @q . The segmental retrieval could result in empty segment in cases when a file has only a very small number of records; error report appears if the file isn’t retrieved by segment." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Delete the source file automatically on closing the cursor; the cursor that the function returns is irreversible when this option works" optionchar="x"/>
<O5 defaultselect="false" description="Not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O6 defaultselect="false" description="If the result set has only one column, the content of the returned cursor will be a sequence." optionchar="i"/>
<O7 defaultselect="false" description="Remove the quotation marks, if any, from the field strings, including the field names, in the first place, and handle escape sequences." optionchar="q"/>
<O8 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="With the option, the f.cursor@m(Fi:type,…;n,s) function returns a multicursor;  here parameter n is the number of segments; use the value of 【Default subcursor count in a multicursor】defined in the designer as the number subcursors if the option is absent; when integrating esProc into a third-party application, use cursorParallelNum value configured in raqsoftConfig.xml file as the default" optionchar="m"/>
<O10 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O11 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O12 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O13 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O14 defaultselect="false" description="Throw an exception, terminate the execution and output the content of the problem record when errors appear in @d check and @n check" optionchar="v"/>
</options>
<params/>
</F171>
<F172 desc="Create a cursor based on a file." displaystr="" majortype="2" name="cursor" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="se the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameters Fi, k and n, and with no support for parameters type and s. Ignore options @t, @s, @i, @q and @m. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records; error report appears if the file isn’t retrieved by segment." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Delete the source file automatically on closing the cursor." optionchar="x"/>
<O5 defaultselect="false" description="Not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O6 defaultselect="false" description="If the result set has only one column, the content of the returned cursor will be a sequence." optionchar="i"/>
<O7 defaultselect="false" description="Remove the quotation marks, if any, from the field strings, including the field names, in the first place, and handle escape sequences." optionchar="q"/>
<O8 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O9 defaultselect="false" description="With the option, the f.cursor@m(Fi:type,…;n,s) function returns a multicursor;  parameter n is the number of segments and can be omitted" optionchar="m"/>
<O10 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O11 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O12 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O13 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O14 defaultselect="false" description="Verify data type matching, and, if error reports, throw an exception, terminate the execution and output the content of the problem record" optionchar="v"/>
<O15 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are treated as quotes" optionchar="a"/>
<O16 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O17 defaultselect="false" description="Split the file content into a string by the separator without parsing" optionchar="f"/>
<O18 defaultselect="false" description="Allow line continuation if there is an escape character \ at the end of the line" optionchar="l"/>
</options>
<params>
<P1 desc="Fi (Fields to be retrieved; all fields will be retrieved by default. The to-be-retrieved field(s) can be represented by their sequence numbers headed by the sign #.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type (Field types. Include bool, int, long, float, decimal,  string, date, time and datetime),Data type of the first row will be used by default." filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="k  (The segment number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n(The number of segments. Retrieve the whole file when both k and n are omitted )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (The number of segments. Retrieve the whole file when both k and n are omitted  )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F172>
<F173 desc="Segment an entity table or an in-memory table or a multi-zone composite table and return the cursor of a specified segment" displaystr="" majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The T.cursor@m(x:C…;wi,...;n) function with this option generates a multicursor segmented into n parts. n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent" optionchar="m"/>
<O2 defaultselect="false" description="Generate a pure table sequence-based column-wise cursor, which has higher performance than regular cursors" optionchar="v"/>
<O3 defaultselect="false" description="Automatically close the entity table/in-memory table after data in the cursor is fetched" optionchar="x"/>
<O4 defaultselect="false" description="Get records in order without merging zone tables when T is a multi-zone composite table; all zone tables are segmented synchronously" optionchar="o"/>
<O5 defaultselect="false" description="Used on a multizone composite table; Perform update merge; when zone tables share a same key value, ignore the record contained in the zone table with a smaller number; segmentation is performed according to the way zone table 1 is split; retrieve a zone table after the first one wholly if they are small enough; Handle the deletion mark and do not return records with a deletion mark to the cursor; but if the key value of a record with the deletion mark is unique in the multizone composite table, just retain it; This option enables retrieving key field(s) as well as the deletion mark field, if there is one, forcefully " optionchar="w"/>
<O6 defaultselect="false" description="Get data in the inverse order; do not support segmentation in this case" optionchar="z"/>
</options>
<params>
<P1 desc="x (Expression; by default all fields of T will be returned to the cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (Column alias; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="wi(Filtering condition; separate multiple conditions by comma(s) and their relationships are AND; besides regular filtering expressions, you can also use the following five types of syntax in a filtering condition, where K is a field in the entity table: 1．K=w w usually uses expression Ti.find(K) or Ti.pfind(K), where Ti is a table sequence. When value of w is null or false, the corresponding record in the entity table will be filtered away; when w is expression Ti.find(K) and the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K; when w is expression Ti.pfind(K) and the to-be-selected fields C,... contain K, ordinal numbers of K values in Ti will be assigned to K. 2．(K1=w1,…Ki=wi,w) Ki=wi is an assignment expression. Generally, parameter wi can use expression Ti.find(Ki) or Ti.pfind(K), where Ti is a table sequence; when wi is expression Ti.find(K) and the to-be-selected fields C,... contain Ki, Ti’s referencing field will be assigned to Ki correspondingly; when wi is expression Ti.pfind(Ki) and the to-be-selected fields C,... contain Ki, ordinal numbers of Ki values in Ti will be assigned to Ki.  w is a filter expression; you can reference Ki in w. 3．K:Ti Ti is a table sequence. Compare Ki value in the entity table with key values of Ti and discard records whose Ki value does not match; when the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K. 4．K:Ti:null Filter away all records that satisfy K:Ti. 5．K:Ti:# Locate records according to ordinal numbers, compare ordinal numbers of records in table sequence Ti according to the entity table’s K values, and discard non-matching records; when the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K.  )" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="k (A positive integer (k≤n) representing the kth segment )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="n (A positive integer representing the number of segments; return all records when parameters k:n are absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F173>
<F174 desc="Return the specified column(s) in a cluster entity table/cluster memory table as a cluster cursor." displaystr="" majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The function with this option generates a cluster multicursor synchronously segmented into n parts. n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent. " optionchar="m"/>
</options>
<params>
<P1 desc="x (Expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="wi(Filtering condition; multiple conditions are separated by comma(s) and their relationships are AND)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F174>
<F175 desc="Synchronously segment an entity table/in-memory table/multi-zone composite table according to a multicursor and return a multicursor." displaystr="" majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Perform matching using the multicursor’s first field of the key" optionchar="k"/>
<O2 defaultselect="false" description="Generate a pure table sequence-based column-wise cursor, which has higher performance than regular cursors" optionchar="v"/>
<O3 defaultselect="false" description="Automatically close the entity table after data is fetched from the cursor" optionchar="x"/>
<O4 defaultselect="false" description="Do not merge zone tables but retrieve data according to the order of zone tables when T is a multizone composite table" optionchar="o"/>
<O5 defaultselect="false" description="Used on a multizone composite table; Perform update merge; when zone tables share a same key value, ignore the record contained in the zone table with a smaller number; segmentation is performed according to the way zone table 1 is split; retrieve a zone table after the first one wholly if they are small enough; Handle the deletion mark and do not return records with a deletion mark to the cursor; but if the key value of a record with the deletion mark is unique in the multizone composite table, just retain it; This option enables retrieving key field(s) as well as the deletion mark field, if there is one, forcefully " optionchar="w"/>
</options>
<params>
<P1 desc="x (Expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (Column alias )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="wi(Filtering condition; separate multiple conditions by comma(s) and their relationships are AND; besides regular filtering expressions, you can also use the following five types of syntax in a filtering condition, where K is a field in the entity table: 1．K=w w usually uses expression Ti.find(K) or Ti.pfind(K), where Ti is a table sequence. When value of w is null or false, the corresponding record in the entity table will be filtered away; when w is expression Ti.find(K) and the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K; when w is expression Ti.pfind(K) and the to-be-selected fields C,... contain K, ordinal numbers of K values in Ti will be assigned to K. 2．(K1=w1,…Ki=wi,w) Ki=wi is an assignment expression. Generally, parameter wi can use expression Ti.find(Ki) or Ti.pfind(K), where Ti is a table sequence; when wi is expression Ti.find(K) and the to-be-selected fields C,... contain Ki, Ti’s referencing field will be assigned to Ki correspondingly; when wi is expression Ti.pfind(Ki) and the to-be-selected fields C,... contain Ki, ordinal numbers of Ki values in Ti will be assigned to Ki.  w is a filter expression; you can reference Ki in w. 3．K:Ti Ti is a table sequence. Compare Ki value in the entity table with key values of Ti and discard records whose Ki value does not match; when the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K. 4．K:Ti:null Filter away all records that satisfy K:Ti. 5．K:Ti:# Locate records according to ordinal numbers, compare ordinal numbers of records in table sequence Ti according to the entity table’s K values, and discard non-matching records; when the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K.   )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="msc (A multicursor generated from an entity table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F175>
<F176 desc="Synchronously segment a cluster entity table according to a cluster multicursor and return a cluster multicursor." displaystr="" majortype="101" name="cursor" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="x(Expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C(To-be-displayed columns; by default all columns are displayed)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="wi(Filtering condition; retrieve the whole set when this parameter is absent; separate multiple conditions by comma(s) and their relationships are AND)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="mcs(A cluster multicursor generated from a cluster entity table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F176>
<F177 desc="Segment a memory table/cluster memory table and return cursor of the specified segment." displaystr="" majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="T.cursor@m(...;n) returns a multicursor segmented into n parts; n is an integer; the function returns an ordinary cursor if n&lt;2; use the max number of segments set in【Tool】-【Options】if n is absent " optionchar="m"/>
</options>
<params>
<P1 desc="C(Column name in the memory table)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="wi(Filtering condition; multiple conditions are separated by comma(s) and they must be met at the same time. You can use expression K:Ti (K is a field in the entity table; Ti is a table sequence whose primary key is K) in a condition. The expression means filtering away records where K=Ti.find(K) is false.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k(A positive integer (k≤n) representing the kth segment)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n(A positive integer representing the number of segments)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F177>
<F178 desc="Divide a memory table in sync with a memory multicursor and return it also as a memory multicursor." displaystr="" majortype="102" name="cursor" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="..." filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="mcs(A multicursor generated from a memory table or a composite table)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F178>
<F179 desc="Merge subcursors in a multicursor into a single cursor or a new multicursor with a smaller number of parallel subcursors." displaystr="" majortype="101" name="cursor" postfix="mcs." returntype="101">
<options/>
<params>
<P1 desc="n(Subcursor column name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F179>
<F180 desc="Get a cursor based on a pseudo table object" displaystr="" majortype="101" name="cursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description=" Store the composite table in the column-wise format when loading it the first time, which helps to increase performance" optionchar="v"/>
</options>
<params>
<P1 desc="xi (A field expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ci (Field name in a result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F180>
<F181 desc="Get the date part of the datetime value." displaystr="" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (Datetime value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F181>
<F182 desc="Convert stringExp to a date value according to the format defined by format and return null if the conversion fails; parameter loc is the language used in stringExp; the default is the system language" displaystr="" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (String expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (Format string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F182>
<F183 desc="The format of the result returned by stringExp should be in consistent with the date format in configuration information; if time is contained in the result, the time will not be converted; return null if the conversion fails" displaystr="" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (String expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F183>
<F184 desc="Convert year,month,day of integer type to date type; return null if the conversion fails" displaystr="" majortype="102" name="date" postfix="" returntype="101">
<options/>
<params>
<P1 desc="year (Integer) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="month (Integer) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="day (Integer )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F184>
<F185 desc="Convert integer ym and day into date data" displaystr="" majortype="102" name="date" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ym (6-bit integer interpreted as year and month)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="day (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F185>
<F186 desc="Convert long integer longExp to date type data" displaystr="" majortype="102" name="date" postfix="" returntype="102">
<options/>
<params>
<P1 desc="longExp(64-bit loing integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F186>
<F187 desc="Return the time and date of a file last modified." displaystr="" majortype="2" name="date" postfix="f." returntype="101">
<options/>
<params/>
</F187>
<F188 desc="Convert a string, an integer, or a long integer to a date value" displaystr="" majortype="102" name="date" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="date@o(day), Convert integer type day to date type data; parameter day can be regarded as the value of computing days@o()" optionchar="o"/>
</options>
<params>
<P1 desc="day(Integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F188>
<F189 desc="Generate multiple derivative variables from a datetime sequence variable" displaystr="" majortype="101" name="datederive" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(The target variable value used to perform potential data smoothing)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of generation process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F189>
<F190 desc="Generate multiple derivative variables from a date table sequence/record sequence variable" displaystr="" majortype="101" name="datederive" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(The target variable value used to perform potential data smoothing)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Rec(A sequence of generation process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F190>
<F191 desc="Generate multiple date difference variables for a datetime sequence/table sequence variable" displaystr="" majortype="101" name="dateinterval" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(The target variable value used to perform potential data smoothing)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of generation process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F191>
<F192 desc="Generate multiple date difference variables for a datetime table sequence/record sequence variable" displaystr="" majortype="101" name="dateinterval" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="cns(A sequence of names of columns ( or column numbers starting from 1) of a record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(A sequence of target variable values used to perform potential data smoothing)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Rec(A sequence of generation process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F192>
<F193 desc="Adjust the precision of the datetime expression and return it." displaystr="" majortype="102" name="datetime" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Measure to minute" optionchar="m"/>
<O2 defaultselect="false" description="Measure to second" optionchar="s"/>
<O3 defaultselect="false" description="Accurate to hour" optionchar="h"/>
</options>
<params>
<P1 desc="datetimeExp (datetime value )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F193>
<F194 desc="Convert the data type of string to datetime type according to the format defined by format and return null if the conversion fails; if parameter format doesn’t exist, the format of string of string type should be the same as the format of datatime value in configuration informationt; parameter loc is the language used in stringExp; the default is the system language" displaystr="" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (Format string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F194>
<F195 desc="Convert long of long integer type to datetime value" displaystr="" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="long (Long integer counted in microseconds)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F195>
<F196 desc="Concatenate date type data and time type data into data of datetime type" displaystr="" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="date (Date type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="time (Time type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F196>
<F197 desc="Convert y,m,d,h,m,s of integer type to datetime data" displaystr="" majortype="102" name="datetime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="y   (Positive integer, year)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="m  (Positive integer, month)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="d  (Positive integer, day)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="h  (Positive integer, hour)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="m (Positive integer, minute)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="s  (Positive integer, second)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F197>
<F198 desc="Convert integer ym, d, h, m, s into datetime data" displaystr="" majortype="102" name="datetime" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ym (6-bit positive integer interpreted as year and month)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="d (Positive integer, day)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (Positive integer, hour)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="m (Positive integer, minute)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (Positive integer, second)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F198>
<F199 desc="Get the day from a date value." displaystr="" majortype="102" name="day" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Get the day of the week from the specified date. For Sunday, return 1; For Monday, return 2, and so on. By default, get the day of the month from the specified date." optionchar="w"/>
</options>
<params>
<P1 desc="dateExp     (Date expression whose result is the date or the string of Chinese date and time format. dateExp can be an integer, which we can regard as the value of computing days@o().)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F199>
<F200 desc="Get the number of days of the year, quarter or month to which the specified date belongs." displaystr="" majortype="102" name="days" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Get the number of days of the quarter to which the specified date belongs" optionchar="q"/>
<O2 defaultselect="false" description="Get the number of days of the year to which the specified date belongs By default get the number of days of the month to which the specified date belongs " optionchar="y"/>
<O3 defaultselect="false" description="Get an integer according to the specified date" optionchar="o"/>
</options>
<params>
<P1 desc="dateExp     (A date or a date string of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F200>
<F201 desc="Convert a string or a numeric value to a big decimal number" displaystr="" majortype="102" name="decimal" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (A numeric string or a number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F201>
<F202 desc="Delete specified records from a table sequence.  Delete the kth record" displaystr="" majortype="102" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="k (A positive integer, which specifies the position of a record to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F202>
<F203 desc="Delete specified records from a table sequence.  Delete the records whose sequence numbers exist in p" displaystr="" majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="p (An integer sequence with the length of n, which specifies the positions of the records to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F203>
<F204 desc="Delete specified records from a table sequence.  Delete the records that exist in sequence  A" displaystr="" majortype="101" name="delete" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="A (A sequence, which specifies the records to be deleted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F204>
<F205 desc="Delete the kth member" displaystr="" majortype="101" name="delete" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="k  (A positive integer that indicates the position of a member to be deleted in the sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F205>
<F206 desc="Delete the members whose sequence numbers exist in p" displaystr="" majortype="101" name="delete" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the deleted record or a record sequence of the deleted records" optionchar="n"/>
</options>
<params>
<P1 desc="p  (An integer sequence with the length of n that specifies the positions of the members to be deleted) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F206>
<F207 desc="Compare the specified two dates." displaystr="" majortype="102" name="deq" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Accurate to the year" optionchar="y"/>
<O2 defaultselect="false" description="Accurate to the quarter" optionchar="q"/>
<O3 defaultselect="false" description="Accurate to the month" optionchar="m"/>
<O4 defaultselect="false" description="Accurate to the ten-day period" optionchar="t"/>
<O5 defaultselect="false" description="Accurate to the week; take Sunday as the first day of the week" optionchar="w"/>
<O6 defaultselect="false" description="Work with @w option and take Mondy as the first day of the week; it is number 1 that is used in the option" optionchar="1"/>
</options>
<params>
<P1 desc="datetimeExp1 (Date or standard datetime formate string  such as yyyy-MM-dd HH:mm:ss, yyyy-MM-dd, or HH:mm:ss )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="datetimeExp2 (Date or standard datetime formate string  such as yyyy-MM-dd HH:mm:ss, yyyy-MM-dd, or HH:mm:ss )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F207>
<F208 desc="Add one or more fields to a table sequence or a record sequence. " displaystr="" majortype="101" name="derive" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks to enhance performance; no definite order for the records in the result set. " optionchar="m"/>
<O2 defaultselect="false" description="Won’t generate a record if there is expression xi and its result is null (this won’t affect a record with null value in the original table sequence)" optionchar="i"/>
<O3 defaultselect="false" description="@x(…;n) Unfold original fields whose values are records into n levels; default of n is 2" optionchar="x"/>
<O4 defaultselect="false" description="When parameter A is a pure table sequence, add columns directly to it instead of generating a new table sequence" optionchar="o"/>
<O5 defaultselect="false" description="Perform the inverse operation; only applies to non-pure sequences" optionchar="z"/>
</options>
<params>
<P1 desc="xi      (Expression, whose results are used as the values of the derived fields )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi      (Field name, which shouldn’t have the same name as any of the original fields in P)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F208>
<F209 desc="Generate a table sequence according to a record sequence." displaystr="" majortype="101" name="derive" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Do not copy the record sequence’s data structure, which will change the record sequence’s structure and which will adjust the number of fields as needed. The option will achieve a better performance as well as an increased risk of error. It’s recommended to be used only when the original record sequence is no longer needed. The option is disabled when there are pure table sequence records in the record sequence. " optionchar="o"/>
</options>
<params/>
</F209>
<F210 desc="Add fields to records in a channel." displaystr="" majortype="101" name="derive" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a corresponding record if there is expression xi  and its result is null; won’t affect the field values of existing fields." optionchar="i"/>
</options>
<params>
<P1 desc="xi  (An expression, whose results will be the values of the new fields)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name, which shouldn’t be same as one of the existing ones)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F210>
<F211 desc="Attach the action of adding fields to a cursor and return the original cursor." displaystr="" majortype="101" name="derive" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a record if there is expression xi and its result  is null (this won’t affect a record with null value in the original table sequence)" optionchar="i"/>
</options>
<params>
<P1 desc="xi (Expression, whose computed results are the field values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi ( Field name. In this case, Fi cannot be of the same name to the existing fields in cs )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F211>
<F212 desc="Add new fields to a pseudo table" displaystr="" majortype="101" name="derive" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Do not generate a corresponding record for a row when parameter xi is present and its computing result is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi(Expression, whose results are used as field values)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi(Field names, which should not be same as names of the existing fields in T)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F212>
<F213 desc="Calculate the determinant of a square matrix." displaystr="" majortype="101" name="det" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Square matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F213>
<F214 desc="Generate a new sequence by removing from the first sub-sequence of a sequence the members that exist in the other sub-sequences of the sequence." displaystr="" majortype="101" name="diff" postfix="A." returntype="101">
<options/>
<params/>
</F214>
<F215 desc="Calculate difference between the sequence-type members in a specified sequence to generate a new sequence where the first subsequence won’t contain members that exist in the other sub-sequences. " displaystr="" majortype="101" name="diff" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (An expression that returns a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F215>
<F216 desc="Convert a numeric string of certain numeral system to a specific numeral system" displaystr="" majortype="102" name="digits" postfix="" returntype="102">
<options/>
<params>
<P1 desc="x(Numeric string; use letters to represent a number greater than 10 )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ds(An integer specifying a numeral system)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="dd(An integer specifying a numeral system)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F216>
<F217 desc="List the file name(s) satisfying a wildcard path." displaystr="" majortype="101" name="directory" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="List the subdirectory ofpath" optionchar="d"/>
<O2 defaultselect="false" description="List the name of returned file, and the returned results will enclose the name of full path" optionchar="p"/>
<O3 defaultselect="false" description="Create directory" optionchar="m"/>
<O4 defaultselect="false" description="Delete record and the record must be null" optionchar="r"/>
<O5 defaultselect="false" description="Perform recursive query to get all file names under all subdirectories; mutually exclusive with @m and @r" optionchar="s"/>
<O6 defaultselect="false" description="Make case-insensitive; without it the OS will have a say" optionchar="c"/>
</options>
<params>
<P1 desc="path   (wildcard path, * indicates 0 or several characters, and ? indicates a single character)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F217>
<F218 desc="Calculate the Euclidean distance between two vectors." displaystr="" majortype="101" name="dis" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Calculate the sum of absolute values of the differences between numbers at same positions in vector A and vector B" optionchar="a"/>
<O2 defaultselect="false" description="Average out the Euclidean distance before getting its square root " optionchar="m"/>
</options>
<params>
<P1 desc="A(Vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F218>
<F219 desc="Calculate Mahalanobis distance between two vectors on covariance matrix. " displaystr="" majortype="101" name="dism" postfix="" returntype="101">
<options/>
<params>
<P1 desc="X(Vectors of same dimension with the covariance matrix C)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(Vectors of same dimension with the covariance matrix C)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C(A covariance matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F219>
<F220 desc="Create DQL connection." displaystr="" majortype="102" name="dql" postfix="" returntype="102">
<options/>
<params>
<P1 desc="meta(The metadata file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F220>
<F221 desc="Draw canvas" displaystr="" majortype="101" name="draw" postfix="G." returntype="101">
<options>
<O1 defaultselect="false" description="Return a JPG canvas" optionchar="j"/>
<O2 defaultselect="false" description="Return a GIF canvas" optionchar="g"/>
<O3 defaultselect="false" description="Return a PNG canvas" optionchar="p"/>
</options>
<params>
<P1 desc="w (Width of canvas in pixels)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="h (Height of canvas inpixels)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F221>
<F222 desc="Join up cluster memory table into a local memory table." displaystr="" majortype="101" name="dup" postfix="T." returntype="101">
<options/>
<params/>
</F222>
<F223 desc="Copy a local memory table onto nodes to create a duplicate cluster memory table." displaystr="" majortype="101" name="dup" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="h(A node or a node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F223>
<F224 desc="Access local DynamoDB." displaystr="" majortype="102" name="dyna_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="dyna_url(URL for accessing DynamoDB)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="region(The AWS service region for use)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F224>
<F225 desc="Close connection to Amazon DynamoDB." displaystr="" majortype="102" name="close" postfix="dynadb." returntype="102">
<options/>
<params/>
</F225>
<F226 desc="Execute a calculation on data in a DynamoDB table" displaystr="" majortype="102" name="execute" postfix="dynadb." returntype="101">
<options/>
<params>
<P1 desc="A(A sequence on which the sql statement is executed circularly while calculating different parameter values  to pass to sql for execution )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(A sql statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F226>
<F227 desc="Query data stored in DynamoDB." displaystr="" majortype="102" name="query" postfix="dynadb." returntype="101">
<options/>
<params>
<P1 desc="A(A sequence on which the sql statement is executed circularly while calculating different parameter values  to pass to sql for execution )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F227>
<F228 desc="Create or delete a Dynamodb table" displaystr="" majortype="102" name="table" postfix="dynadb." returntype="101">
<options>
<O1 defaultselect="false" description="Perform table deletion" optionchar="d"/>
</options>
<params>
<P1 desc="tableName(Table name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="partitionKey(The main partition key)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="type1/type2(Data types S, N and B, which represent string, number and binary respectively; default type is S; when type2 is present, type1 cannot be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="sortKey(The sorting key, which can be omitted at table creation)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F228>
<F229 desc="Get the date/time which is a certain time period before or after a given date/time." displaystr="" majortype="102" name="elapse" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Compute the date which is k years before or after the specified date." optionchar="y"/>
<O2 defaultselect="false" description="Compute the date which is k quarters before or after the specified date." optionchar="q"/>
<O3 defaultselect="false" description="Compute the date which is k months before or after the specified date." optionchar="m"/>
<O4 defaultselect="false" description="If the specified date is the last day of a month, the new date will not be adjusted to the last day of the month to which it belongs. Without the option the new date will be automatically adjusted to the last day of the corresponding month. This option works with @yqm." optionchar="e"/>
<O5 defaultselect="false" description="Compute the datetime which is k seconds before or after the specified datetime" optionchar="s"/>
<O6 defaultselect="false" description="Compute the datetime which is k milliseconds before or after the specified datetime; by default the function computes the date which is n days after the specified date." optionchar="ms"/>
</options>
<params>
<P1 desc="t(A given start date; When this parameter is datetime type, the function returns a string of date format or datetime format; When this parameter is an integer, the function is equivalent to days@o() that returns an integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k(An integer expression; the negative value means finding a date k time period before)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F229>
<F230 desc="An external libaray function that builds models and performs predictions using the elastic net regression method." displaystr="" majortype="102" name="elasticnet" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Number of iterations; default is 1000)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="l1(Coefficient 11; default is 0.9)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="l2(Coefficient 12; default is 0.1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F230>
<F231 desc="Generate a new record sequence by performing enumeration grouping on an record sequence according to another record sequence." displaystr="" majortype="101" name="enum" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Repetitive enum, that is, allocate a certain record of P to multiple groups. " optionchar="r"/>
<O2 defaultselect="false" description="The return value is composed of the sequence numbers of members that exist in P" optionchar="p"/>
<O3 defaultselect="false" description="Group P’s records according to E’s members and return the result groups. In the result set, there is a group to store the unaligned member(s)." optionchar="n"/>
</options>
<params>
<P1 desc="E (Record sequence/sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (A field name or an expression in P. y is allowed to be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F231>
<F232 desc="Assign value to the global variable." displaystr="" majortype="102" name="env" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Set the global variable v as a task variable" optionchar="j"/>
</options>
<params>
<P1 desc="v (The global variable )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Variable value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F232>
<F233 desc="Judge if a sequence can be generated by swapping the positions of the members of another sequence" displaystr="" majortype="101" name="eq" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="B    (a sequence expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F233>
<F234 desc="Obtain the last error information from a database connection." displaystr="" majortype="1" name="error" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Use the option to return information in string" optionchar="m"/>
</options>
<params/>
</F234>
<F235 desc=" Close REST Client connection." displaystr="" majortype="102" name="es_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F235>
<F236 desc="Execute the delete command and return a boolean value." displaystr="" majortype="102" name="es_delete" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or a block of data in JSON format)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F236>
<F237 desc="Export data to the local." displaystr="" majortype="102" name="es_export" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(restclient object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fileName(Name of the local file to which data is exported)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="cs(Character set, which is GBK by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="indexName(Index name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="colX(Column names represented by a sequence; export all fields by default )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F237>
<F238 desc="Execute the get command and return a table sequence or a cursor." displaystr="" majortype="102" name="es_get" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Query a cursor and by default return all records" optionchar="c"/>
<O2 defaultselect="false" description="Parameter entity can be a filefd" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F238>
<F239 desc="Execute head command and return a table sequence." displaystr="" majortype="102" name="es_head" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A REST Client object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(The address of to-be-checked document/record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F239>
<F240 desc="Connect to Elasticsearch (ES) server in the default http protocol. " displaystr="" majortype="102" name="es_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The https protocol" optionchar="s"/>
</options>
<params>
<P1 desc="host(URL of the ES server, the format is: http(s)://hostname:port, in which http(s) can be omitted; the default is http protocol)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user(Username for connectiong to an ES server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="passwd(Password for connectiong to an ES server)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F240>
<F241 desc="Execute the post command and return a table sequence or a cursor." displaystr="" majortype="102" name="es_post" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Query a cursor " optionchar="c"/>
<O2 defaultselect="false" description="Parameter entity can be a file" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F241>
<F242 desc=" Execute the put command and return a table sequence." displaystr="" majortype="102" name="es_put" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Parameter entity can be a file" optionchar="f"/>
</options>
<params>
<P1 desc="fd(A REST Client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="endpoint(Rest API address)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="entity(A parameter transmitted through http body, which is a JSON string or the name of JSON file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="header(A variable parameter that passes http header; it is a key type JSON string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F242>
<F243 desc="Dynamically parse and compute the expression" displaystr="" majortype="102" name="eval" postfix="" returntype="101">
<options/>
<params>
<P1 desc="StringExp (An expression string to be calculated)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="argExp (Parameter expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F243>
<F244 desc="Execute a SPL script file through QVS" displaystr="" majortype="102" name="exec" postfix="qvm." returntype="101">
<options>
<O1 defaultselect="false" description="Automatically close QVM when final value is returned" optionchar="x"/>
</options>
<params>
<P1 desc="splx(A SPL script file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="...(Parameter(s) of the splx file; multiple parameters are separated by comma)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="t(Time-out (unit: second); default is 120)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F244>
<F245 desc="Execute the SQL statement sql in database db. args,… is the parameter of sql, which can also be a sequence consisting of parameter values" displaystr="" majortype="1" name="execute" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="sql      (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args     (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F245>
<F246 desc="Execute the SQL statement sql in database db over sequence A. args,… is the parameter of sql. Executions of SQL statements will be committed in BATCHSQL mode, which reduces the frequency of database access. Here args shouldn’t be a a sequence type parameter." displaystr="" majortype="1" name="execute" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="A            (A sequence. the SQL statement is executed on each member of A. Generally args is computed against each member of A and the value is passed to the SQL statement for execution.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql         (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args      (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F246>
<F247 desc="Execute the SQL statement sql in database db over cursor cs. args,… is the parameter of sql. Executions of SQL statements will be committed in BATCHSQL mode, which reduces the frequency of database access. Here args shouldn’t be a a sequence type parameter." displaystr="" majortype="1" name="execute" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="" optionchar="k"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement in the form of select * from table, for example.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F247>
<F248 desc="Check if a file exists." displaystr="" majortype="2" name="exists" postfix="f." returntype="101">
<options/>
<params/>
</F248>
<F249 desc="Compute e to the nth power." displaystr="" majortype="102" name="exp" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n (The exponent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F249>
<F250 desc="Convert a sequence into a string." displaystr="" majortype="102" name="export" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="The column name will be written to the beginning of the character string as the first record." optionchar="t"/>
<O2 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
<O4 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O5 defaultselect="false" description="Perfrom escaping according to the Excel rule, which treats two double quotation marks as one and does not escape the other characters Need to work with @q" optionchar="o"/>
</options>
<params>
<P1 desc="x (Fields to be exported. If omitted, then export all fields of A.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Name of the resulting field in the string. If omitted, then use the original field name.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="s (User-defined field separator. The default is tab.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F250>
<F251 desc="Write a sequence/table sequence/record sequence into a file." displaystr="" majortype="2" name="export" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Export field description, or the headers, as the first row of the file" optionchar="t"/>
<O2 defaultselect="false" description="Append. By default, overwrite the original file. The option and @t are mutual exclusive. The appended records and the original records should be of the same structure, otherwise error will be reported" optionchar="a"/>
<O3 defaultselect="false" description="Convert into binary file to speed up the processing and ignore @t options; won’t segment A if it is small enough, otherwise it will be segmented when being converted into the binary format; A is ordered by s when the latter is present and create a new segment whenever s is changed; s should be different for the newly-added data at append " optionchar="b"/>
<O4 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O5 defaultselect="false" description="Force the execution of @b and write the sequence to the binary file f in segment by segment. The sequence won’t be segmented without this option. With this option, the parameter s, when it exists, is the grouping expression according which sequence A is ordered; perform data segmentation only when s changes. The option is used to export a large amount of data to a binary file with parallel processing in segments, which can make sure the integrity of records in each segment. " optionchar="z"/>
<O6 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
<O7 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O8 defaultselect="false" description="" optionchar="o"/>
</options>
<params>
<P1 desc="A    (The record sequence/sequence to be exported.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x     (The field to be exported. If omitted, all the fields of A that can be textualized will be exported. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F     (Resulting field name. If omitted, then use the original field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s     (The user-defined separator used in the text file, and the default separator is tab)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F251>
<F252 desc="Retrieve data from a cursor and write it to a text file." displaystr="" majortype="2" name="export" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export field description, or the headers, as the first row of the file" optionchar="t"/>
<O2 defaultselect="false" description="Append. If omitting , overwrite the original file. This option cannot co-exist with @t. f and cs must be of the same structure, otherwise error will be reported." optionchar="a"/>
<O3 defaultselect="false" description="Convert into binary file to speed up the processing. It ignores @t and does not support the parameter s." optionchar="b"/>
<O4 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O5 defaultselect="false" description="Force the execution of @b and write the sequence to the binary file f in segment by segment. The sequence won’t be segmented without this option. With this option, the parameter s is the grouping expression ruling that sequence A is ordered by s, if the parameter exists, and perform the segmentation only when s changes. The binary file is used to export a large sequenece in segments with parallel processing, which will make sure records in each segment won’t be split.  " optionchar="z"/>
<O6 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system. " optionchar="w"/>
<O7 defaultselect="false" description="Enclose the exported text field values and headers with quotation marks " optionchar="q"/>
<O8 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
</options>
<params>
<P1 desc="cs (Cursor whose data to be exported.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Fields to be exported. If omitted, then export all fields in the record sequence A that can be textualized. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F (Resulting field name. If omitted, then use the original field name.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator; the default is tab.b)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F252>
<F253 desc="Create a matrix whose major diagonal element is 1 and other elements are 0." displaystr="" majortype="102" name="eye" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n1/n2(Positive integers)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F253>
<F254 desc="Perform an aggregate operation over an attached table’s column" displaystr="" majortype="102" name="f" postfix="T." returntype="102">
<options/>
<params>
<P1 desc="T (An attached table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (An attached table’s column)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F254>
<F255 desc="Compute the factorial of the parameter." displaystr="" majortype="102" name="fact" postfix="" returntype="101">
<options/>
<params>
<P1 desc="nExp (Data for which you want to compute the factorial)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F255>
<F256 desc="Open a cursor or a cluster cursor and fetch records from it." displaystr="" majortype="101" name="fetch" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t actually fetched out the returned data from the cursor. The option enables an action functionally equivalent to copying the data; it doesn’t support x." optionchar="0"/>
<O2 defaultselect="false" description="Close the cursor after data is fetched." optionchar="x"/>
</options>
<params>
<P1 desc="n ( An positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Grouping expression, according to which cs is sorted. With x, n will be ignored.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F256>
<F257 desc="Fetch and store the existing data in a channel." displaystr="" majortype="101" name="fetch" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="f(A bin file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F257>
<F258 desc="Get records from a multicursor." displaystr="" majortype="101" name="fetch" postfix="mcs" returntype="101">
<options/>
<params/>
</F258>
<F259 desc="Get the value of a specified field in a record." displaystr="" majortype="101" name="field" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F    (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F259>
<F260 desc="Modify a value of the specified field of a record." displaystr="" majortype="101" name="field" postfix="r." returntype="102">
<options/>
<params>
<P1 desc="F (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Expression whose computing result is the value of the Fth field, or the value of the string parameter F.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F260>
<F261 desc="Get values of a specified field of a sequence." displaystr="" majortype="101" name="field" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="When the return value is a record or record sequence, loop its members iteratively to get desired values" optionchar="r"/>
</options>
<params>
<P1 desc="F  (The sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F261>
<F262 desc="Modify the value of a specified field in a sequence." displaystr="" majortype="101" name="field" postfix="A." returntype="102">
<options/>
<params>
<P1 desc="F (Sequence number of a field, or the string parameter in which a variable can be used to reference the field name.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (A sequence whose length is equal to the number of values in Fth field, or a single value, which can be considered as a sequence in which members have the same value and their number is equal to the number of values in Fth field.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F262>
<F263 desc="Open a file with the specified name. " displaystr="" majortype="101" name="file" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Search the file names on the non-absolute paths in a specified order: Class path -&gt; Search path-&gt; Main path. The search path is the one configured on the option menu of esProc, and the default main path is the current directory. With this option, the function returns the name of a read-only file. " optionchar="s"/>
<O2 defaultselect="false" description="Generate a temporary file under the directory of fn file. Without the fn file, create the temporary file through the Tempory directory, one of esProc options under the Tool menu. When the relative path is used to point to the temporary directory, it is relative to the configured main directory" optionchar="t"/>
<O3 defaultselect="false" description="Make the write action wait when sharing violation happens" optionchar="a"/>
<O4 defaultselect="false" description="Import file into the memory and generate a file object; the in-memory file is read-only" optionchar="i"/>
</options>
<params>
<P1 desc="fn (Name of the file to load. Both the absolute path and the relative path are acceptable. If using the relative path, then it is relative to the main path, which is the one configured on the option menu of esProc, and which by default is the current directory (the directory holding the script file)  If using the relative path, follow these rules: 1. The relative path is relative to the main directory if the latter exists; and the latter is the main directory configured in esProc option menu; search the path where the application is located (for instance, the application directory in IDE is [installation root directory]/esProc/bin); 2. When the main directory is absent and the current script file is already saved, take the directory containing the script file as the main directory; 3. When the main directory is absent and the current script file isn’t saved, search the path where the application is located (for instance, the application directory in IDE is [installation root directory]/esProc/bin). )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which supports jvm's built-in character set and which by default is the default value set by OS)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F263>
<F264 desc="Generate a new cluster file that has same distribution type as an existing cluster file." displaystr="" majortype="102" name="file" postfix="" returntype="2">
<options/>
<params>
<P1 desc="fn  (A cluster file; supports only the composite table file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (A cluster file; supports only the composite table file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F264>
<F265 desc="Return a file or file group preceded by the corresponding zone table number(s). " displaystr="" majortype="101" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(A composite table file.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(An integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F265>
<F266 desc="Return a remote file from a node" displaystr="" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(To-be-loaded file represented by an absolute path or a relative path that is relative to the main directory)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which is a JVM built-in one; use the system default when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h(A node)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F266>
<F267 desc="Return a remote file from a sequence of nodes" displaystr="" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(To-be-loaded file represented by an absolute path or a relative path that is relative to the main directory)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs(Character set, which is a JVM built-in one; use the system default when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs(A sequence of nodes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F267>
<F268 desc="Generate a cluster file  on one or more nodes" displaystr="" majortype="102" name="file" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable a remote generation with parameter z and parameter hs have a one-one-one correspondence; and is equivalent to to(hs.len()) when parameter z is absent" optionchar="w"/>
</options>
<params>
<P1 desc="fn(A composite table file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(Zone table number(s), which is an integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hs(A node or a sequence of nodes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F268>
<F269 desc="Generate a new cluster homo-name files group using the distribution style of an existing homo-name files group" displaystr="" majortype="102" name="file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fn(A would-be cluster homo-name files group)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(Zone table number, which is an integer or an integer sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="f(A cluster homo-name files group)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F269>
<F270 desc="Create a new string by concatenating strings together." displaystr="" majortype="102" name="fill" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Source strings for making up a new string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Number of source strings that constitute the new string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F270>
<F271 desc="Fill missing values using the specified constant value" displaystr="" majortype="101" name="fillcons" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Treat non-numeric members in the sequence as nulls" optionchar="n"/>
</options>
<params>
<P1 desc="v (A constant value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F271>
<F272 desc="Fill missing values with the specified values" displaystr="" majortype="101" name="fillfun" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="xs (A one-dimensional sequence whose members will fill the missing value positions)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tq (A one-dimensional sequence whose members are indexes of missing value positions in sequence A)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F272>
<F273 desc="Fill missing values according to the specified method" displaystr="" majortype="101" name="fillmthd" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="m (A method for filling missing values)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F273>
<F274 desc="Find a record according to its primary key value." displaystr="" majortype="101" name="find" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Enable the dichotomizing search. Here, A must be ordered by the primary key; otherwise, the result will be wrong, and the index table will be ignored." optionchar="b"/>
<O2 defaultselect="false" description="Return members of A matching the sequence of key values specified by parameter k" optionchar="k"/>
</options>
<params>
<P1 desc="k (Primary key, which will be written as a sequence if it is a multi-field primary key.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F274>
<F275 desc="Find the record(s) according to the specified primary key value(s) from a memory table." displaystr="" majortype="101" name="find" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Find multiple records according to multiple primay keys and return them as a record sequence; write multiple primary keys in the format of [[k1,k2],[...],...]" optionchar="k"/>
</options>
<params>
<P1 desc="k(The primary key; write multiple keys as a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F275>
<F276 desc="Find a record  from an entity table/multizone composite table according to the specified primary key value" displaystr="" majortype="101" name="find" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Find multiple records according to multiple primary key values and return them as a record sequence; by default the function returns the first-found record whose primary key is k ; to search for multiple records according to a composite primary key, write parameter k in the format of [[k1,k2],[...],...]" optionchar="k"/>
</options>
<params>
<P1 desc="k (The key value; write multiple key values as a sequence; time key value is allowed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Column name; retrieve all field if omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C (Column alias; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F276>
<F277 desc="F inverse cumulative distribution function." displaystr="" majortype="102" name="finv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="p(Probabilty, within the interval of (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="v1(Numerator degrees of freedom)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="v2(Denominator degrees of freedom)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F277>
<F278 desc="Calculate p-value for Fisher’s exact test" displaystr="" majortype="101" name="fisher_p" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence, which is a multi-value target)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence, which is a numeric variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F278>
<F279 desc="Perform foreign-key-style association on a table sequence/record sequence" displaystr="" majortype="101" name="fjoin" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Delete the current record when result of expression w is null or false" optionchar="i"/>
<O2 defaultselect="false" description="Enable parallel processing" optionchar="m"/>
</options>
<params>
<P1 desc="w(An expression, which, besides the regular syntax, can be used in the following syntax: 1. K=w, which means value assignment; K is a field of P, and you can use an esProc function in w; 2. (Ki=wi,…,w), which contains the combined use of Ki=wi, where w is a logical expression, and where Ki can be referenced in w; )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(Alias of expression w; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(An expression; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="F(Field name in expression x; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F279>
<F280 desc="Attach foreign-key-style association computation to a cursor and return the original cursor." displaystr="" majortype="101" name="fjoin" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Delete the current record when result of expression w is null or false" optionchar="i"/>
</options>
<params>
<P1 desc="w(An expression, which, besides the regular syntax, can be used in the following syntax: 1. K=w, which means value assignment; K is a field of cursor cs, and you can use an esProc function in w; 2. (Ki=wi,…,w), which contains the combined use of Ki=wi, where w is a logical value and where Ki can be referenced in w. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(Alias of expression w; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(An expression; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="F(Field name in expression x; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F280>
<F281 desc="Perform foreign-key-style association on a channel" displaystr="" majortype="101" name="fjoin" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Delete the current record when result of expression w is null or false" optionchar="i"/>
</options>
<params>
<P1 desc="w(An expression, which, besides the regular syntax, can be used in the following syntax: 1. K=w, which means value assignment; K is a field of channel ch, and you can use an esProc function in w; 2. (Ki=wi,…,w), which contains the combined use of Ki=wi, where w is a logical expression, and where Ki can be referenced in w. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(Alias of expression w; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(An expression; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="F(Field name in expression x; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F281>
<F282 desc="Perform foreign-key-style association on a pseudo table" displaystr="" majortype="101" name="fjoin" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Delete the current record when result of expression w is null or false" optionchar="i"/>
</options>
<params>
<P1 desc="w(An expression, which, besides the regular syntax, can be used in the following syntax: 1. K=w, which means value assignment; K is a field of pseudo table T, and you can use an esProc function in w; 2. (Ki=wi,…,w), which contains the combined use of Ki=wi, where w is a logical expression, and where Ki can be referenced in w. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ti(Alias of expression w; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(An expression; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="F(Field name in expression x; can be absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F282>
<F283 desc="Convert a string or a numeric value  to a 64-bit double-precision floating-point number" displaystr="" majortype="102" name="float" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (A numeric string or a number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F283>
<F284 desc="Truncate the data at the specified positions, and reject all the remaining part if any" displaystr="" majortype="102" name="floor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be intercepted) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (An integer to specify the position from which data is to be truncated; taken as 0 when it is omitted &gt;0: Move the decimal point to the right for nExp places &lt;0: Move the decimal point to the left for nExp places =0: Indicate the current decimal place.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F284>
<F285 desc="Get the names of fields of the table sequence according to the serial numbers of these fields." displaystr="" majortype="101" name="fname" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="i (Sequence number of field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F285>
<F286 desc="Get the field names from records according to the serial numbers of these fields." displaystr="" majortype="101" name="fname" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="i (Sequence number of field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F286>
<F287 desc="Get the serial number of a field in a table sequence." displaystr="" majortype="101" name="fno" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F (field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F287>
<F288 desc="Get the serial number of a field of a record in a table sequence." displaystr="" majortype="101" name="fno" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F (field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F288>
<F289 desc="Generate a formatted string in Java." displaystr="" majortype="101" name="format" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="... (The format parameter of the specified string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F289>
<F290 desc="Calculate the frequency of a specified member in a sequence" displaystr="" majortype="101" name="freq" postfix="" returntype="101">
<options/>
<params>
<P1 desc="o(A string/number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F290>
<F291 desc="Set the remote working directory/directories on the FTP server" displaystr="" majortype="102" name="ftp_cd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remotePath (The path name of a remote working directory; when it is omitted, the remote working directory on the FTP server is by default regarded as the root directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F291>
<F292 desc="Exit an FTP client program" displaystr="" majortype="102" name="ftp_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F292>
<F293 desc="List all directories and files under the current directory on an FTP server." displaystr="" majortype="102" name="ftp_dir" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Only list directories; parameter multiFiles is a wildcard-specified server file" optionchar="d"/>
<O2 defaultselect="false" description="List full paths of directories and files; parameter multiFiles is a wildcard-specified server file" optionchar="p"/>
<O3 defaultselect="false" description="Create new directories; parameter multiFiles is a file with fixed name" optionchar="m"/>
<O4 defaultselect="false" description="Delete empty directories; parameter multiFiles is a file with fixed name" optionchar="r"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="multiFiles(The path name of a remote working directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F293>
<F294 desc="Download a file from the FTP server." displaystr="" majortype="102" name="ftp_get" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite the local namesake file" optionchar="f"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remoteFile(A remote file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFile (A local file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F294>
<F295 desc="Download multiple files from a FTP server." displaystr="" majortype="102" name="ftp_mget" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite a namesake file" optionchar="f"/>
<O2 defaultselect="false" description="Skip a namesake file" optionchar="t"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="serverFolder (A server folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFolder (A local folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="multiServerFiles (Wildcard-specified server files; can be duplicated)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F295>
<F296 desc="Upload multiple files onto a FTP server." displaystr="" majortype="102" name="ftp_mput" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite a namesake file" optionchar="f"/>
<O2 defaultselect="false" description="Skip a namesake file" optionchar="t"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="serverFolder (A server folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFolder (A local folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="multiLocalFiles (Wildcard-specified server files; can be duplicated)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F296>
<F297 desc="Create an FTP client" displaystr="" majortype="102" name="ftp_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Start the FTP passive mode" optionchar="d"/>
</options>
<params>
<P1 desc="server (An FTP server’s IP address)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="port (An FTP server’s port number, which is by default 21 and can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="user (The username to access an FTP server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pwd (The password to access an FTP server)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F297>
<F298 desc="Upload a file to the FTP server." displaystr="" majortype="102" name="ftp_put" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Overwrite the local namesake file" optionchar="f"/>
</options>
<params>
<P1 desc="client (An FTP client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="remoteFile (A remote file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="localFile (A local file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F298>
<F299 desc="Call a subroutine" displaystr="" majortype="102" name="func" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Increase performance by not using recursive invocation; by default, the function will copy cells to enable recursive invocation" optionchar="i"/>
<O2 defaultselect="false" description="Enable macro invocation when the func function body only consists of an expression, whose variables must not be changed" optionchar="m"/>
</options>
<params>
<P1 desc="c (The master cell of a subroutine; it is usually the cell where the func is located )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (The parameter used in a subroutine; can be a numerical value, a sequence, or other types of value )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F299>
<F300 desc="Return the greatest common divisor" displaystr="" majortype="102" name="gcd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (A numeric expression that will be ignored if its value is not a number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F300>
<F301 desc="Return the greatest common divisor" displaystr="" majortype="102" name="gcd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F301>
<F302 desc="Get information about base members at a superior level in a multilayer loop function" displaystr="" majortype="102" name="get" postfix="" returntype="101">
<options/>
<params>
<P1 desc="level (The number of levels between the current level, which is recorded as 0, and the desired superior level)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name, which is sometimes represented by #, denoting the ordial number of a field; get members directly when it is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="a:b (An offset interval, where a and b are offset values for members’ ordinal numbers; default a is 1-#, and default b is ~.len() - # ; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F302>
<F303 desc="Perform equi-grouping according one or more fields or expressions." displaystr="" majortype="101" name="group" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted" optionchar="o"/>
<O2 defaultselect="false" description="Get the first record of each group to form a record sequence and return it (Please note that 1 is a number instead of a letter)" optionchar="1"/>
<O3 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. @n and @0 are mutually exclusive" optionchar="n"/>
<O4 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O5 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. This option is equivalent to A.group@o(a+=if(x,1,0)), in which a=0 and there is only one x" optionchar="i"/>
<O6 defaultselect="false" description="Discard the group over which the result of grouping expression x is null. Use it when there’s only one expression x" optionchar="0"/>
<O7 defaultselect="false" description="Perform a concatenation of sequences/records sequences after the grouping. It is equivalent to A.group(xi,…).conj()" optionchar="s"/>
<O8 defaultselect="false" description="Return a sequence of integer sequences, each of which contains the positions of members in each group in sequence A" optionchar="p"/>
<O9 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O10 defaultselect="false" description="When parameter A is a pure table sequence, return a set of pure table sequences" optionchar="v"/>
</options>
<params>
<P1 desc="xi (Grouping expression. When grouping data by multiple fields or expressions, separate grouping expressions from each other by commas)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F303>
<F304 desc="Group a sequence and then perform aggregate operations." displaystr="" majortype="101" name="group" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted." optionchar="o"/>
<O2 defaultselect="false" description="x gets assigned with group numbers which can be used to define a group. @n and @0 are mutually exclusive." optionchar="n"/>
<O3 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O4 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. There is only one x." optionchar="i"/>
<O5 defaultselect="false" description="Discard the group over which the result of grouping expression x is null" optionchar="0"/>
<O6 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O7 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
<O8 defaultselect="false" description="Summarize data cumulatively" optionchar="s"/>
</options>
<params>
<P1 desc="x (Grouping expression. If omitting x:F, aggregate the whole set without grouping; in this case ;must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name of the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate expression in which ~ is used to reference a group)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Names of summary fields in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F304>
<F305 desc="Group records in a channel by comparing each one with its neighbor(s) and return a channel." displaystr="" majortype="101" name="group" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With this option and with grouping expression x being a bool expression, start a new group if the result of x is true. Be sure there’s only one x in this case" optionchar="i"/>
</options>
<params>
<P1 desc="x  (Grouping expression. Use the comma to separate multiple grouping fields/expressions.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F305>
<F306 desc="Attach the action of grouping records by comparing only adjacent records to the cursor and return the original cursor. " displaystr="" majortype="101" name="group" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="x is a bool expression. Begin a new group when a record makes it return true. In this case there should be only one x." optionchar="i"/>
<O2 defaultselect="false" description="Get the first record of every group to form a record sequence and return it to the original cursor; here it is number 1 instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="When parameter cs is a cursor based on pure table sequence, copy each grouped subset as a new pure table sequence" optionchar="v"/>
</options>
<params>
<P1 desc="x (Grouping expression. Multiple fields/expressions for grouping will be separated from each other with the comma.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F306>
<F307 desc="Group a cluster cursor by comparing each record with its next neighbor. " displaystr="" majortype="101" name="group" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x(Grouping expression; use comma to separate multiple grouping fields or expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F307>
<F308 desc="Attach the action of grouping and aggregating records by comparing only adjacent records to a cursor and return the original cursor." displaystr="" majortype="101" name="group" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Cumulative aggregation" optionchar="s"/>
<O2 defaultselect="false" description="@q(x:F,…;x’:F’,…; y:G,…),Used when parameter cs is ordered by x,… and only fields after it need to be sorted; support in-memory sorting" optionchar="q"/>
<O3 defaultselect="false" description="@sq(x:F,…;x’:F’,…; y:G,…),Only sort without grouping when parameters y:G are absent, and perform cumulative aggregation when the parameters are present; @s works only when @q option is present" optionchar="sq"/>
<O4 defaultselect="false" description="Return a table sequence consisting of results of expression y to the original cursor; grouping expression x is a field of cs and y is function on cs; the result of computing y must be one record of cs; and y only supports maxp, minp and top@1 functions when it is an aggregate expression; When @sev options work together, the function returns a pure table sequence " optionchar="e"/>
</options>
<params>
<P1 desc="x  (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y  (Aggregate expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (Aggregation field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F308>
<F309 desc="Group records of a pseudo table by comparing the grouping field in each with its next neighbor." displaystr="" majortype="101" name="group" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="x is a boolean expression. Begin a new group when a record makes it return true. In this case there should be only one x" optionchar="i"/>
<O2 defaultselect="false" description="Get the first record of every group to form a record sequence and return it; here it is number 1, instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="Return result as a table sequence on which an index can be directly created; by default, the function sorts the result" optionchar="t"/>
<O4 defaultselect="false" description="Store the composite table in the column-wise format when loading it the first time, which helps to increase performance" optionchar="v"/>
</options>
<params>
<P1 desc="xi (Grouping expression; use comma to separate multiple grouping fields or expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F309>
<F310 desc="Group a pseudo table by comparing each record with its next neighbor, perform aggregation over each group, and return a new pseudo table" displaystr="" majortype="101" name="group" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Cumulative aggregation" optionchar="s"/>
<O2 defaultselect="false" description="Used when parameter T is ordered by x,… and only fields after it need to be sorted; support in-memory sorting" optionchar="q"/>
<O3 defaultselect="false" description="Only sort without grouping when parameters y:G are absent, and perform cumulative aggregation when the parameters are present; @s works only when @q option is present" optionchar="sq"/>
<O4 defaultselect="false" description="Return a pseudo table consisting of results of expression y; grouping expression x is a field of T and y is function on T; the result of computing y must be one record of T; and y only supports maxp, minp and top@1 functions when it is an aggregate expressio" optionchar="e"/>
</options>
<params>
<P1 desc="x(Grouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(Field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y(Aggregate expression)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G(Aggregation field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F310>
<F311 desc="Generate a sequence for use in a data-input sheet." displaystr="" majortype="101" name="groupi" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Assume that the sequence is ordered, perform a merge by comparing each record with its next neighbor and won’t sort the result set" optionchar="o"/>
</options>
<params>
<P1 desc="Di (A data-input sheet’s dimension)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F311>
<F312 desc="Group records in a cursor and push them respectively into a sequence of channels." displaystr="" majortype="101" name="groupn" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (A sequence of channels)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F312>
<F313 desc="Group records in channel ch and push them respectively into a sequence of channels." displaystr="" majortype="101" name="groupn" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x (Gouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C (A sequence of channels)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F313>
<F314 desc="Attach the grouping record action to a cursor and return the original cursor while writing the grouped subsets to a sequence of bin files" displaystr="" majortype="101" name="groupn" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (A sequence of bin file objects)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F314>
<F315 desc="Group records of a pseudo table and write the grouped subsets to a sequence of bin files." displaystr="" majortype="101" name="groupn" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="x(Grouping expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(A sequence of bin file objects)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F315>
<F316 desc="Group a table sequence and then get the aggregate result cumulatively" displaystr="" majortype="101" name="groups" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Group records by comparing adjacent ones, which is equal to the merging operation, and the result set won’t be sorted." optionchar="o"/>
<O2 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. @n and @o are mutually exclusive." optionchar="n"/>
<O3 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o/@n" optionchar="u"/>
<O4 defaultselect="false" description="x is a bool expression. If the result of x is true, then start a new group. There is only one x." optionchar="i"/>
<O5 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; can’t be used with @oi options. " optionchar="m"/>
<O6 defaultselect="false" description="Discard groups on which expression x gets empty result" optionchar="0"/>
<O7 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O8 defaultselect="false" description="When empty data is obtained from the cursor, the function returns an empty table sequence having only the data structure" optionchar="t"/>
<O9 defaultselect="false" description="@z(…;…;n)  Split the sequence according to groups during parallel computation, and the multiple threads share a same result set; in this case HASH space will not be dynamically adjusted; parameter n is HASH space size, whose value can be default" optionchar="z"/>
<O10 defaultselect="false" description="Return a table sequence consisting of results of computing function y; expression x is a field of cursor cs and y is a function on cs; the result of y must be one record of cs and y only supports maxp, minp and top@1 when it is an aggregate function" optionchar="e"/>
</options>
<params>
<P1 desc="x (Group expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name of the result table sequence.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (y is the function with which A is traversed. When y is an aggregate function, it only supports sum/count/max/min/top/avg/iterate/icount/median/maxp/minp/concat/var. When the function work with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted. When y isn’t an aggregate function, perform calculation over only the first record in each group )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Summary field name in the result table sequence.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F316>
<F317 desc="Group records in a channel." displaystr="ch.groups(x:F,…;y:G…;n)" majortype="101" name="groups" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With the option the value of expression x is a group number, which points to the desired group" optionchar="n"/>
<O2 defaultselect="false" description="Won’t sort the resulting set by expression x; the option and @n are mutually exclusive" optionchar="u"/>
</options>
<params>
<P1 desc="x  (Grouping expression, by which an aggregation over the whole grouped set is performed if x:F is omitted. In that case the semicolon should not be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field names of the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (An aggregate function on channel ch, which only supports sum/count/max/min/top/avg/iterate/concat/var; the parameter Gi should be given up if function iterate(x,a;Gi,…) is used)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (The aggregate fields in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n  (The maximum number of groups that can be divided. Stop execution if the number is exceeded. The parameter is defined for a situation where the number of groups to be divided is large yet indefinite. It doesn’t work with @n option.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F317>
<F318 desc="Group records in a cluster cursor, sort them by the grouping field and peform aggregation over each group and add each aggregate to the result set." displaystr="" majortype="102" name="groups" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="Perform the group operation over data in every node and compose the result sets into a cluster memory table in the segmentation way of the cursor; suppport a cluster dimension table" optionchar="c"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon (;) must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (An aggregate function on cs, which only supports sum/count/max/min/top /avg/iterate/concat/var; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F318>
<F319 desc="Group records in a cursor." displaystr="" majortype="101" name="groups" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="The value of grouping expression is group number used to locate the group; you can use n to specify the number of groups and generate corresponding number of zones first." optionchar="n"/>
<O2 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @n" optionchar="u"/>
<O3 defaultselect="false" description="Compare each record only with its neighboring record to group, which is equivalent to the merge operation, and won’t sort the result set" optionchar="o"/>
<O4 defaultselect="false" description="With this option, the function only has one parameter x that is a bool expression; start a new group if its result is true" optionchar="i"/>
<O5 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O6 defaultselect="false" description="Discard groups on which expression x gets empty result" optionchar="0"/>
<O7 defaultselect="false" description="When empty data is obtained from the cursor, the function returns an empty table sequence having only the data structure" optionchar="t"/>
<O8 defaultselect="false" description="@z(…;…;n) Split the sequence according to groups during parallel computation, and the multiple threads share a same result set; in this case HASH space will not be dynamically adjusted; parameter n is HASH space size, whose value can be default" optionchar="z"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon (;) must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (An aggregate function on cs, which only supports sum/count/max/min/top/avg/iterate/concat/var; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n; it doesn’t work with @n option. Support a multicuror when this parameter is absent.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F319>
<F320 desc="Group records in a pseudo table" displaystr="" majortype="101" name="groups" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="The value of grouping expression is group number used to locate the group; you can use n to specify the number of groups and generate corresponding number of zones first" optionchar="n"/>
<O2 defaultselect="false" description="Do not sort the result set by the grouping expression; it doesn’t work with @n" optionchar="u"/>
<O3 defaultselect="false" description="Compare each record only with its neighboring record to group, which is equivalent to the merge operation, and won’t sort the result set" optionchar="o"/>
<O4 defaultselect="false" description="With this option, the function only has one parameter x that is a boolean expression; start a new group if its result is true" optionchar="i"/>
<O5 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O6 defaultselect="false" description="Enable returning a resut set containing aggregates only without group-level data" optionchar="b"/>
<O7 defaultselect="false" description="Store the composite table in the column-wise format when loading it the first time, which helps to increase performance" optionchar="v"/>
</options>
<params>
<P1 desc="x (Grouping expression; if omitting parameters x:F, aggregate the whole set; in this case, the semicolon “;” must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (An aggregate function on T, which only supports sum/count/max/min/top/avg/iterate/concat/var; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (The specified maximum number of groups; stop executing the function when the number of data groups is bigger than n to prevent memory overflow; the parameter is used in scenarios when it is predicted that data will be divided into a large number of groups that are greater than n)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F320>
<F321 desc="Group records, in a channel and return a channel." displaystr="" majortype="101" name="groupx" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="With the option the value of expression x is a group number, which points to the desired group" optionchar="n"/>
</options>
<params>
<P1 desc="x  (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F  (Field name in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y  (An aggregate function which only supports sum/count/max/min/top /avg/iterate; the parameter Gi should be given up if function iterate(x,a;Gi,…) is used)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G  (The aggregate fields in the resulting table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F321>
<F322 desc="Group the ordered records in a cursor and return result as a cursor. " displaystr="" majortype="101" name="groupx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="x gets assigned with group numbers which can be used to define the groups. " optionchar="n"/>
<O2 defaultselect="false" description="Won’t sort the result set by parameter x; mutually exclusive with @n." optionchar="u"/>
<O3 defaultselect="false" description="Treat parameter n as the segmentation expression by which records are first segmented and then grouped and sorted" optionchar="g"/>
</options>
<params>
<P1 desc="x(Grouping expression.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(Result field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y(Aggregate function which only supports sum/count/max/min/top/ avg/iterate. When the function works with the iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G(Aggregate field name )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value is n times of the default, which is automatically calculated, if n&lt;1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F322>
<F323 desc="Group records in a cluster cursor and return a synchronously segmented cursor." displaystr="" majortype="102" name="groupx" postfix="cs." returntype="102">
<options/>
<params>
<P1 desc="x (Grouping expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F (Resulting field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Aggregate function that only supports sum/count/max/min/top/avg/iterate; when the function works with iterate(x,a;Gi,…) function, the latter’s parameter Gi should be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="G (Aggregate field name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="n (Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value is n times of the default, which is automatically calculated, if n&lt;1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F323>
<F324 desc="Return a hash value" displaystr="" majortype="101" name="hash" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (Data of any type)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (An integer greater than 1)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F324>
<F325 desc="Close a HBase connection." displaystr="" majortype="102" name="hbase_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F325>
<F326 desc="Compare data with the HBase-supplied comparator." displaystr="" majortype="102" name="hbase_cmp" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Match the current value with the prefix" optionchar="p"/>
<O2 defaultselect="false" description="Check if the current value is null but won’t perform matching" optionchar="n"/>
<O3 defaultselect="false" description="Use a regular expression to match table data" optionchar="r"/>
<O4 defaultselect="false" description="Use the threshold and table data, both of which are string type, to match up a string" optionchar="s"/>
<O5 defaultselect="false" description="Convet a string type or a date/time/datatime type parameter to a Long type one" optionchar="l"/>
<O6 defaultselect="false" description="Perform bit-level comparison using AND, OR and XOR operations" optionchar="b"/>
</options>
<params>
<P1 desc="str (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r (Only use this parameter with @r option; its value can only be one of the following letters: i=case insensitive  (Case-insensitive)  m=multiline,     (^ and $ can match up a line break within a string) d=dotall,        (The dot symbol can match up a line break) u=unicode case,  (Case-insensitive in matching up Unicode characters ) q=canon_eq     (Consider same characters in different character encodings as equal)  x=unix_lines,    (Consider \n as a line break only) l=literal,        (Text mode) c=comments    (Comment mode) The value must be in quotation marks. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (Only use this parameter with @b option; its value can only be one of the following: AND, OR, XOR; the value must be in quotation marks. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F326>
<F327 desc="Filter data with the HBase-supplied filter." displaystr="" majortype="102" name="hbase_filter" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filterName (HBase filter name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filterArg (Filter parameter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F327>
<F328 desc="Filter data with multiple filters." displaystr="" majortype="102" name="hbase_filterlist" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Every filter is independent in filtering data." optionchar="o"/>
</options>
<params>
<P1 desc="filterHandle (Filter handle)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F328>
<F329 desc="Query data in HBase database and return a single row." displaystr="" majortype="102" name="hbase_get" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (Database connection information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="rowName (Row name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="family (Column family name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="column (Colum name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="type (Data type; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
<P7 desc="alias (Another name of a column; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P7>
<P8 desc="filter:f (‘filter:’ is a fixed format, and parameter f means filter handle; can be omitted )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P8>
<P9 desc="timeRange:[t1,t2] (‘timeRange:’ is a fixed format, and parameters t1 and t2 specify a range of timestamp; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P9>
</params>
</F329>
<F330 desc="Create a HBase connection." displaystr="" majortype="102" name="hbase_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS connection information )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="zkUrl (Zookeeper connection information)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F330>
<F331 desc="Query a HBase database and return result as a cursor or a table sequence." displaystr="" majortype="102" name="hbase_scan" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a cursor" optionchar="c"/>
</options>
<params>
<P1 desc="client (Database connection information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="family (Column family name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="column (Column name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="Type (Data type; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="alias (Another name of a column; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
<P7 desc="rowPrefix:x (‘rowPrefix:’ is a fixed format; parameter x is the prefix of rowKey )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
<P8 desc="filter:f (Filter handle)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P8>
<P9 desc="startRow:startrow (‘startRow:’ is a fixed format; parameter startrow represents the starting row, which will be included in data retrieval )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P9>
<P10 desc="stopRow:stoprow (‘stopRow:’ is a fixed format; parameter stoprow represents the ending row, which will be excluded in data retrieval )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P10>
<P11 desc="timeRange:[t1,t2] (‘timeRange:[,]’ is a fixed format; parameter t1 is the starting timestamp whose value will be retrieved, and parameter t2 is the ending timestamp whose value won’t be retrieved)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P11>
</params>
</F331>
<F332 desc="Close the HDFS connection." displaystr="" majortype="102" name="hdfs_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="HdfsClient (An HDFS connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F332>
<F333 desc="Get the list of all files in a specified path." displaystr="" majortype="102" name="hdfs_dir" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="List names of all directories in the specified path" optionchar="d"/>
<O2 defaultselect="false" description="List the full paths of all directories and files in the specified path" optionchar="p"/>
<O3 defaultselect="false" description="Create a directory; return true if the directory is created, otherwise return false" optionchar="m"/>
<O4 defaultselect="false" description="Delete a directory; return true if the operation is successful, otherwise return false" optionchar="r"/>
</options>
<params>
<P1 desc="hd (An hd connecton)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="path (A relative path within the path containing the HDFS file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F333>
<F334 desc="Download a local file to a specific position" displaystr="" majortype="102" name="hdfs_download" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Download all files in the specified folder to the local machine, and require both the source and directories are folders" optionchar="d"/>
</options>
<params>
<P1 desc="hd(An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="local(A local file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="remote(A remote file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F334>
<F335 desc="Check whether there is a specified file or folder in HDFS and return a boolean value" displaystr="" majortype="102" name="hdfs_exists" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hd (An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file/path(Hadoop file name/Hadoop path name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F335>
<F336 desc="Open a specified directory and return an HDFS file flow." displaystr="" majortype="102" name="hdfs_file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hd (An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file (The name of the to-be-loaded Hadoop file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="cs (The charset embedded in JVM; by default it is the default value for a virtual machine)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F336>
<F337 desc="Connect to the HDFS file system and return a connection object." displaystr="" majortype="102" name="hdfs_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url(The URL format is scheme://authority/path. Scheme is the HDFS protocol name; authority is the host name; and path is a string of the file (or directory) path) " filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="user(A Hadoop user; default is root)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F337>
<F338 desc="Upload a local file to a specific position" displaystr="" majortype="102" name="hdfs_upload" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Upload all files in the specified folder to the specified path, and require both the source and directories are folders" optionchar="d"/>
</options>
<params>
<P1 desc="hd(An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="local(A local file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="remote(A remote file or folder)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F338>
<F339 desc="Upload data to the specified location in HDFS" displaystr="" majortype="101" name="hdfs_write" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Appen-write; the to-be-appended content should have same structure as the original file content, otherwise error will be reported; ignore @t option when the target file already has content; overwrite the original file by default" optionchar="a"/>
<O2 defaultselect="false" description="Write the field name information (titles) to the target file as the first row" optionchar="t"/>
</options>
<params>
<P1 desc="hd(An hd connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file(The location and name of the file to be loaded to HDFS; can be .txt file or .csv file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="A/cs(A table sequence/record sequence/cursor; do not support a random access file, such as .btx)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="x(The field(s) to be uploaded; upload all fields when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F(The result field name(s) in the form of string; use original field names when the parameter is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F339>
<F340 desc="Close a Hive database connection." displaystr="" majortype="102" name="hive_close" postfix="" returntype="102">
<options/>
<params/>
</F340>
<F341 desc="Query a Hive database and return the result as a cursor." displaystr="" majortype="102" name="hive_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F341>
<F342 desc="Execute Hive’s SQL-like queries. " displaystr="" majortype="102" name="hive_execute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, which supports Hive’s SQL-like queries such as create table, drop table, load data, insert into, insert owerwrite, and create view)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F342>
<F343 desc="Create a Hive database connection." displaystr="" majortype="102" name="hive_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS file connection information )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="thriftUrl (Thrift file connection information)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="hdfsUserName  (HDFS file user name )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F343>
<F344 desc="uery a Hive database and return the result as a sequence." displaystr="" majortype="102" name="hive_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F344>
<F345 desc="Return the hyperlink string of a canvas" displaystr="" majortype="102" name="hlink" postfix="G." returntype="101">
<options/>
<params/>
</F345>
<F346 desc="Set or get the number of memory zone holding a specified task on the current node." displaystr="" majortype="102" name="hosts" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i(An integer that represents memory zone number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="j(Task name; can be absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F346>
<F347 desc="Return a sequence of available nodes." displaystr="" majortype="102" name="hosts" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n(The number of nodes)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="hs(A node sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="j(Task name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F347>
<F348 desc="Get the hour from a specified time" displaystr="" majortype="102" name="hour" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp   (Date or standard datetime format string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F348>
<F349 desc="Get text data under a specified tag in an html file" displaystr="" majortype="101" name="htmlparse" postfix="s." returntype="101">
<options/>
<params>
<P1 desc="tag(A tag in an html file; if the tag’s value is “table”, get all data under it)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="i(An integer)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="j(An integer)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F349>
<F350 desc="Package the returned result of URL as the file flow and return it." displaystr="" majortype="102" name="httpfile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (HTTP service in the URL string format.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Character set, which supports JVM's built-in character set, and which by default is the default value of virtual machine.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="param (A parameter submitted using the method specified in parameter method with a syntax like p1=v1&amp;p2=v2…. can be omitted. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="cs (Character set, which supports JVM's built-in character set, and which by default is the default value of virtual machine.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="method(The method used to pass parameter param’s value; its value is GET or POST (default is POST))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="header(The header property can have multiple items, like headerName1:value1,headerName2:value2,... (the format is &quot;property&quot;:&quot;value&quot;,…); or can be omitted. The execution of .property() function over a returned file object will return the header property.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F350>
<F351 desc="Upload parameters and files to an URL using the HTTP protocol." displaystr="" majortype="101" name="httpupload" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (HTTP service’s URL string format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F351>
<F352 desc="Convert a specified table sequence to apure table sequence." displaystr="" majortype="101" name="i" postfix="P." returntype="101">
<options/>
<params/>
</F352>
<F353 desc="Count the number of distinct members in a sequence" displaystr="" majortype="101" name="icount" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Remove duplicates by comparing neighboring members" optionchar="o"/>
<O2 defaultselect="false" description="Judge whether a member is distinct or not according to position when parameter A is a number sequence" optionchar="n"/>
<O3 defaultselect="false" description="Judge whether a member is distinct or not according to the long type bit when parameter A is a number sequence" optionchar="b"/>
</options>
<params/>
</F353>
<F354 desc="Use index to query data in an entity table." displaystr="icursor(C,…;w;f,…)" majortype="101" name="icursor" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Make sure the result set is ordered by the indexed field and large result sets are supported " optionchar="s"/>
<O2 defaultselect="false" description="Handle multiple conditions joined up with &amp;&amp; from left to right while the default is handling them in an optimal order" optionchar="u"/>
</options>
<params>
<P1 desc="C (To-be-retrieved columns in the cluster table; get all columns when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition, which cannot be omitted and in which the filtering field for T must be same as the indexed field; support &gt;, &gt;=, &lt;, &lt;=, == and contain in its syntax)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="f(Index file object; the program will automatically use the suitable one when there are multiple index files)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F354>
<F355 desc="Get distinct values from a sequence." displaystr="" majortype="101" name="id" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Without sorting, remove the repetitive neighboring members only" optionchar="o"/>
<O2 defaultselect="false" description="Do not sort the result set by x. It doesn’t work with @o" optionchar="u"/>
<O3 defaultselect="false" description="Used over a grouped table with each group ordered to speed up grouping" optionchar="h"/>
<O4 defaultselect="false" description="Discard members on which expression x is computed and gets empty result" optionchar="0"/>
<O5 defaultselect="false" description="Enable parallel processing to increase performance of complex computations on a large volume of data, with indefinite computing order; the parameter and @o option are mutually exclusive" optionchar="m"/>
<O6 defaultselect="false" description="Judge whether a member is distinct or not according to position when there is only one xi and xi is a natural number" optionchar="n"/>
<O7 defaultselect="false" description="Judge whether a member is distinct or not according to the bit length in a byte in order to reduce storage usage when there is only one xi and xi is a natural number" optionchar="b"/>
</options>
<params>
<P1 desc="xi (An expression; use ~ to represent x if the latter is omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of to-be-retrieved distinct values counting from the beginning; return all values if it is absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F355>
<F356 desc="Return a channel consisting of values of one or more fields." displaystr="" majortype="101" name="id" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (Expression; use comma to separate multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n  (Integer; can’t be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F356>
<F357 desc="Return a sequence consisting of values of fields in a given cursor." displaystr="" majortype="101" name="id" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Do not sort data while removing neighboring duplicate members; require that data is ordered by expression x" optionchar="o"/>
<O2 defaultselect="false" description="Do not sort result set by expression x; the option and @o are mutually exclusive" optionchar="u"/>
<O3 defaultselect="false" description="Used to segment ordered data, which increases efficiency" optionchar="h"/>
<O4 defaultselect="false" description="Discard members on which expression x is computed and gets empty result" optionchar="0"/>
<O5 defaultselect="false" description="Judge whether a member is distinct or not according to position when there is only one xi and xi is a natural number" optionchar="n"/>
<O6 defaultselect="false" description="Judge whether a member is distinct or not according to the bit length in a byte in order to reduce storage usage when there is only one xi and xi is a natural number" optionchar="b"/>
</options>
<params>
<P1 desc="xi  (Expression; use comma to separate multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n  (Integer; return all values when omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F357>
<F358 desc="If a is true, then return true. Otherwise, return false" displaystr="" majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="a (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F358>
<F359 desc="If a is non-null and non-false, then return b; otherwise return c, which is null by default." displaystr="" majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="a (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b  (Value expression. If the result of a is true, then return the result of b)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c (Value expresssion. If the result of a is false, then return the result of c)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F359>
<F360 desc="Calculate the boolean expression from left to right.if bool is true, then return the result of trueValue, and the computation will be terminated; If bool is false, then calculate the next bool. If none of the Boolean expression boolis true, and there is a default expression default, then return the result of default, otherwise return null." displaystr="" majortype="102" name="if" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xk (Boolean expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yk (Value expression. If the result of xk is true, then return its result.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="y (Default value expression. If all the results of boolean expressions are false, then return the result of this expression.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F360>
<F361 desc="To judge if an object is a sequence" displaystr="" majortype="102" name="ifa" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x    (the object to be judged)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F361>
<F362 desc="Find whether the type of parameter is date or datetime" displaystr="" majortype="102" name="ifdate" postfix="" returntype="101">
<options/>
<params>
<P1 desc="exp (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F362>
<F363 desc="Search for a specified key value in an in-memory table according to the index." displaystr="" majortype="101" name="ifind" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return a sequence of ordinal numbers of matching records" optionchar="p"/>
<O2 defaultselect="false" description="Return the first matching record" optionchar="1"/>
</options>
<params>
<P1 desc="I(Index name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k(Key value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F363>
<F364 desc="Get the first non-null member of a sequence.Equivalent to ifn(x1,…,xn)" displaystr="" majortype="101" name="ifn" postfix="A." returntype="101">
<options/>
<params/>
</F364>
<F365 desc="Compute x with each member of the sequence and return the first non-null member of the new sequence.Equivalent to A.(x).ifn()" displaystr="" majortype="101" name="ifn" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally ann expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F365>
<F366 desc="Find whether the parameter is of numeric data type." displaystr="" majortype="102" name="ifnumber" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Exp (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F366>
<F367 desc="Judge whether a data object is a pure sequence or a pure table sequence" displaystr="" majortype="102" name="ifpure" postfix="" returntype="102">
<options/>
<params>
<P1 desc="x(Any data object, including constant, expression, record, sequence, table sequence and record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F367>
<F368 desc="Find whether an object is a record." displaystr="" majortype="102" name="ifr" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (Any data object, for example a constant, an expression, a record, a record sequence, a sequence or a table sequence.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F368>
<F369 desc="Find whether the parameter is of string data type" displaystr="" majortype="102" name="ifstring" postfix="" returntype="101">
<options/>
<params>
<P1 desc="Exp    (Expression of any data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F369>
<F370 desc="Judge if an object is a table sequence" displaystr="" majortype="102" name="ift" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x   (any object, for example: a constant, an expression, a record, a record sequence, a sequence or a  table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F370>
<F371 desc="Find whether the parameter is of time data type." displaystr="" majortype="102" name="iftime" postfix="" returntype="101">
<options/>
<params>
<P1 desc="exp   (Data expression of any type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F371>
<F372 desc="Judge if a variable exists" displaystr="" majortype="102" name="ifv" postfix="" returntype="101">
<options/>
<params>
<P1 desc="v (Parameter name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F372>
<F373 desc="Close Informix database connection" displaystr="" majortype="101" name="ifx_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F373>
<F374 desc="Create Informix database connection" displaystr="" majortype="101" name="ifx_conn" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (The URL to connect to Informix server)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fragfile (Fragmentation information file that records the fields and every field’s max and min values in each fragmented file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F374>
<F375 desc="Create Informix database connection" displaystr="" majortype="101" name="ifx_conn" postfix="" returntype="101">
<options/>
<params>
<P1 desc="driver (Name of JDBC driver for connecting to Informix database; the format is com.informix.jdbc.IfxDriver)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F375>
<F376 desc="Query data in fragmented files from k1 to k2 using a SQL statement" displaystr="" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k1 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="k2 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F376>
<F377 desc="List the fragmentation information of table table with cursors and search fragmented file k1 and fragmented file k2 according to the where condition. Parameter f is the table’s column name and parameter alias is the column’s another name. Parameter where can be omitted; parameter k2 will be omitted if parameter k1 is absent; search only framted file k1 when k2 is absent" displaystr="" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="where (Query condition; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="f (A column name of a fragmented file)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="alias (Another name of column f)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="k1 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="k2 (A fragmented file; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F377>
<F378 desc="Query data over the fragmented file specified by the parameter ifxCursor quries with a SQL statement; parameter f2 is the fragmented field, which, if absent, is the fragmented field of the fragmented file ifxCursor" displaystr="" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="ifxCursor (The fragmented file recorded with cursor)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="f2 (A fragmented field; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F378>
<F379 desc="Query table table according to where condition over the fragmented file specified by parameter ifxCursor; parameter f is the table’s column name and parameter alias is its another name; f2 is the fragmented field, which, if absent, is the fragmented field of the fragmented file ifxCursor" displaystr="" majortype="101" name="ifx_cursor" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Allow unordered data" optionchar="o"/>
<O2 defaultselect="false" description="Require data to be ordered" optionchar="f"/>
<O3 defaultselect="false" description="Enable the use of multiple channels" optionchar="m"/>
</options>
<params>
<P1 desc="ifxconn (Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="where (Query condition; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="f (A column name of a fragmented file)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="alias (Another name of column f)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="ifxCursor (The fragmented file recorded with cursor)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="f2 (A fragmented field; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P7>
</params>
</F379>
<F380 desc="List the fragmentation information of a specified table with table sequences" displaystr="" majortype="101" name="ifx_listfrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (The ifxconn object which holds the fragmentation information)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F380>
<F381 desc="Save the fragmentation information file stored in the memory as a new file" displaystr="" majortype="101" name="ifx_savefrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="file (A fragmentation information file, which can be the same file as fragfile or not.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F381>
<F382 desc="Set the fragmentation file of a specified table" displaystr="" majortype="101" name="ifx_setfrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An ifxconn object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (A table being fragmented)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="fieldName (Fragmented field)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="min (The minimum value in a fragmented file; can be omitted and can have multiple values)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F382>
<F383 desc="Extract fragmentation information from the database" displaystr="" majortype="101" name="ifx_takefrag" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ifxconn (An Ifxconn object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="table (The table being fragmented; can be omitted and can have multiple number of it)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F383>
<F384 desc="Fi is the retrieved fields. By default, all fields will be retrieved.s is the optional separator. By default, the separator is tab. The format of character string: Separate the records with space, and the fields with optional separators. The default separator is tab." displaystr="" majortype="101" name="import" postfix="S." returntype="101">
<options>
<O1 defaultselect="false" description="In f, take the record in the first row as the field name. If not using this option, then use _1, and _2,… as the field name." optionchar="t"/>
<O2 defaultselect="false" description="Use comma as the separator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option." optionchar="c"/>
<O3 defaultselect="false" description="Won’t split strings and data will be imported as a table sequence consisting of strings of single field values; ignor the parameters" optionchar="s"/>
<O4 defaultselect="false" description="Return the result set as a sequence if it only contains one field" optionchar="i"/>
<O5 defaultselect="false" description="Remove the quotation marks, if any, from both ends of each data item, including those in the field names and handle the escape sequences; quotation marks not located at the ends are left alone" optionchar="q"/>
<O6 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
<O7 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Generate null if parameter Fi isn’t included in the imported strings; by default there will be an error report " optionchar="e"/>
<O9 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O10 defaultselect="false" description="Ignore a row whose number of columns don’t match the first row" optionchar="n"/>
<O11 defaultselect="false" description="In corporation with @d or @n, if a mismatch appears, throw an exception, terminate the execution and output the content of the problem record; error will be reported if parentheses or quotation marks does not match when @p option or @q option is present " optionchar="v"/>
<O12 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are identified as quotes" optionchar="a"/>
<O13 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O14 defaultselect="false" description="Split the file content into a string by the separator without parsing" optionchar="f"/>
<O15 defaultselect="false" description="Allow line continuation and put an escape character \ at the end the line" optionchar="l"/>
<O16 defaultselect="false" description="Read contents as a string before parsing so that errors about some character sets can be avoided; the option slows the computation" optionchar="r"/>
</options>
<params>
<P1 desc="Fi (Fields retrieved. By default, all fields will be retrieved)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type(Field types include bool, int, long, float, decimal, number, string, date, time and datetime; data type of the first row will be used by default; it is a serial byte key when the value is an integer; only 16 bytes are allowed in a serial byte value )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="fmt (Date\time format)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator; the default is tab.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F384>
<F385 desc="Read contents from a file and return them as a table sequence. " displaystr="" majortype="2" name="import" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field name. If this option is not used, _1, _2,… will be used as field names." optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameter Fi, k and n, and with no support available for parameters type and s. Options @t, @s, @i, @q  will be ignored. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records or it is unable to be segmented. " optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Do not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O5 defaultselect="false" description="If the result set has only one column, return it as a sequence" optionchar="i"/>
<O6 defaultselect="false" description="Remove the quotation marks, if any, of the field strings, including the field names, in the first place, and handle the escape sequences. " optionchar="q"/>
<O7 defaultselect="false" description="Use multithreads to increase data retrieval speed, but this will leave an indefinite order for members of the result set. This option will be ignored when parameters k and n exist and it is often used to retrieve data from big files. More than one parallel thread should be specified in license file and configuration information. " optionchar="m"/>
<O8 defaultselect="false" description="Use comma as the seperator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O10 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O11 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O12 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O13 defaultselect="false" description="Verify data type matching, and, if error reports, throw an exception, terminate the execution and output the content of the problem record" optionchar="v"/>
<O14 defaultselect="false" description="Read contents as a string before parsing so that errors about some character sets can be avoided; the option slows the computation" optionchar="r"/>
</options>
<params/>
</F385>
<F386 desc="Read contents from a file and return them as a table sequence. " displaystr="" majortype="2" name="import" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field name. If this option is not used, _1, _2,… will be used as field names." optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from the exported binary file, with the support for parameter Fi, k and n, and with no support available for parameters type and s. Options @t, @s, @i, @q and @m will be ignored. The segmental retrieval could result in empty segment in cases when a file has only a very small number of records or it is unable to be segmented." optionchar="b"/>
<O3 defaultselect="false" description="Make the function return null when Fi doesn’t exist in the file; raise an error when the option is absent." optionchar="e"/>
<O4 defaultselect="false" description="Do not split the to-be-retrieved field when it is imported as a cursor whose content is a TSeq consisting of strings of a single field; in this case the parameters will be ignored." optionchar="s"/>
<O5 defaultselect="false" description="If the result set has only one column, return it as a sequence" optionchar="i"/>
<O6 defaultselect="false" description="Remove the quotation marks, if any, of the field stringsfrom both ends of each data item, including those in the field names, in the first place, and handle the escape sequences; quotation marks not located in the ends are left alone " optionchar="q"/>
<O7 defaultselect="false" description="Use multithreads to increase data retrieval speed, but this will leave an indefinite order for members of the result set. This option will be ignored when parameters k and n exist and it is often used to retrieve data from big files. More than one parallel thread should be specified in configuration information. errors may appear when @o option or parameters k:n are present " optionchar="m"/>
<O8 defaultselect="false" description="Use comma as the seperator when the parameter s is absent, but the user-defined separator s should take priority when there are both s and @c option. " optionchar="c"/>
<O9 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="o"/>
<O10 defaultselect="false" description="Retain the whitespaces on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O11 defaultselect="false" description="Delete a record if it contains unmatching data types or data formats and start examining data by type" optionchar="d"/>
<O12 defaultselect="false" description="Ignore and discard rows whose number of columns don’t match the first row" optionchar="n"/>
<O13 defaultselect="false" description="Perfrom escaping according to the Excel rule, which identifies two double quotation marks as one and does not escape the other characters" optionchar="v"/>
<O14 defaultselect="false" description="Enable not to identify single quotes as the quotes; by defaut both single and double quotes are identified as quotes" optionchar="a"/>
<O15 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="p"/>
<O16 defaultselect="false" description="Enable handling the matching of parentheses (not including the separators within the parentheses) and quotes, as well as the the escape sequences outside of the quotes; the option covers functionalities defined by @q option" optionchar="f"/>
<O17 defaultselect="false" description="Allow line continuation where there is an escape character \ at the end of the line" optionchar="l"/>
<O18 defaultselect="false" description="Read contents as a string before parsing so that errors about some character sets can be avoided; the option slows the computation" optionchar="r"/>
</options>
<params>
<P1 desc="Fi      (Fields to be retrieved. All fields will be retrieved by default. The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="type(Field types include bool, int, long, float, decimal, string, date, time and datetime. Data type of the first row will be used by default; when the parameter value is an integer, it represents serial byte key, which allows 16 bytes only)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="fmt(Date\time format)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="k (The segment number.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="n (The number of segments. Retrieve the whole file when both k and n are omitted.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="s ( User-defined separator. The default separator is tab. When the parameter is omitted, the comma preceding it can be omitted, too. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F386>
<F387 desc="Read in records from an entity table and return them as a table sequence." displaystr="" majortype="102" name="import" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Enable generating a pure table sequence" optionchar="v"/>
<O2 defaultselect="false" description="Automatically close the entity table after data is fetched from the cursor" optionchar="x"/>
</options>
<params>
<P1 desc="x(An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="C(A column name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="wi(Filtering condition; separate multiple conditions by comma(s) and their relationships are AND; besides regular filtering expressions, you can also use the following five types of syntax in a filtering condition, where K is a field in the entity table: 1．K=w w usually uses expression Ti.find(K) or Ti.pfind(K), where Ti is a table sequence. When value of w is null or false, the corresponding record in the entity table will be filtered away; when w is expression Ti.find(K) and the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K; when w is expression Ti.pfind(K) and the to-be-selected fields C,... contain K, ordinal numbers of K values in Ti will be assigned to K. 2．(K1=w1,…Ki=wi,w) Ki=wi is an assignment expression. Generally, parameter wi can use expression Ti.find(Ki) or Ti.pfind(K), where Ti is a table sequence; when wi is expression Ti.find(K) and the to-be-selected fields C,... contain Ki, Ti’s referencing field will be assigned to Ki correspondingly; when wi is expression Ti.pfind(Ki) and the to-be-selected fields C,... contain Ki, ordinal numbers of Ki values in Ti will be assigned to Ki.  w is a filter expression; you can reference Ki in w. 3．K:Ti Ti is a table sequence. Compare Ki value in the entity table with key values of Ti and discard records whose Ki value does not match; when the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K. 4．K:Ti:null Filter away all records that satisfy K:Ti. 5．K:Ti:# Locate records according to ordinal numbers, compare ordinal numbers of records in table sequence Ti according to the entity table’s K values, and discard non-matching records; when the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K.     )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F387>
<F388 desc="Get a table sequence based on a pseudo table" displaystr="" majortype="101" name="import" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="xi (A field expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ci (Field name in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F388>
<F389 desc="Impute missing values to a sequence type variable during modeling" displaystr="" majortype="101" name="impute" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the imputation result after execution" optionchar="c"/>
<O2 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and date" optionchar="BNIED"/>
</options>
<params>
<P1 desc="Rec(A sequence of imputation process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F389>
<F390 desc="Impute missing values to a table sequence/record sequence type variable during modeling" displaystr="" majortype="101" name="impute" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the imputation result after execution" optionchar="c"/>
<O2 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and date" optionchar="BNIED"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of imputation process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F390>
<F391 desc="Create an index on the key of an in-memory table." displaystr="" majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create a multilevel tree-structured index when the in-memory table T’s basic key is serial byte type, and ignore parameter n" optionchar="s"/>
<O2 defaultselect="false" description="Create the index with parallel processing" optionchar="m"/>
<O3 defaultselect="false" description="Create index on the sequence number key" optionchar="n"/>
</options>
<params>
<P1 desc="n (Index length)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F391>
<F392 desc="Create an index table for the key of a table sequence" displaystr="" majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create a multilevel tree-structure index and ignore parameter n if the TSeq’s basic key is serial byte values" optionchar="s"/>
<O2 defaultselect="false" description="Enable parallel processing" optionchar="m"/>
<O3 defaultselect="false" description="Create an ordinal-number index for the table sequence; the index is used for numberizing the foreign key. Foreign key numberization requires that foreign key values of the fact table correspond to ordinal numbers of the dimension table’s records; the ordinal number key can be omitted when using the index, and ignore parameter n when the option works. The option is not fit for a table sequence containing a time key" optionchar="n"/>
</options>
<params>
<P1 desc="n(The length of index)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F392>
<F393 desc="Create an index file for an entity table" displaystr="" majortype="101" name="index" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Work when only parameter f is present; used to load the index file to the memory and can increase performance" optionchar="2"/>
<O2 defaultselect="false" description="Work when only parameter f is present; used to load the index file to the memory; help achieve higher performance than @2 but occupy more memory space" optionchar="3"/>
<O3 defaultselect="false" description="Close the index to release resources when only parameter f is present" optionchar="0"/>
<O4 defaultselect="false" description="Create a full-text index on column C, which should be a string type single column; Support like(&quot;*X*&quot;) style search; X can be a string made up of letters, numbers or common characters, whose length should be greater than 2, or one or more Chinese characters; Case-insensitive when the index string is made up of letters; With this option, parameter h is interpreted as the largest number of records matched with each index string; no such interpretation when h is absent" optionchar="w"/>
</options>
<params>
<P1 desc="f(Index file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="h(Hash index length; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="w(Filtering condition; retrieve the whose set if the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="C(The field for which an index is created)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in an entity table; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F393>
<F394 desc="Create one or multiple non-primary-key-based indexes for an in-memory table" displaystr="" majortype="101" name="index" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="I(Index name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="h(Index length)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="w(Filtering condition; read the whole set when it is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="C(The field(s) on which index is created)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F394>
<F395 desc="Return a positive infinity value; with a negative sign before the function, it will return a negative infinity value. " displaystr="" majortype="101" name="inf" postfix="" returntype="101">
<options/>
<params/>
</F395>
<F396 desc="Close InfluxDB connection." displaystr="" majortype="102" name="influx_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F396>
<F397 desc="Insert one or more records to InfluxDB database." displaystr="" majortype="102" name="influx_insert" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connecton object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="string(Line protocol characters or line protocol arrays of characters. Data format should meet the requirements of InfluxDB line protocol; time stamp is represented in UTC or is in the format of yyyy-MM-ddTHH:mm:ss/yyyy-MM-ddTHH:mm:ssXXZ)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F397>
<F398 desc="Connect to InfluxDB." displaystr="" majortype="102" name="influx_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(Database connection URL)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="database(The database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="retentionPolicy(The retention plicy for defining how long InfluxDb needs to keep the data or which time period of data the database needs to store)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="username(The user name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="password(The password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F398>
<F399 desc="Query InfluxDB database." displaystr="" majortype="102" name="influx_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hd(Connecton object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(The SQL query statement or database search statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F399>
<F400 desc="Insert the members of X before position k in A, and return A." displaystr="" majortype="101" name="insert" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records." optionchar="n"/>
</options>
<params>
<P1 desc="k (The position before which one or more members are inserted, when k==0, the member(s) will be appended in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="X (a sequence composed of the members to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F400>
<F401 desc="Insert member x before position k in A, and return A." displaystr="" majortype="101" name="insert" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records." optionchar="n"/>
</options>
<params>
<P1 desc="k  (The position before which one or more members are inserted, when k==0, the member(s) will be appended in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x   (a member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F401>
<F402 desc="Insert an empty record before the position k in the T. If k is 0, then append it in the end and return the new T" displaystr="" majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records" optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F402>
<F403 desc="Insert a record into T before the position k where the value of Fi is xi and return the new T. When parameter k is omitted, we assume the table sequence T is already ordered by the key and insert records; if the key value has already existed, the function won’t perform the insertion." displaystr="" majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the inserted record or a record sequence of the inserted records" optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k      (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi      (The Fi field value before which the new record is to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi     (The name of field where xi resides; without Fi, it will be the corresponding ith field.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F403>
<F404 desc="Insert multiple records into T before the position k where the value of Fi is xi and return the new T . The number of the records to be inserted is determined by the length of sequence A." displaystr="" majortype="101" name="insert" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-inserted or -modified records or record sequences " optionchar="n"/>
<O2 defaultselect="false" description="T.insert@r(k:A)        Insert sequence A into table squence T from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="T.insert@f(k:A)        Insert sequence A into table squence T from the kth record; only the common fields are inserted. " optionchar="f"/>
</options>
<params>
<P1 desc="k           (The position before which the member, or the record, is inserted. When k==0, append it in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A           (A sequence or an integer; If A is an integer, then it is equals to to(A))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi           (The Fi field value before which the new record is to be inserted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi          (The name of field where xi resides; without Fi, it will be the corresponding ith field.))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F404>
<F405 desc="To obtain the integer part of a numeric value from a numeric string or a number, and convert its data type to 32-bit integer." displaystr="" majortype="102" name="int" postfix="" returntype="101">
<options/>
<params>
<P1 desc="valueExp (an expression, the result of which must be a numeric string or a number.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F405>
<F406 desc="Compute the number of days between two datetime values" displaystr="" majortype="102" name="interval" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Compute the years between two date time data" optionchar="y"/>
<O2 defaultselect="false" description="Compute the months between two date time data" optionchar="m"/>
<O3 defaultselect="false" description="Compute the seconds between two date time data" optionchar="s"/>
<O4 defaultselect="false" description="Compute the milliseconds between two date time data" optionchar="ms"/>
<O5 defaultselect="false" description="Compute the quarters between two date time data" optionchar="q"/>
<O6 defaultselect="false" description="Compute the timespan between two date time data and return Real valuer" optionchar="r"/>
<O7 defaultselect="false" description="Compute the weeks between two datetime values" optionchar="w"/>
<O8 defaultselect="false" description="Compute the number of Sundays between two datetime values according to a left-open interval" optionchar="7"/>
<O9 defaultselect="false" description="Compute the number of Mondays between two datetime values according to a left-open interval" optionchar="1"/>
</options>
<params>
<P1 desc="t1(A date value, datetime value or integer; when it is an integer, it can be understood as value of days@o())" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="t2(A date value, datetime value or integer; when it is an integer, it can be understood as value of days@o())" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F406>
<F407 desc="Adjust the order of members of a sequence." displaystr="" majortype="101" name="inv" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p  (an integer sequence, members of which is the rankings of A, so the number of its members is the same as that of A , and it is a unique n sequence (n=A.len()))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F407>
<F408 desc="Compute the sequence numbers of an integer’s members in another integer sequence." displaystr="" majortype="101" name="inv" postfix="p." returntype="101">
<options/>
<params>
<P1 desc="k (An integer, which is p.len() by default)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F408>
<F409 desc="Calculate the inverse of a square matrix. " displaystr="" majortype="101" name="inverse" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A square matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F409>
<F410 desc="Call the static function of class in the package" displaystr="" majortype="102" name="invoke" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Convert the sequence type parameter or return value; can be performed recursively" optionchar="x"/>
</options>
<params>
<P1 desc="p (package path)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c (class name)" filtertype="0" identifieronly="false" presign="." repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="f (static method name)" filtertype="0" identifieronly="false" presign="." repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="ai (parameter)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F410>
<F411 desc="Check if a string is composed of letters" displaystr="" majortype="102" name="isalpha" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (String/ numeric expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F411>
<F412 desc="Check if a string is composed of numbers." displaystr="" majortype="102" name="isdigit" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String/ numeric expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F412>
<F413 desc="Compute intersection of all sequence-type members in a sequence" displaystr="" majortype="101" name="isect" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F413>
<F414 desc="Retrieve records from file f that is ordered by x field, according to the criterion that the values of x should be members of sequence A" displaystr="" majortype="2" name="iselect" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from an exported binary file, with the support for parameters A, x and Fi, and with no support available for parameter s. Ignore options @t and @c. Segments containing no records may appear if it is a file containing a small number of records; an error report will appear if the file isn’t segmented when being retrieved." optionchar="b"/>
<O3 defaultselect="false" description="Use comma as the separator. By default parameter s is the separator, and use \t as the separator when s is absent. But the user-defined separator s should take priority when there is one." optionchar="c"/>
<O4 defaultselect="false" description="Find all records with the same value of x field; by default x is distinct in the file f." optionchar="r"/>
<O5 defaultselect="false" description="First remove quotation marks surrounding strings, including the headers, and then handle the escaping" optionchar="q"/>
<O6 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O7 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Return a null column if parameter Fi doesn’t exist; the default way of handling is to report error" optionchar="e"/>
<O9 defaultselect="false" description="Perform type matching and delete a record if there is mismatching data type or format in it " optionchar="d"/>
<O10 defaultselect="false" description="Throw an exception, terminate execution, and output the content of the current record whenerrors appear in @d check and @n check" optionchar="v"/>
<O11 defaultselect="false" description="Discard a row whose number of columns doesn’t match the number in the first row" optionchar="n"/>
</options>
<params>
<P1 desc="A (A single value or a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Field name/expression; the sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (Fields to be retrieved, and all fields will be retrieved by default)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="s (User-defined separator. The default is tab. When the parameter is omitted, the comma preceding it can be omitted, too)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F414>
<F415 desc="Rtrieve records from file f that is ordered by x field, according to the criterion that the values of x should fall in the interval [a:b]" displaystr="" majortype="2" name="iselect" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Use the first row of f as the field names. If omitting this option, then use_1,_2,… as the field names" optionchar="t"/>
<O2 defaultselect="false" description="Retrieve data from an exported binary file, with the support for parameters A, x and Fi, and with no support available for parameter s. Ignore options @t and @c. Segments containing no records may appear if it is a file containing a small number of records; an error report will appear if the file isn’t segmented when being retrieved." optionchar="b"/>
<O3 defaultselect="false" description="Use comma as the separator. By default parameter s is the separator, and use \t as the separator when s is absent. But the user-defined separator s should take priority when there is one." optionchar="c"/>
<O4 defaultselect="false" description="Find all records with the same value of x field; by default x is distinct in the file f." optionchar="r"/>
<O5 defaultselect="false" description="First remove quotation marks surrounding strings, including the headers, and then handle the escaping" optionchar="q"/>
<O6 defaultselect="false" description="Use quotation marks as the escape character" optionchar="o"/>
<O7 defaultselect="false" description="Retain the white space on both sides of the data item; without it a trim operation will be automatically performed" optionchar="k"/>
<O8 defaultselect="false" description="Return a null column if parameter Fi doesn’t exist; the default way of handling is to report error" optionchar="e"/>
<O9 defaultselect="false" description="Perform type matching and delete a record if there is mismatching data type or format in it " optionchar="d"/>
<O10 defaultselect="false" description="Throw an exception, terminate execution, and output the content of the current record when errors appear in @d check and @n check" optionchar="v"/>
<O11 defaultselect="false" description="Discard a row whose number of columns doesn’t match the number in the first row" optionchar="n"/>
</options>
<params>
<P1 desc="a (Field value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Field value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x (Field name/expression; the sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi (Fields to be retrieved, and all fields will be retrieved by default)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="s (User-defined separator. The default is tab. When the parameter is omitted, the comma preceding it can be omitted, too)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F415>
<F416 desc="Check if a string is composed of lower case letters" displaystr="" majortype="102" name="islower" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String expression/ Integer expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F416>
<F417 desc="Find missing values in a vector" displaystr="" majortype="101" name="ismiss" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="indicator (A number/string/sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F417>
<F418 desc="Find missing values in a matrix" displaystr="" majortype="101" name="ismissm" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="indicator (A number/string/sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F418>
<F419 desc="Define transaction isolation level for the connection according to the option and return the original level" displaystr="" majortype="102" name="isolate" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Correspond respectively to NONE" optionchar="n"/>
<O2 defaultselect="false" description="Correspond respectively to READ_COMMITTED" optionchar="c"/>
<O3 defaultselect="false" description="Correspond respectively to READ_UNCOMMITTED" optionchar="u"/>
<O4 defaultselect="false" description="Correspond respectively to REPEATABLE_READ" optionchar="r"/>
<O5 defaultselect="false" description="Correspond respectively to SERIALIZABLE" optionchar="s"/>
</options>
<params/>
</F419>
<F420 desc="Check if a string is composed of upper case letters" displaystr="" majortype="102" name="isupper" postfix="" returntype="101">
<options/>
<params>
<P1 desc="string (String expression/ Integer expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F420>
<F421 desc="Perform interative loop on a record sequence and return the result of the last calculation of a given expression." displaystr="" majortype="101" name="iterate" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (An initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c (A boolean expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F421>
<F422 desc="Perform interative loop on record sequences in a channel and return the result of the last calculation of a given expression" displaystr="" majortype="101" name="iterate" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x(An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a(Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c(An expression returns true/false)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F422>
<F423 desc="Perform interative loop on record sequences in a cursor and return the result of the last calculation of a given expression" displaystr="" majortype="101" name="iterate" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x(An expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a(Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="c(An expression returns true/false)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F423>
<F424 desc="An iterative loop for calculating an expression." displaystr="" majortype="102" name="iterate" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (An expression containing ~~)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (Initial value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F424>
<F425 desc="Join multiple sequences according to positions and return a pure table sequence." displaystr="" majortype="102" name="j" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi(Field name(s) in the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F425>
<F426 desc="Join multiple sequences together." displaystr="" majortype="102" name="join" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join. If no matches are found, then correspond to the null" optionchar="f"/>
<O2 defaultselect="false" description="Left join. Please note that this is the number &quot;1&quot; instead of the letter &quot;l&quot;" optionchar="l"/>
<O3 defaultselect="false" description="Supporse if all Ai are in order for xj, then use merge operation instead." optionchar="m"/>
<O4 defaultselect="false" description="Perform a join according to positions while ignoring parameter xj" optionchar="p"/>
<O5 defaultselect="false" description="Used only to filter A1 and ignore parameter Fi; do not work with @f@1 options" optionchar="i"/>
<O6 defaultselect="false" description="Used only to filter A1 to retain records that cannot be found and ignore parameter Fi; do not work with @f@1 options" optionchar="d"/>
</options>
<params>
<P1 desc="Ai (Sequences or record sequences to be joined)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name of the resulting table sequence)" filtertype="0" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (Relational field/ expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F426>
<F427 desc="A foreign-key-style join between table sequences/record sequences, or a table sequence and a record sequence." displaystr="" majortype="101" name="join" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Delete a record with a non-matching foreign key value; by default, a non-matching record will be represented by null. If parameters x:F are omitted, perform the filtering purely over parameter P" optionchar="i"/>
<O2 defaultselect="false" description="If parameter x:F is absent, delete the records matching the foreign key and perform the filtering operation only over table sequence/record sequence P" optionchar="d"/>
<O3 defaultselect="false" description="Enable a merge join when P is ordered by C and T is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C (P’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T (Table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (T’s field expression, which can be represented by ~ and #; the pound sign # represents the sequence number of a record in T; record the sequence number as null if a record doesn’t exist in T)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F427>
<F428 desc="A foreign-key-style join between a channel and a record sequence." displaystr="" majortype="101" name="join" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Delete the whole record if the foreign key can’t be matched; by default make it null." optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…),Generate a new record by introducing the original record as a new field; field expression x can be written as ~, which represents the whole record of ch" optionchar="o"/>
<O3 defaultselect="false" description="Delete the whole record matching foreign key value when parameters x:F are absent and perform filtering on ch only" optionchar="d"/>
<O4 defaultselect="false" description="Use MERGE method during parallel computation when ch is ordered by the foreign key and T is ordered by its key" optionchar="m"/>
</options>
<params>
<P1 desc="C  (Foreign key of a given channel; use comma to separate a composite key)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T  (Table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K  (Key of the given table sequence/record sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x  (A field expression of the given table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F  (Name of the field expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F428>
<F429 desc="Attach foreign key style join with a record sequence to the cursor and return the original cursor.  " displaystr="" majortype="102" name="join" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Delete a record with a non-matching foreign key value; by default a non-matching record will be represented by null" optionchar="i"/>
<O2 defaultselect="false" description="Use the original record as the value of Fi field to generate a new record" optionchar="o"/>
<O3 defaultselect="false" description="If parameters x:F are absent, only perform a filtering over the cursor by deleting its records where the foreign key is matched " optionchar="d"/>
<O4 defaultselect="false" description="Enable a merge join when cs is ordered by C and T is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C (Cursor cs’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T (A table sequence/A record sequence )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (T’s field expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Field name in expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F429>
<F430 desc="A foreign-key-style join between a cluster cursor and a record sequence." displaystr="" majortype="101" name="join" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="With a distributed cluster table, the operation won’t involve a cross-node reference but it assumes that the referenced records are local" optionchar="c"/>
</options>
<params>
<P1 desc="C(cs’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(A cluster memory table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K(T’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x(T’s field expression )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F(Name of T’s field expression)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F430>
<F431 desc="A foreign-key-style join beween an in-memory table and a table sequence or two in-memory tables" displaystr="" majortype="101" name="join" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Delete records of T that cannot match the foreign key, and by default, will record corresponding values as nulls. When parameters x:F are absent, just perform the fileting on T" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…) Use the original records of Ai as a new field F to generate new records; here x is equivalent to ~" optionchar="o"/>
<O3 defaultselect="false" description="Delete records of T that match the foreign key when parameters x:F are absent, which is equivalent to performing fileting on T" optionchar="d"/>
<O4 defaultselect="false" description="When x is represented by ~, record the correspondence relationship between F and C,…in the result set to identify the foreign key for a pre-join" optionchar="k"/>
<O5 defaultselect="false" description="Use MERGE method to compute when T is ordered by C and Ai is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C(T’s foreign key; use colon to separate multiple fields of a composite foreign key)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai(A table sequence or an in-memory table)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="K(Ai’s key)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="x(Expression of an Ai’s field)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="F(Field name of expression x)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F431>
<F432 desc="A foreign-key-style join between a pseudo table and a table sequence/record sequence." displaystr="" majortype="101" name="join" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Delete a record with a non-matching foreign key value; by default, a non-matching record will be represented by null." optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…),Use the record as the value of F field to generate a new record; here expression x is equivalent to ~, which is a whole record of T" optionchar="o"/>
<O3 defaultselect="false" description="When parameters x:F are absent, delete whole records matching the foreign key and perform the filtering operation only over pseudo table T" optionchar="d"/>
<O4 defaultselect="false" description="Enable a merge join when T is ordered by C and A is ordered by K" optionchar="m"/>
</options>
<params>
<P1 desc="C(T’s foreign key; separate multiple fields in a composite key with the colon)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A(Table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K(A’s key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x(A’s field expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F(Field name in expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F432>
<F433 desc="Join table sequences retrieved from a series of cursors." displaystr="" majortype="102" name="joinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join. If no matched value is found, then it corresponds to null" optionchar="f"/>
<O2 defaultselect="false" description="Left join. Note that it is the number “1”, instead of letter “l”. " optionchar="1"/>
<O3 defaultselect="false" description="Perform a join according to positions, while ignoring the parameter xj" optionchar="p"/>
<O4 defaultselect="false" description="Used only to filter A1 cs1 and ignore parameter Fi; do not work with @f@1 options" optionchar="i"/>
<O5 defaultselect="false" description="Used only to filter cs1 to retain records that cannot be found and ignore parameter Fi; do not work with @f@1 options" optionchar="d"/>
</options>
<params>
<P1 desc="csi (Cursors/table sequences/cluster cursors being joined.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name of result TSeq)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xj (Join field/expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F433>
<F434 desc="Join up synchronously segmented cluser cursors." displaystr="" majortype="101" name="joinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Full join; use null to correspond when there is no matching value" optionchar="f"/>
<O2 defaultselect="false" description="Left join; the option is number 1 instead of letter l" optionchar="1"/>
<O3 defaultselect="false" description="Join by positions; ignore parameter xj" optionchar="p"/>
</options>
<params>
<P1 desc="csi (To-be-joined cluster cursors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (The resulting field)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (Joining field/expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F434>
<F435 desc="Join up a cursor and a segmentable bin file by the foreign key." displaystr="" majortype="101" name="joinx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O3 defaultselect="false" description="Speed up the matching action according to a certain order when the cursor contains a relatively small amount of data or it is a sequence; return a sequence when cursor/multicursor cs is a sequence  " optionchar="q"/>
<O4 defaultselect="false" description="Speed up the matching operation by shuffling records in the cursor" optionchar="u"/>
<O5 defaultselect="false" description="Perform a merge join when cs is ordered by C and f is ordered by K; with this option, the bin file f can be a cursor, and when cs is a multicursor, it is the multicursor partitioned in the same way" optionchar="m"/>
</options>
<params>
<P1 desc="C (cs’s foreign key)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (A bin file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (The bin file’s key; it is treated as row number when written as # )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (An expression of the field of f)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Name of the field of expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="n (Number of buffer rows)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F435>
<F436 desc="Join up a cursor and an entity table by the foreign key." displaystr="" majortype="101" name="joinx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O3 defaultselect="false" description="Speed up the matching action according to a certain order when the cursor contains a relatively small amount of data or it is a sequence cs Speed up the join when the cursor contains relatively small amount of data or is a sequence" optionchar="q"/>
<O4 defaultselect="false" description="Speed up the matching action if the cursor is ordered by the first foreign key field.When the cursor is ordered by the first field of its foreign key, use it to speed up the join; can work with @q" optionchar="c"/>
<O5 defaultselect="false" description="Speed up the matching operation by shuffling records in the cursor" optionchar="u"/>
</options>
<params>
<P1 desc="C (cs’s foreign key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P1>
<P2 desc="T (An entity table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="K (The entity table’s key; it is treated as row number when written as #)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="x (An expression of the field of T)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="F (Name of the field of expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="n (Number of buffer rows)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F436>
<F437 desc="Join up a channel and a bin file or an entity table by the foreign key." displaystr="" majortype="102" name="joinx" postfix="ch." returntype="102">
<options>
<O1 defaultselect="false" description="Discard the records whose foreign key values can’t be matched" optionchar="i"/>
<O2 defaultselect="false" description="@o(F;…)   Generate a new record by adding a F field whose values are referenced records; expression x can be represented by ~, which means a record" optionchar="o"/>
<O3 defaultselect="false" description="When parameters x:F are absent, discard the records whose foreign key values are matching" optionchar="d"/>
<O4 defaultselect="false" description="Speed up the matching action according to a certain order when the channel contains a relatively small amount of data or it is a sequence " optionchar="q"/>
<O5 defaultselect="false" description="Speed up the matching action if the channel is ordered by the first foreign key field; can work with @q" optionchar="c"/>
<O6 defaultselect="false" description="Speed up the matching operation by shuffling records in the channel" optionchar="u"/>
</options>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F437>
<F438 desc="Parse a string, a record or a table sequence in JSON format." displaystr="" majortype="102" name="json" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Treat parameter x as an expression and calculate its result" optionchar="v"/>
<O2 defaultselect="false" description="Arrange the returned result set as a same-structure table sequence" optionchar="t"/>
</options>
<params>
<P1 desc="x(A JSON string/record/sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F438>
<F439 desc="Get environment information of the current JVM" displaystr="" majortype="102" name="jvm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Key name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F439>
<F440 desc="Generate a serial byte with a specified number of bytes" displaystr="" majortype="102" name="k" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="l (The length of bytes)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F440>
<F441 desc="Generate a serial byte with a specified number of bytes" displaystr="" majortype="101" name="k" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ni (Byte value)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F441>
<F442 desc="Close a Consumer connection" displaystr="" majortype="101" name="kafka_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd (A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F442>
<F443 desc="Commit the current consumer offset position" displaystr="" majortype="101" name="kafka_commit" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Asynchronous commit" optionchar="a"/>
</options>
<params>
<P1 desc="fd (A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F443>
<F444 desc="Connect to Kafka server" displaystr="" majortype="102" name="kafka_open" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="For the use of clustering and related operations" optionchar="c"/>
</options>
<params>
<P1 desc="filename/fileObject(The attribute parameter file with the extension .properties, which contains the send key, value encoding and message decoding; all of them should correspond to each other one by one/A file object)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="topic(Query one or more specified topics)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="partitionSize(The number of zones on a topic, which can be absent and is valid only in the context of a cluster)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F444>
<F445 desc="Return records in a Consumer topic as a table sequence" displaystr="" majortype="101" name="kafka_poll" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd (A Consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="timeout (The interval of consumer poll loop; default is 1000ms)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="partition(A Kafka topic partition in the cluster mode, which is an integer or an array of integers)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F445>
<F446 desc="A producer publishes messages to topics" displaystr="" majortype="102" name="kafka_send" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A consumer object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="partition(The index number of a topic partition in a cluster, which is an integer beginning from 0)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="key(The key word of a message)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="value(Value of a message)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F446>
<F447 desc="Connect to Kafka server" displaystr="" majortype="101" name="kafka_subscribe" postfix="" returntype="101">
<options/>
<params>
<P1 desc="prop:value (The property parameter Properties, which will be input in the form of k:v and which can include multiple property parameters; refer to Kaka documents to learn more about this)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="topic (Query a topic or multiple topics)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="ValueType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F447>
<F448 desc="Connect to Kafka server" displaystr="" majortype="101" name="kafka_subscribe" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filename (The property parameter file suffixed with .properties)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fileObject  (A file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="topic (Query a topic or multiple topics)" filtertype="0" identifieronly="false" presign=";" repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="valueType (The data type of a Consumer key, which is by default the string; it supports int, integer, float, long and string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F448>
<F449 desc="Get the primary key value of a record." displaystr="" majortype="101" name="key" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="Fi (Key)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F449>
<F450 desc="Set a key for a table sequence." displaystr="" majortype="101" name="keys" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Set the last parameter KT as the time key, and make all other parameters the basic keys" optionchar="t"/>
</options>
<params>
<P1 desc="Ki(Key name; can be one or multiple keys; delete all keys of a memory table when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F450>
<F451 desc="Define the key(s) for a memory table." displaystr="" majortype="101" name="keys" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="@t(…,KT)   Set the last parameter KT as the time key and all other key fields constitute the basic key" optionchar="t"/>
</options>
<params>
<P1 desc="Ki(Key name; can be one or multiple keys; delete all keys of a memory table when the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F451>
<F452 desc="Create an index over a primary key when the latter is set" displaystr="" majortype="101" name="keys" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Create a hash index" optionchar="i"/>
<O2 defaultselect="false" description="Create a serial byte index for a serial byte primary key; omit parameter n when using this option" optionchar="s"/>
<O3 defaultselect="false" description="Enable parallel processing" optionchar="m"/>
<O4 defaultselect="false" description="Indicate that a table has a time key" optionchar="t"/>
<O5 defaultselect="false" description="Indicate that a table has a sequence number key" optionchar="n"/>
</options>
<params>
<P1 desc="Ki(Primary key, which can be one or multiple; delete all keys of a memory table when this parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(An integer greater than 1, which is length of the hash table; its default lenght is the table length. Will be omitted when creating a serial byte index with @s option)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F452>
<F453 desc="Perform an unsupervised clustering algorithm that divides a dataset into predetermined number of clusters based on the minimum error function" displaystr="" majortype="101" name="kmeans" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence, which is the training set)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F453>
<F454 desc="An external libaray function that builds models and performs predictions using the Lasso regression method." displaystr="" majortype="102" name="lasso" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Number of iterations; default is 1000)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F454>
<F455 desc="Return the least common multiple" displaystr="" majortype="102" name="lcm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The expression, which will be ignored if its value is not a number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F455>
<F456 desc="Return the least common multiple" displaystr="" majortype="102" name="lcm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F456>
<F457 desc="Get the substring from the left of a string" displaystr="" majortype="102" name="left" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s(The source string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(The nth character of source string s; return an empty string when the absolute value of n is greater than the length of s)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F457>
<F458 desc="Get the length of a sequence" displaystr="" majortype="101" name="len" postfix="A." returntype="101">
<options/>
<params/>
</F458>
<F459 desc="Get the number of records in a memory table." displaystr="" majortype="101" name="len" postfix="T." returntype="101">
<options/>
<params/>
</F459>
<F460 desc="Compute the length of string" displaystr="" majortype="102" name="len" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (String for which you want to compute the length)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Charset; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F460>
<F461 desc="Compute the logarithm." displaystr="" majortype="102" name="lg" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x(Real number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b(Base; default is 10)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F461>
<F462 desc="Find if a string matches a format string" displaystr="" majortype="102" name="like" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Indicate not case-sensitive during matching, otherwise, case sensitive by default" optionchar="c"/>
<O2 defaultselect="false" description="Use SQL wildcard characters; % matches zero or multiple characters and __ matches a single character; This option does not work with @c option. " optionchar="s"/>
</options>
<params>
<P1 desc="stringExp      (Expression of character sting) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="formatExp     (Expression of format string) " filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F462>
<F463 desc="Perform linear fitting using the least squares method." displaystr="" majortype="101" name="linefit" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable returning a vector since parameter Y is a vector" optionchar="1"/>
</options>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A matrix or a vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F463>
<F464 desc="For linear programming and calculate absolute value in linear objective function under linear constraints" displaystr="" majortype="101" name="lineplan" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence representing coefficient matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence representing a constraints matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="C(The objective function matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F464>
<F465 desc="Compute the natural logarithm of parameters" displaystr="" majortype="102" name="ln" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data for which you want to compute the natural logarithm)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F465>
<F466 desc="Switch file(s) or homo-name files group between the local and QVM" displaystr="" majortype="101" name="load" postfix="qvm." returntype="101">
<options/>
<params>
<P1 desc="l(Local file(s)/homo-name files group to be uploaded)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(The parameter is a zone table number or a sequence of zone table numbers when parameters l and r are homo-name files group; otherwise, it will be ignored)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="r(To-be-downloaded file(s)/homo-name files in the QVM main directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="z(The parameter is a zone table number or a sequence of zone table numbers when parameters l and r are homo-name files group)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F466>
<F467 desc="Use a synchronization lock." displaystr="" majortype="101" name="lock" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Unlock the restriction" optionchar="n"/>
</options>
<params>
<P1 desc="n (Lock name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (Timeout (in millisecond); waiting to be locked if the parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F467>
<F468 desc="Convert the value of a string  to a 64-bit long integer." displaystr="" majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (The string expression you want to return as a long integer.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F468>
<F469 desc="Convert the value of  a number to a 64-bit long integer." displaystr="" majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp(The number you want to return as a long integer. If the number contains decimal fractions, the fractional part will be truncated. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F469>
<F470 desc="Convert a date to a 64-bit long integer" displaystr="" majortype="102" name="long" postfix="" returntype="101">
<options/>
<params>
<P1 desc="dateExp(Date type expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F470>
<F471 desc="Convert all characters to lower case" displaystr="" majortype="102" name="lower" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="A quoted string won’t be converted" optionchar="q"/>
</options>
<params>
<P1 desc="s      (Strings you want to convert to the lower case)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F471>
<F472 desc="Get members at specified positions.-n&lt;=i&lt;=n and i is not equal to 0; For 1≤i≤n, it indicates to get the ith member; For -n≤i≤-1,  it indicates to get the ith member from the last " displaystr="" majortype="101" name="m" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="i (an integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F472>
<F473 desc="P is a non-zero n-integer sequence " displaystr="" majortype="101" name="m" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="P (A non-zero n-integer sequence) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F473>
<F474 desc="Get members of a sequence at specified positions to form a new sequence." displaystr="" majortype="101" name="m" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="a (Integer; 1 by default)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Integer; -1 by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="c (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="d (Integer; 1 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="e (Integer; -1 by default)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F474>
<F475 desc="Calculate the mean absolute error between two vectors." displaystr="" majortype="101" name="mae" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vectors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vectors)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F475>
<F476 desc="Correct Akima piecewise cubic Hermite interpolation" displaystr="" majortype="102" name="makimamthd" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (A one-dimensional sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (A one-dimensional sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="newx (A one-dimensional sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F476>
<F477 desc="Compute the maximum value of all the non-null members in a sequence.Equivalent to max(x1,…,xn)" displaystr="" majortype="101" name="max" postfix="A." returntype="101">
<options/>
<params/>
</F477>
<F478 desc="Compute x with each member of the sequence and then compute the maximum value of the members of the new sequence,Equivalent to A.(x).max()" displaystr="" majortype="102" name="max" postfix="A." returntype="102">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F478>
<F479 desc="Compute expression x over sequence A and return members of A that makes expression x get the greatest value." displaystr="" majortype="101" name="maxp" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return all the members that fulfill the condition; by default, return the first one" optionchar="a"/>
<O2 defaultselect="false" description="Search the members from back to front" optionchar="z"/>
</options>
<params>
<P1 desc="x  (An expression that by default returns the last member of sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F479>
<F480 desc="Perform cumulative sum on a matrix or a multidimensional matrix." displaystr="" majortype="102" name="mcumsum" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A matix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F480>
<F481 desc="Generate a multicursor based on a sequence of cursors." displaystr="" majortype="101" name="mcursor" postfix="CS." returntype="101">
<options/>
<params/>
</F481>
<F482 desc="Generate a multicursor based on one cursor." displaystr="" majortype="101" name="mcursor" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="n  (An integer, which should be no greater than the number of parallel tasks set in TOOL&gt;OPTION.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F482>
<F483 desc="Get  a string’s MD5 signature. " displaystr="" majortype="101" name="md5" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F483>
<F484 desc="Divide a sequence into multiple segments and return the specified bordering member(s)." displaystr="" majortype="101" name="median" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="k (The kth segment (1=&lt;k&lt;=n); return the bordering members of between every two segments as sequence when k is absent )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The number of to-be-divided segments, which is greater than 1 and whose default is 2; can be omitted when parmeter k is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x (An expression; parameters k,n cannot be omitted this parameter is present)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F484>
<F485 desc="Generate an in-memory table from a cursor." displaystr="" majortype="102" name="memory" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="Group the would-be in-memory table by the first field; this requires that the cursor is ordered by the first field " optionchar="p"/>
<O2 defaultselect="false" description="The option requires that data in the cursor should be of a pure table sequence and it enables to return a column-wise in-memory table" optionchar="v"/>
<O3 defaultselect="false" description="Automatically close the cursor after the in-memory table is generated" optionchar="x"/>
</options>
<params>
<P1 desc="K (The key; can be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F485>
<F486 desc="Generate a cluster memory table from a cluster cursor." displaystr="" majortype="101" name="memory" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="K(The key; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F486>
<F487 desc="Generate a cluster memory table from a local memory table" displaystr="" majortype="101" name="memory" postfix="" returntype="101">
<options/>
<params>
<P1 desc="h (Node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="V (A memory table’s global variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F487>
<F488 desc="Generate a in-memory table from an entity table." displaystr="" majortype="101" name="memory" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Group the would-be in-memory table by the first field, and this requires that the entity table must be ordered by the first field; when the entity table is already segmented and the to-be-imported fields include its first field, the result in-memory table will inherit the composite table’s segmentation property" optionchar="p"/>
<O2 defaultselect="false" description="The option requires that the entity table be a pure table sequence and it enables to return a column-wise in-memory table" optionchar="v"/>
<O3 defaultselect="false" description="Automatically close the entity table after the in-memory table is generated" optionchar="x"/>
<O4 defaultselect="false" description="Used on a multizone composite table; Perform update merge; ignore the record in the zone table having the smaller number when there are same key values in two zone tables; Split zone tables according to the way of segmenting the first zone table; first read certain zone tables after the first one wholly if they are small enough. " optionchar="w"/>
</options>
<params>
<P1 desc="C(A column name; import all columns when the parameter is omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition; won’t perform filtering when the parameter is omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F488>
<F489 desc="Generate a cluster memory table from a cluster entity table." displaystr="" majortype="101" name="memory" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="C(A column name; import all columns when the parameter is omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="w(Filtering condition; won’t perform filtering when the parameter is omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F489>
<F490 desc="Convert a table sequence to an in-memory table." displaystr="" majortype="101" name="memory" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Directly use records of the original table sequence; when data of the original table sequence changes, the data in the returned in-memory table follows to change; by default the function copies and convert data in the original table sequence; in this case, data in the in-memory table does not follow to change even if data in the original table sequence changes" optionchar="o"/>
</options>
<params/>
</F490>
<F491 desc="Merge multiple table sequences/record sequences." displaystr="" majortype="101" name="merge" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Remove the duplicates from the table sequence/record sequence generated from unioning members of A(i)s in certain order; records with same xi have same corresponding members of A(i)" optionchar="u"/>
<O2 defaultselect="false" description="Return a table sequence/record sequence composed of the common members of A(i)s" optionchar="i"/>
<O3 defaultselect="false" description="Generate a new table sequence/record sequence by removing members of A(2)&amp;…A(n) from A(1)." optionchar="d"/>
<O4 defaultselect="false" description="Do not assume that A(i) is already sorted by [xi,…]" optionchar="o"/>
<O5 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
<O6 defaultselect="false" description="Remove common members of A(i) and union the other members to generate a new table sequence/sequence" optionchar="x"/>
</options>
<params>
<P1 desc="xi  (A field of A(i). If performing merge by multiple fields, use the comma to separate them, for example, x1,x2... )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F491>
<F492 desc="Merge data of the member cursors of a sequence of cursors  and return a multicursor. " displaystr="" majortype="101" name="merge" postfix="CS." returntype="101">
<options>
<O1 defaultselect="false" description="Union operation. Remove the duplicate records from the resulting cursor obtained by unioning the cursor members of CS in certain order. By default, the duplicate records are included" optionchar="u"/>
<O2 defaultselect="false" description="Intersection operation. Return a cursor composed of common members of members of CS, the sequence of cursors." optionchar="i"/>
<O3 defaultselect="false" description="Difference operation. Create a new cursor by removing members of CS2&amp;…CSn from CS1" optionchar="d"/>
<O4 defaultselect="false" description="Put records with null values at the end" optionchar="o"/>
<O5 defaultselect="false" description="Only merge distinct records in member cursors" optionchar="x"/>
</options>
<params>
<P1 desc="xi(An expression. If performing merge by multiple fields, use comma to separate them, for example, x1,x2...)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F492>
<F493 desc="Merge members of a sequence of composite table (multi)cursors" displaystr="" majortype="101" name="mergex" postfix="CS." returntype="101">
<options/>
<params/>
</F493>
<F494 desc="Search for positions of non-zero members in a vector or matrix." displaystr="" majortype="102" name="mfind" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A vector or a matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F494>
<F495 desc="Create indicator variable for missing values in a sequence variable" displaystr="" majortype="101" name="mi" postfix="A." returntype="101">
<options/>
<params/>
</F495>
<F496 desc="Create indicator variable for missing values for a table sequence/record sequence variable during modeling" displaystr="" majortype="101" name="mi" postfix="P." returntype="101">
<options/>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F496>
<F497 desc="Get the substring of a string " displaystr="" majortype="102" name="mid" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s(The source string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(The starting position of the substring; if n&lt;0, count backwards from the last character of source string s, fill in the extra positions with spaces and make the abs(n)th-to-last character the starting position)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="l(The length of substring; by default, the length will be counted from the starting character to the end of the source string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F497>
<F498 desc="Get the millisecond from a specified datetime value." displaystr="" majortype="102" name="millisecond" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (An expression whose result is a date or a datetime value of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F498>
<F499 desc="Compute the minimum value of all the non-null members in a sequence.Equivalent to min(x1,…,xn)" displaystr="" majortype="101" name="min" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Do not ignore null" optionchar="0"/>
</options>
<params/>
</F499>
<F500 desc="Compute x with each member of the sequence and then compute the minimum value of the members of the new sequence" displaystr="" majortype="101" name="min" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F500>
<F501 desc="Get the member that makes the minimum value for the expression" displaystr="" majortype="101" name="minp" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return all the members that fulfill the condition. By default, return the first eligible member" optionchar="a"/>
<O2 defaultselect="false" description="Search the members from back to front " optionchar="z"/>
</options>
<params>
<P1 desc="x (An expression that by default returns the first member of A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F501>
<F502 desc="Get the minute from a datetime value." displaystr="" majortype="102" name="minute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp (An expression whose result is a date or a datetime value of standard format)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F502>
<F503 desc="Calculate the mean value within a matrix or a multidimensional marix." displaystr="" majortype="102" name="mmean" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Calculate the mean on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F503>
<F504 desc="Normalize a matrix or a multidimensional matrix, during which the center value is 0 and the standard deviation is 1." displaystr="" majortype="102" name="mnorm" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Handle the normalization using a statistical method where n-1 is the divisor" optionchar="s"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F504>
<F505 desc="Get the most frequently appearing members from a sequence or a table sequence." displaystr="" majortype="101" name="mode" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Fields of the table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F505>
<F506 desc="Modify the field values of a record" displaystr="" majortype="101" name="modify" postfix="r." returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="r"/>
</options>
<params>
<P1 desc="xi  (Modification expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Name of the field to be modified. The ith field in r will be modified if Fi isn’t supplied.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F506>
<F507 desc="Modify the kth record, which is equal to T(k).modify(xi:Fi,…)" displaystr="" majortype="101" name="modify" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-modified records or record sequences" optionchar="n"/>
<O2 defaultselect="false" description="@r(k:A)    Modify table sequence T using squence A from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="@f(k:A)    Modify table sequence T using squence A from the kth record; only the common fields are modified. " optionchar="f"/>
</options>
<params>
<P1 desc="k   (The position at which the record will be modified. If k exceeds the limit, then append a new record in the end.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi   (The value of Fi field to be modified)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi   (Name of the field of the record which will be modified. If Fi is omitted, then modify the ith field of T.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F507>
<F508 desc="Modify the records from the kth record to the (k+|A|-1)th record" displaystr="" majortype="101" name="modify" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Return the newly-modified records or record sequences" optionchar="n"/>
<O2 defaultselect="false" description="@r(k:A)   Modify table sequence T using squence A from the kth record according to the order of the fields" optionchar="r"/>
<O3 defaultselect="false" description="@f(k:A)   Modify table sequence T using squence A from the kth record; only the common fields are modified. " optionchar="f"/>
</options>
<params>
<P1 desc="k (The position at which the record will be modified. If k exceeds the limit, then append a new record in the end.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A (A sequence or an integer; If A is an integer, then it is equal to to(A))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (The value of Fi field to be modified)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi (Name of the field of the record which will be modified. If Fi is omitted, then modify the ith field of T.)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F508>
<F509 desc="Assign x to the kth member of sequence A" displaystr="" majortype="101" name="modify" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the modified record or a record sequence of modified records" optionchar="n"/>
</options>
<params>
<P1 desc="k (A member position; If k is greater than the length of sequence A, then append the member in the end)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (a member value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F509>
<F510 desc="Assign members of X to members of A in order from the kth position to the (k+|X|-1)th position " displaystr="" majortype="101" name="modify" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return the modified record or a record sequence of modified records" optionchar="n"/>
</options>
<params>
<P1 desc="k  (A member position; If k is greater than the length of sequence A, then append the member in the end)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="X (a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F510>
<F511 desc="Close conncetion to MongoDB database" displaystr="" majortype="101" name="mongo_close" postfix="" returntype="102">
<options/>
<params/>
</F511>
<F512 desc="Insert data to a MongoDB database." displaystr="" majortype="102" name="mongo_insert" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(A MongoDB database object to be connected)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="collection(A MongoDB collection)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="T(A table sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F512>
<F513 desc="Insert data to a MongoDB database." displaystr="" majortype="102" name="mongo_insert" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd (A MongoDB database object to be connected)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="collection (A MongoDB collection)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F513>
<F514 desc="Connect to the MongoDB server." displaystr="" majortype="101" name="mongo_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (mongodb://[username:password@]host1[:port1]       [,host2[:port2],...[,hostN[:portN]]]/database[?options])" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="keyStory(Set keyStory when using SSL/TLS to connect MongoDB server, meaning it is a trusted certificate)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="keyStoryPasswd(Password of keyStory)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F514>
<F515 desc="Query and manipulate the databsase and return result value." displaystr="" majortype="102" name="mongo_shell" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Return a table sequence" optionchar="d"/>
<O2 defaultselect="false" description="Return a cursor; should be used together with @d option, otherwise it is invalid" optionchar="c"/>
<O3 defaultselect="false" description="Go on with the execution when error appears and return the error information" optionchar="e"/>
</options>
<params>
<P1 desc="fd (MongoDB connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (An MongoDB function, which supports find, count, distinct and aggregate and follows the MongoDB syntax)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F515>
<F516 desc="Get the month from a specified date/datetime value." displaystr="" majortype="102" name="month" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a 6-digit number if there is a year part in the parameter" optionchar="y"/>
</options>
<params>
<P1 desc="dateExp (An expression whose result is a date or a datetime value of standard format; it can be an integer, which we can regard as the value of computing days@o().)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F516>
<F517 desc="Move, delete, or rename a file." displaystr="" majortype="102" name="movefile" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Force an execution of the function if the target file already exists. Without the option you can’t force an execution. Delete the target file if parameter path is absent." optionchar="y"/>
<O2 defaultselect="false" description="Copy the file. If the target file name is the same as that of the specified file to which it will be moved, the copy fails." optionchar="c"/>
<O3 defaultselect="false" description="path is relative to the main directory when it is a relative path; default is relative to fn’s parent directory" optionchar="p"/>
</options>
<params>
<P1 desc="fn(A file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="z(An integer; it represents the zone table number when parameter fn is a homo-name files group; or is omitted when fn isn’t a homo-name files group)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="path(The path (with file name) along which the file is moved, or a file name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F517>
<F518 desc="Move a file from a node to another" displaystr="" majortype="102" name="movefile" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Force moving to overwerite a namesake file while default is failure, and deletion when path is null;" optionchar="y"/>
<O2 defaultselect="false" description="Copy the file, and the copy fails if there is already a namesake file" optionchar="c"/>
</options>
<params>
<P1 desc="fn(A file name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="h(A node)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="path(A path (that contains file name) to which a file is moved, or a file name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="hs(A node or a node sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F518>
<F519 desc="Fill missing values with moving window method." displaystr="" majortype="102" name="movmthd" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Fill missing items with median of moving window" optionchar="i"/>
</options>
<params>
<P1 desc="window (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F519>
<F520 desc="Calculate the standard error of the mean between two vectors." displaystr="" majortype="101" name="mse" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(Vectors)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(Vectors)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F520>
<F521 desc="Calculate the standard deviation on a matrix or a multidimensional marix." displaystr="" majortype="102" name="mstd" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Perform the calculation using a statistical method, during which the n-1 is the divisor" optionchar="s"/>
<O2 defaultselect="false" description="Calculate the standard deviation on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F521>
<F522 desc="Calculate sum on a matrix or a multidimensional marix." displaystr="" majortype="102" name="msum" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Calculate sum on all elements of matrix A and parameter n is invalid" optionchar="a"/>
</options>
<params>
<P1 desc="A(A matrix or a multidimensional matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(A positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F522>
<F523 desc="Calculate the product of two matrices or vectors." displaystr="" majortype="101" name="mul" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A matrix or a vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F523>
<F524 desc="Create indicator variables for the MVP analysis and automatically perform the subsequent handling according to a sequence of indicator variables for missing values" displaystr="" majortype="101" name="mvp" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(A sequence of target variable values)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of creation and handling records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F524>
<F525 desc="Create indicator variables for the MVP analysis and automatically perform the subsequent handling according to a table sequence/record sequence of indicator variables for missing values" displaystr="" majortype="101" name="mvp" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F525>
<F526 desc="Return a file’s path relative to the main directory." displaystr="" majortype="2" name="name" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Return a full path" optionchar="p"/>
</options>
<params/>
</F526>
<F527 desc="Perform computation on a sequence to generate a new table sequence." displaystr="" majortype="101" name="new" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel processing to speed up computation" optionchar="m"/>
<O2 defaultselect="false" description="Won’t generate a record if the result of expression xi is null." optionchar="i"/>
<O3 defaultselect="false" description="When parameter A is a pure table sequence, directly reference an old column if it is unmodified instead of generating a new column; sequence A will also be updated when the result table sequence is updated" optionchar="o"/>
<O4 defaultselect="false" description="Perform an inverse operation; only apply to non-pure sequences" optionchar="z"/>
</options>
<params>
<P1 desc="xi(An expression whose results are field values; if omitted, field values will be nulls a, and when is absent, :Fi must not be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi(Field names of the result table sequence; use xi when the parameter is absent; use the original field names when xi is #i)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F527>
<F528 desc="Return the channel with newly-computed field values for its records." displaystr="" majortype="101" name="new" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate the corresponding record when the result of computing expression xi is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi  (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name in the given channel; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F528>
<F529 desc="Attach the action of computing new field values to a cursor and return the original cursor." displaystr="" majortype="101" name="new" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t generate a record if the result of expression xi is null" optionchar="i"/>
</options>
<params>
<P1 desc="xi (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field name of cs; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F529>
<F530 desc="Return a table sequence/cursor consisting of the specified fields according to the correspondence between the composite table’s key (/dimension) and the corresponding field in the table sequence/cursor." displaystr="" majortype="101" name="new" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Copy records of the primary table and return result set aligned by A/cs" optionchar="r"/>
</options>
<params>
<P1 desc="A/cs(A table sequence/cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="K(Name of the A/cs’s field that corresponds to T’s key (/dimension) Field of A/cs; when it is specified, use it to match with T’s key (/dimension); when it is absent, use the first field of A/cs to perform the matching; when there are multiple  Ks, use colon (:) to separate them)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(Field expression or aggregate function count/sum/max/min/avg)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="C(Column alias; can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="wi(Filtering condition; separate multiple conditions by comma(s) and their relationships are AND; besides regular filtering expressions, you can also use the following five types of syntax in a filtering condition, where K is a field in the entity table: 1．K=w w usually uses expression Ti.find(K) or Ti.pfind(K), where Ti is a table sequence. When value of w is null or false, the corresponding record in the entity table will be filtered away; when w is expression Ti.find(K) and the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K; when w is expression Ti.pfind(K) and the to-be-selected fields C,... contain K, ordinal numbers of K values in Ti will be assigned to K. 2．(K1=w1,…Ki=wi,w) Ki=wi is an assignment expression. Generally, parameter wi can use expression Ti.find(Ki) or Ti.pfind(K), where Ti is a table sequence; when wi is expression Ti.find(K) and the to-be-selected fields C,... contain Ki, Ti’s referencing field will be assigned to Ki correspondingly; when wi is expression Ti.pfind(Ki) and the to-be-selected fields C,... contain Ki, ordinal numbers of Ki values in Ti will be assigned to Ki.  w is a filter expression; you can reference Ki in w. 3．K:Ti Ti is a table sequence. Compare Ki value in the entity table with key values of Ti and discard records whose Ki value does not match; when the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K. 4．K:Ti:null Filter away all records that satisfy K:Ti.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F530>
<F531 desc="Compute each member of a sequence according to the specified condition to generate multiple records and concatenate them into a new table sequence." displaystr="" majortype="101" name="news" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Left join, which creates an empty record when X is empty; here it is number 1 instead of letter l" optionchar="1"/>
<O2 defaultselect="false" description="Use parallel processing to increase performance" optionchar="m"/>
</options>
<params>
<P1 desc="X(A sequence/integer; can be understood as to(X) when it is an integer, meaning performing X number of computations on sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (Expression, whose results will be field values; the sign ~ used in the parameter references data from record sequence X instead of A. The sign # is used to represent a field with a sequence number  )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi(Field name of the result sequence; when omitted, field names are xi by default, and use the original field names when xi is #i)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F531>
<F532 desc="Get new values for the fields of records in a channel and update them into the channel." displaystr="" majortype="101" name="news" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="X  (Record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi  (Expression, whose results will be field values; the sign ~ used in the parameter references data from X instead of A. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi  (Field name in the given channel; will be automatically identified if the parameter is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F532>
<F533 desc="Generate multiple records based on a record sequence, concatenate them into a new table sequence and return it to the original cursor." displaystr="" majortype="101" name="news" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Left join, which creates an empty record when record sequence X is empty" optionchar="1"/>
</options>
<params>
<P1 desc="X (Record sequence )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="xi (An expression, whose values are uses as the new field values. It is treated as null if omitted; in that case, : Fi can’t be omitted. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (Filed name of the new cs; use the identifiers parsed from expression xi if it is omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F533>
<F534 desc="Return a table sequence/cursor consisting of the specified fields according to the correspondence between the table sequence/cursor’s key and the corresponding field in the composite table." displaystr="" majortype="102" name="news" postfix="T." returntype="102">
<options>
<O1 defaultselect="false" description="Perform aggregation on data of the subtable and return a result set aligned to A/cs" optionchar="r"/>
</options>
<params>
<P1 desc="A/cs(A table sequence/cursor/composite table cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="K( A/cs’s field name; when it is specified, use it to match with T’s first field; when it is absent, use A/cs’s key (/dimension) to perform the matching; when there are multiple Ks, use colon (:) to separate them)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(Field value)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="C(Column alias)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="wi(Filtering condition; separate multiple conditions by comma(s) and their relationships are AND; besides regular filtering expressions, you can also use the following five types of syntax in a filtering condition, where K is a field in the entity table: 1．K=w w usually uses expression Ti.find(K) or Ti.pfind(K), where Ti is a table sequence. When value of w is null or false, the corresponding record in the entity table will be filtered away; when w is expression Ti.find(K) and the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K; when w is expression Ti.pfind(K) and the to-be-selected fields C,... contain K, ordinal numbers of K values in Ti will be assigned to K. 2．(K1=w1,…Ki=wi,w) Ki=wi is an assignment expression. Generally, parameter wi can use expression Ti.find(Ki) or Ti.pfind(K), where Ti is a table sequence; when wi is expression Ti.find(K) and the to-be-selected fields C,... contain Ki, Ti’s referencing field will be assigned to Ki correspondingly; when wi is expression Ti.pfind(Ki) and the to-be-selected fields C,... contain Ki, ordinal numbers of Ki values in Ti will be assigned to Ki.  w is a filter expression; you can reference Ki in w. 3．K:Ti Ti is a table sequence. Compare Ki value in the entity table with key values of Ti and discard records whose Ki value does not match; when the to-be-selected fields C,... contain K, Ti’s referencing field will be assigned to K. 4．K:Ti:null Filter away all records that satisfy K:Ti.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F534>
<F535 desc="Find records in a recursive way where the foreign key values reference a specified record." displaystr="" majortype="101" name="nodes" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Make the function return leaf-level nodes " optionchar="d"/>
<O2 defaultselect="false" description="Make the function return all child nodes and their level relative to the root node. " optionchar="p"/>
</options>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r (A record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (A number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F535>
<F536 desc="Normalize a matrix or a vector" displaystr="" majortype="102" name="norm" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable subtracting the mean from each row only without keeping lengths same;the mean value after normalization is 0." optionchar="0"/>
<O2 defaultselect="false" description="0-1 normalization; mean value after normalization is 0, and standard deviation is 1" optionchar="s"/>
</options>
<params>
<P1 desc="A(A matrix or a vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F536>
<F537 desc="An inverse normal cumulative distribution function." displaystr="" majortype="102" name="norminv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(Probability,  within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mu(The mean value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="sigma(The standard deviation, which is a positive number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F537>
<F538 desc="On integers, perform bitwise NOT operation to get the logical negation on each bit" displaystr="" majortype="102" name="not" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x  (The numeric expression for which you want to find the logical negation on each bit)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F538>
<F539 desc="Get the current system date time" displaystr="" majortype="102" name="now" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return the date part only, date type" optionchar="d"/>
<O2 defaultselect="false" description="Return the time part only, time type" optionchar="t"/>
<O3 defaultselect="false" description="Acurrate to minute" optionchar="m"/>
<O4 defaultselect="false" description="Accurate to second" optionchar="s"/>
<O5 defaultselect="false" description="Accurate to hour" optionchar="h"/>
</options>
<params/>
</F539>
<F540 desc="Divide a set of natural numbers into a number of subsets of equal length k, and find out the bucket number of the subset where the ith member settles" displaystr="" majortype="102" name="ntile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i (Integer; the sequence number of a member.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Integer; the length of a subset.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F540>
<F541 desc="Divide a set with length of n into a number of subsets of equal length k, and find out the bucket number of the subset where the ith member settles" displaystr="" majortype="102" name="ntile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="i (The sequence number of a member, which is an integer and meets i&lt;=n)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (The length of each subset, which is an integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (Length of the set, which is an integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F541>
<F542 desc="Convert a string to a number." displaystr="" majortype="101" name="number" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp (A string expression, the result of which is a numeric value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (A format string;can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F542>
<F543 desc="Normalize a sequence type numeric variable during modeling" displaystr="" majortype="101" name="numnorm" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the normalization result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(A sequence of normalization process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F543>
<F544 desc="Normalize a table sequence/record sequence numeric variable during modeling" displaystr="" majortype="101" name="numnorm" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the normalization result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of normalization process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F544>
<F545 desc="Get the first non-null member that isn’t double quoted from an integer sequence." displaystr="" majortype="101" name="nvl" postfix="A." returntype="101">
<options/>
<params/>
</F545>
<F546 desc="Convert a pure table sequence to an ordinary sequence." displaystr="" majortype="101" name="o" postfix="P." returntype="101">
<options/>
<params/>
</F546>
<F547 desc="Close connection to a multidimensional database." displaystr="" majortype="102" name="olap_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="conn (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F547>
<F548 desc="Establish connection to multidimensional database." displaystr="" majortype="101" name="olap_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="url (Address of the server on which a multidimensional database runs)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="catalog (The multidimensional database name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="user (User name for accessing a multidimensional database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="pwd (Password for accessing a multidimensional database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F548>
<F549 desc="Query data in a multidimensional database and return the result." displaystr="" majortype="101" name="olap_query" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return a cursor" optionchar="c"/>
</options>
<params>
<P1 desc="conn (The connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mdx (A multidimensional database query that allows one or two axes)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F549>
<F550 desc="Create a multidimensional matrix where all the elements are1." displaystr="" majortype="102" name="ones" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ni(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F550>
<F551 desc="Open a composite table’s base table" displaystr="" majortype="101" name="open" postfix="f." returntype="101">
<options/>
<params/>
</F551>
<F552 desc="Generate a cluster table from a cluster file." displaystr="" majortype="2" name="open" postfix="" returntype="101">
<options/>
<params/>
</F552>
<F553 desc="Perform bitwise OR operation on integers" displaystr="" majortype="102" name="or" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (A numeric expression based on which you perform the bitwise OR operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F553>
<F554 desc="Perform bitwise OR operation on integers" displaystr="" majortype="102" name="or" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F554>
<F555 desc="Print out data to console" displaystr="" majortype="102" name="output" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Print out the print data along with current time and place the current time before the print data " optionchar="t"/>
<O2 defaultselect="false" description="Won’t create a new line using carriage return after the current info is output, which means info of the next cell will be printed on same line of that of the current one" optionchar="s"/>
<O3 defaultselect="false" description="Also record data in the log file; default log level is info" optionchar="g"/>
<O4 defaultselect="false" description="Also record data in the log file; default log level is debug" optionchar="g1"/>
<O5 defaultselect="false" description="Also record data in the log file; default log level is info" optionchar="g2"/>
<O6 defaultselect="false" description="Also record data in the log file; default log level is warning" optionchar="g3"/>
<O7 defaultselect="false" description="Also record data in the log file; default log level is server" optionchar="g4"/>
</options>
<params>
<P1 desc="x  (Export parameters separated with comma)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F555>
<F556 desc="Get serial numbers of the members at the specified positions.-n≤i≤n and i is not equal to 0; For 1≤i≤n, it indicates to get the serial number of the ith  member; For -n≤i≤-1, it indicates to get the serial number of the ith member from the last. " displaystr="" majortype="101" name="p" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="i (an integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F556>
<F557 desc="Get serial numbers of the members at the specified positions.P is the n integer sequence whose length is m, the member values of which should be larger  than -n and less than n, but not equal to 0. " displaystr="" majortype="101" name="p" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Turn back the position exceeding the boundary of A, that is, to set i=if(i%n==0,n,i%n), where n is the length of A." optionchar="r"/>
<O2 defaultselect="false" description="The position exceeding the boundary of A will be ignored." optionchar="0"/>
</options>
<params>
<P1 desc="P(the n integer sequence whose length is m)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F557>
<F558 desc="Pad another character string ahead of the character string until reaching the specified length." displaystr="" majortype="102" name="pad" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Pad another character string on the right of the character string" optionchar="r"/>
</options>
<params>
<P1 desc="s (Character string expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="c (Character string expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="l (Character string whose result is the numeric value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F558>
<F559 desc="Add members of a sequence to another one until the latter reaches certain length." displaystr="" majortype="101" name="pad" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Add members before the existing members of sequence A; by default the additions will be placed at its end." optionchar="l"/>
<O2 defaultselect="false" description="If the length of sequence A is the multiple of n, do not perform the adding action. If the length of A isn’t the multiple of n, add members to A until its length is the multiple of n; the number of additions – which are members of sequence x – need to be added after the existing members can be calculated with the formula – m=n-A.len()%n. " optionchar="m"/>
</options>
<params>
<P1 desc="x (A single value or a sequence; with a sequence, add its members sequentially to sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (An integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F559>
<F560 desc="Parse a string into the corresponding data type" displaystr="" majortype="102" name="parse" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Remove quotes of the string before starting an escape sequence including the escape character and unicode. By default the string will not be escaped." optionchar="e"/>
<O2 defaultselect="false" description="Retrieve a substring with enough length starting from the left side and parse it, while ignoring the unparsable rest. Note that the string needs to begin with the numeric value." optionchar="n"/>
<O3 defaultselect="false" description="If a string starts with the squotation marks, parse it until the next quotation marks appears and leave the rest of the string alone, and return a string." optionchar="q"/>
</options>
<params>
<P1 desc="s (String)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F560>
<F561 desc="Loop through the records of a sequence to modify the specified field of a table sequence in order. " displaystr="" majortype="101" name="paste" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Loop through the records of sequence Ai to insert them to Fi field of table sequence T before the kth record." optionchar="i"/>
</options>
<params>
<P1 desc="Ai (A table sequence/record sequence/sequence, whose records/members will be values of Fi field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (The field to be modified; when it isn’t supplied, modify the ith field of T)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="k (The position the modification starts. The default is 0, in which case records or members will be appended at the end. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F561>
<F562 desc="Perform PCA (Principal Component Analysis) on matrix A and return data for dimensionality reduction; n is the number of principal components" displaystr="" majortype="102" name="pca" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="" optionchar="r"/>
</options>
<params>
<P1 desc="A(A matrix )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of principal components)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F562>
<F563 desc="Reduce dimensionality for another matrix having same number of columns" displaystr="" majortype="102" name="pca" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(The PCA fiiting object returned by pca(A,n))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F563>
<F564 desc="Get the first day or  the last days of the week/month/quarter/year  to which a date belongs" displaystr="" majortype="102" name="pdate" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="Take Sunday as the first day of a week and get the first day of the week to which dateExp belongs; this is the default option of pdate() function" optionchar="w"/>
<O2 defaultselect="false" description="Get the beginning day of the month to which dateExp belongs" optionchar="m"/>
<O3 defaultselect="false" description="Get the beginning day of the quarter to which dateExp belongs" optionchar="q"/>
<O4 defaultselect="false" description="Get the first day of the year to which dateExp  belongs" optionchar="y"/>
<O5 defaultselect="false" description="Work with @w option and take Monday as the first day of a week; note that it is number 1 that is used here" optionchar="1"/>
<O6 defaultselect="false" description="Work with another option to get the last day" optionchar="e"/>
</options>
<params>
<P1 desc="dateExp    (Expression whose result is a date or date time)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F564>
<F565 desc="Calculate Pearson’s correlation coefficient between two vectors" displaystr="" majortype="102" name="pearson" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable the calculation of r2, that is, pearson(norm@0(A),norm@0(B))" optionchar="r"/>
<O2 defaultselect="false" description="Equivalent to @a(…;k) that calculates the adjusted r2 with degrees of freedom being k" optionchar="a"/>
</options>
<params>
<P1 desc="A(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F565>
<F566 desc="Judge to which enum group an object belongs." displaystr="" majortype="101" name="penum" postfix="E." returntype="101">
<options>
<O1 defaultselect="false" description="Return the serial numbers of all the group satisfying the group conditions, and the default is to  return the serial number of the first group " optionchar="r"/>
<O2 defaultselect="false" description="If no sequence member is found, return the length of E plus 1. This option is mutual exclusive to @r." optionchar="n"/>
</options>
<params>
<P1 desc="y (y is allowed to be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F566>
<F567 desc="Generate a date/time sequence with same interval." displaystr="" majortype="101" name="periods" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="i is in years" optionchar="y"/>
<O2 defaultselect="false" description="i is in quarters" optionchar="q"/>
<O3 defaultselect="false" description="i is in months" optionchar="m"/>
<O4 defaultselect="false" description="i is in ten-days" optionchar="t"/>
<O5 defaultselect="false" description="i is in seconds" optionchar="s"/>
<O6 defaultselect="false" description="exclusive of end point" optionchar="x"/>
<O7 defaultselect="false" description="Not be adjusted. By default, the result will be adjusted to the original start point of the time unit and adjustment must be done in case of @t." optionchar="o"/>
</options>
<params>
<P1 desc="s (a date time variable)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (a date time variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="i  (an integer indicating the interval; its unit is day and its value is 1 by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F567>
<F568 desc="Return the number of permutations" displaystr="" majortype="102" name="permut" postfix="" returntype="101">
<options/>
<params>
<P1 desc="n   (An integer that is the number of the objects)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (An integer that is the number of each way of permutation)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F568>
<F569 desc="To find the serial number of a record by its primary key" displaystr="" majortype="101" name="pfind" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Enable the binary search which requires that A must be ordered by the key, otherwise the result will be wrong." optionchar="b"/>
<O2 defaultselect="false" description="Return the opposite number of an insertable position number when the eligible record cannot be found" optionchar="s"/>
<O3 defaultselect="false" description="Return 0 when there isn’t such a record corresponding to the key" optionchar="0"/>
</options>
<params>
<P1 desc="k  (Primary key; multiple field values from a composite primary key will be presented in sequence [k1,k2,…] or (k1,k2,…).)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F569>
<F570 desc="Compute the circumference ratio and its multiples" displaystr="" majortype="102" name="pi" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Multiples. If omitting this parameter, then return the circumference ratio)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F570>
<F571 desc="Perform row-to-column/column-to-row transposition for a table sequence/record sequence." displaystr="" majortype="101" name="pivot" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Transpose rows to columns  in table sequence/record sequence. In this case the default fields in Ni are the fields of A that are not included in g. " optionchar="r"/>
<O2 defaultselect="false" description="" optionchar="s"/>
</options>
<params>
<P1 desc="g (Grouping fields/expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="G(A field in the result set; default is g)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F (A to-be-transposed field in the specified sequence)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="V (A field in the specified sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="Ni (Values of F fieldand can be absent; by default it represents all unique field values  in F)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="Ni`(Names of new fields and default values are Ni )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P6>
</params>
</F571>
<F572 desc="Create association between multiple table sequences/record sequences through the join key" displaystr="" majortype="101" name="pjoin" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Work when data is ordered to enable MERGE " optionchar="o"/>
<O2 defaultselect="false" description="Enable full join while ignoring parameter z" optionchar="f"/>
</options>
<params>
<P1 desc="K(P’s join key)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(P’s expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F(Field name corresponding to expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="Ai(A table sequence/record sequence)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="z(Join type)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="Ki(Join key of Ai)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="xi(Expression of Ai)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P7>
<P8 desc="Fi(Field name corresponding to expression xi)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P8>
</params>
</F572>
<F573 desc="Attach the join-key-based association with another cursor or a record sequence to a cursor and return the original cursor." displaystr="" majortype="101" name="pjoin" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Enable full join while ignoring parameter z" optionchar="f"/>
<O2 defaultselect="false" description="Use this option to increase efficiency when associating composite table cursors" optionchar="r"/>
<O3 defaultselect="false" description="Use this option to make the time key the join key when both cs and csi are composite table-based cursors and csi has the time key; do not work with @f option" optionchar="t"/>
</options>
<params>
<P1 desc="K(cs’s join key)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(cs’s expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F(Field name corresponding to expression x)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="csi(A cursor/composite table cursor/record sequence)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="z(Join type)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="Ki(Join key of csc:/Ai:)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="xi(Expression of csc:/Ai:)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P7>
<P8 desc="Fi(Field name corresponding to expression xi)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P8>
</params>
</F573>
<F574 desc="Create association between a pseudo table and a cursor/record sequence through the join key" displaystr="" majortype="101" name="pjoin" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Enable full join while ignoring parameter z; do not work with @r" optionchar="f"/>
</options>
<params>
<P1 desc="K(Enable full join while ignoring parameter z; do not work with @r)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(T’s expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F(Field name corresponding to expression x)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="csi(A cursor/record sequence)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="z(Join type)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="Ki(Join key of csi)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="xi(Expression of csi)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P7>
<P8 desc="Fi(Field name corresponding to expression xi)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P8>
</params>
</F574>
<F575 desc="Compute the plotting string on the canvas G, with the chart element e to plot. Assign the chart element parameter ai with the value xi. If the corresponding coordinate axis is available for this parameter value, then this coordinate axis is Ai." displaystr="" majortype="101" name="plot" postfix="G." returntype="101">
<options/>
<params>
<P1 desc="e (Chart element, for example, MapAxis, NumericAxis, EnumAxis, DateAxis, BackGround, Column, Line, Dot, Polygon, Text, Legend and Sector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ai (Parameters of chart element, for example, the name, logicData, and physicalData parameters in the chart element of MapAxis. For the parameter introduction of each chart element, please refer to parameter chapter)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="xi (parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="Ai (Coordinate axis corresponding to the parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F575>
<F576 desc="Fit matrix A and matrix T and return the coefficient; n is the number of principal components" displaystr="" majortype="102" name="pls" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="T(A matrix)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n(Number of principal components)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F576>
<F577 desc="Fit together matrices using PLS technique and return the coefficient." displaystr="" majortype="102" name="pls" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(PLS fitting object returned by pls(A,T,n))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F577>
<F578 desc="Get the position of the maximum member of a sequence" displaystr="" majortype="101" name="pmax" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O2 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
</options>
<params>
<P1 desc="x   (A field name or an expression, in which &quot;~&quot; is used to reference the current record.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F578>
<F579 desc="Get the position of the minimum member of a sequence" displaystr="" majortype="101" name="pmin" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O2 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O3 defaultselect="false" description="Do not skip null members" optionchar="0"/>
</options>
<params>
<P1 desc="x (A field name or an expression, in which &quot;~&quot; is used to reference the current record.) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F579>
<F580 desc="Calculate the coefficient between two vectors in polynomial fitting. " displaystr="" majortype="101" name="polyfit" postfix="" returntype="101">
<options/>
<params>
<P1 desc="X(Vectors of same dimension)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(Vectors of same dimension)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n(A non-zero positive integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F580>
<F581 desc="Get the position of a member in a sequence" displaystr="" majortype="101" name="pos" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing are all applicable" optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="Members of A are in order. With the binary search, return the position of x if x is a member of A; otherwise, return a number opposite to the sequence number at which position the x can be inserted orderly." optionchar="s"/>
<O5 defaultselect="false" description="If x is a sequence, then treat it as an single value. In this case, A is a sequence composed of sequences" optionchar="p"/>
<O6 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a." optionchar="n"/>
</options>
<params>
<P1 desc="x (A member.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k(Search from the kth member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F581>
<F582 desc="Get the positions of sequence members in another sequence." displaystr="" majortype="101" name="pos" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Get  single ascending ISeq p to make A(p)==x" optionchar="i"/>
<O2 defaultselect="false" description="Get position of the continuous sub-sequence x of sequence A when it appears the first time" optionchar="c"/>
<O3 defaultselect="false" description=" A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing  are all applicable " optionchar="b"/>
</options>
<params>
<P1 desc="x  (a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F582>
<F583 desc="Search the position of a substring in a parent string, and return null if not found" displaystr="" majortype="102" name="pos" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform the search leftward starting from begin, while the search will be done rightward by default." optionchar="z"/>
<O2 defaultselect="false" description="Case-insensitive" optionchar="c"/>
<O3 defaultselect="false" description="Search for the subsring at the beginning of the parent string by ignoring parameter begin" optionchar="h"/>
<O4 defaultselect="false" description="Skip quoted strings when searching the parent string" optionchar="q"/>
</options>
<params>
<P1 desc="s1 (The parent string where you want to search for the substring.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s2 (Substring of interest.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="begin (The position from which the search starts; the default search is from the beginning.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F583>
<F584 desc="Compute the powers of a numeric value" displaystr="" majortype="102" name="power" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Base)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (Power; default is 2)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F584>
<F585 desc="Among the records, query fields referred by the foreign key recursively" displaystr="" majortype="101" name="prior" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="r1 (A record)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="n (A Number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F585>
<F586 desc="Call a storage procedure by a database connection" displaystr="" majortype="1" name="proc" postfix="db." returntype="101">
<options/>
<params>
<P1 desc="sql  (The execution statement for the storage procedure; for example, call test(?,?))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="param ( The value of an input argument,  If param:type:mode:variable appears repeatedly, then separate it with comma, like param:type:mode:variable,... )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="type (The data type of an argument)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="mode (&quot;i&quot; or &quot;o&quot;. &quot;i&quot; indicates an input argument and &quot;o&quot; indicates an output argument)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="variable (The output argument's name, which will be referenced in the current program cellset)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F586>
<F587 desc="Return the product of a set of numbers." displaystr="" majortype="102" name="product" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F587>
<F588 desc="Return the product of a set of numbers." displaystr="" majortype="102" name="product" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F588>
<F589 desc="Retrieve property value from the property file." displaystr="" majortype="2" name="property" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Read a property value and parse it as what it is; by default return the value as a string." optionchar="v"/>
</options>
<params>
<P1 desc="p  (Property name; the function returns a table sequence composed of all properties if it is omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F589>
<F590 desc="Read property values from node strings." displaystr="" majortype="101" name="property" postfix="xs." returntype="101">
<options>
<O1 defaultselect="false" description="Separate node strings by commas or semicolons; use spaces by default" optionchar="c"/>
<O2 defaultselect="false" description="Use colons to separate node string name and its value; use the equal sign by default" optionchar="j"/>
<O3 defaultselect="false" description="Enclose values by double quotation marks" optionchar="q"/>
<O4 defaultselect="false" description="Read the string and then parse it into value; return a sequence by default" optionchar="v"/>
</options>
<params>
<P1 desc="xs(Node strings, whose format is“name1=value1 name2=value2...”)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Node string name; return a table sequene made up fo all properties when it is absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="v(Null or a string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F590>
<F591 desc="Compute the proportion of each member of a sequence." displaystr="" majortype="101" name="proportion" postfix="A." returntype="101">
<options/>
<params/>
</F591>
<F592 desc="Return the sequence number of the interval in which the parameter falls" displaystr="" majortype="101" name="pseg" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use intervals that are left-open and right-closed" optionchar="r"/>
</options>
<params>
<P1 desc="x (An expression, which is a field name or a legal expression made up of field name and in which the sign ~ can be used to reference the current record; can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F592>
<F593 desc="Get the positions of the selected members from a sequence" displaystr="" majortype="101" name="pselect" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform the binary search when A is an ordered sequence by default. Note that in this case xi must be in ascending or descending order. If A is not an ordered sequence, this option could return incorrect result. When it is used with A.pselect(x1:y1,x2:y2,......xi:yi) to find out members that make cmp(x,y) return 0, simply write A.pselect@b(x1:y1,x2:y2,......xi:yi) without including cmp()." optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="The member in A is ordered for formula x. With the binary search, if none members in A can make the formula x generate a result of 0, then return a number opposite to the position at which the number meeting the conditions can be inserted." optionchar="s"/>
<O5 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a" optionchar="n"/>
<O6 defaultselect="false" description="Return 0 when the eligible member isn’t found; the parameter and @n option are mutually-exclusive" optionchar="0"/>
</options>
<params>
<P1 desc="x  (A boolean expression, whose value can be null. when using @b option, x should be an expression whose return value is an integer) " filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (Search from the kth member)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F593>
<F594 desc="Get the positions of the selected members from a sequence, the simplified syntax for multiple conditions using &quot;&amp;&amp;&quot; to do the union query, it is equal to A.pselect(x1==y1 &amp;&amp; x2==y2 &amp;&amp;...... xi==yi {,k})." displaystr="" majortype="101" name="pselect" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform the binary search when A is an ordered sequence by default. Note that in this case xi must be in ascending or descending order. If A is not an ordered sequence, this option could return incorrect result. When it is used with A.pselect(x1:y1,x2:y2,......xi:yi) to find out members that make cmp(x,y) return 0, simply write A.pselect@b(x1:y1,x2:y2,......xi:yi) without including cmp()." optionchar="b"/>
<O2 defaultselect="false" description="Return a sequence composed of serial numbers of all the members that fulfill the rules. So the  result is an n integer sequence " optionchar="a"/>
<O3 defaultselect="false" description="Perform the search backwards from the last member; by default perform the search from the first member." optionchar="z"/>
<O4 defaultselect="false" description="All members of A are in descending/ascending order for formula xk. With binary search, if no members meeting the conditions are found, then return a number opposite to the sequence number of position at which the number meeting the conditions can be inserted." optionchar="s"/>
<O5 defaultselect="false" description="If no sequence member is found, return the length of A plus 1. This option is mutual exclusive to @a" optionchar="n"/>
<O6 defaultselect="false" description="Return 0 when the eligible member isn’t found; the parameter and @n option are mutually-exclusive" optionchar="0"/>
</options>
<params>
<P1 desc="xi    (xi is an expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yi    (yi is a comparing value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F594>
<F595 desc="Generate a pseudo table definition object" displaystr="" majortype="102" name="pseudo" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enable to use pure-table-sequence based column-wise computation on a pseudo table generated from a composite table" optionchar="v"/>
</options>
<params>
<P1 desc="pd (A pseudo table definition record)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of subcursors in a multicursor; by default, get a single cursor)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F595>
<F596 desc="Segment a pseudo table according to the segmentation way of another." displaystr="" majortype="101" name="pseudo" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F596>
<F597 desc="Get the original positions of the sorted members of a sequence." displaystr="" majortype="101" name="psort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform parallel algorithm to enhance performance of handling data-intensive or computation-intensive tasks." optionchar="m"/>
<O2 defaultselect="false" description="Sort a sequence in descending order and return the position of a member in the original sequence" optionchar="z"/>
<O3 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="x (the sorting expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F597>
<F598 desc="Get the original positions of the sorted members of a sequence." displaystr="" majortype="101" name="psort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Perform parallel algorithm to enhance performance of handling data-intensive or computation-intensive tasks." optionchar="m"/>
<O2 defaultselect="false" description="Sort a sequence in descending order and return the position of a member in the original sequence" optionchar="z"/>
<O3 defaultselect="false" description="Put records with null values at the end" optionchar="0"/>
</options>
<params>
<P1 desc="xi (If there are multiple sorting expressions, they can be written as xi:di,.., a compound expression consisting of multiple expressions)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="di (Sorting order: &gt;0 represents ascending order, which is the default, and &lt;0 descending order)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F598>
<F599 desc="Compute the specified expression(s) over each member of a sequence, sort the result members, and return ordinal numbers of the first n members in the original sequence." displaystr="" majortype="101" name="ptop" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1." optionchar="1"/>
<O2 defaultselect="false" description="Do not ignore null members; ignore null members by default." optionchar="0"/>
<O3 defaultselect="false" description="Use standard competition ranking, where members having equal values are given equal rank and the next member is given the next highest rank" optionchar="r"/>
<O4 defaultselect="false" description="Use dense ranking, where members having equal values are given equal rank and the next members are given the immediately following ranking number" optionchar="i"/>
</options>
<params>
<P1 desc="n (Integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Sort expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F599>
<F600 desc="Push data in a channel into another channel." displaystr="" majortype="101" name="push" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="chi  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F600>
<F601 desc="Push data in a cursor into a channel." displaystr="" majortype="101" name="push" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="chi  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F601>
<F602 desc="Execute a SQL statement on a data source and return a table sequence composed of the query results.  " displaystr="" majortype="1" name="query" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Return only the first-found record satisfying the condition, which can be a single value if only one field is involved or a sequence if multiple fields are involved." optionchar="1"/>
<O2 defaultselect="false" description="Return a sequence if the result set has only one column." optionchar="i"/>
<O3 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type." optionchar="d"/>
<O4 defaultselect="false" description="Close the database connection automatically when the statement finishes execution. Only valid with the database connection established through the connect function." optionchar="x"/>
<O5 defaultselect="false" description="Return a pure sequence or a pure table sequence" optionchar="v"/>
</options>
<params>
<P1 desc="sql (A SQL statement, like select * from table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="args (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F602>
<F603 desc="Perform sql based on A and return a table sequence composed of query results. Here, args can be an expression evaluated based on each member of A. This type of syntax can work with @idx options." displaystr="" majortype="1" name="query" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Return only the first-found record satisfying the condition, which can be a single value if only one field is involved or a sequence if multiple fields are involved." optionchar="1"/>
<O2 defaultselect="false" description="Return a sequence if the result set has only one column." optionchar="i"/>
<O3 defaultselect="false" description="Convert the numeric data type to the double data type, instead of the decimal data type." optionchar="d"/>
<O4 defaultselect="false" description="Close the database connection automatically when the statement finishes execution. Only valid with the database connection established through the connect function. " optionchar="x"/>
<O5 defaultselect="false" description="Return a pure sequence or a pure table sequence" optionchar="v"/>
</options>
<params>
<P1 desc="A  (A sequence. sql is executed on each member of A. Generally args is computed against each member of A and the value is passed to sql for execution.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql  (A SQL statement, like select * from table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args  (An argument value passed into the specified SQL command sql. It can be a constant or an expression. The comma is used to separate multiple arguments.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F603>
<F604 desc="Execute DQL query statement." displaystr="" majortype="102" name="query" postfix="d." returntype="102">
<options/>
<params>
<P1 desc="dql(DQL query statement)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F604>
<F605 desc="Find a certain field of a specified row in a table sequence/memory table" displaystr="" majortype="101" name="r" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T(A table sequence/memory table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F(A field of T; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F605>
<F606 desc="Close R2DBC connection." displaystr="" majortype="102" name="r2dbc_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="r2dbc_open(R2DBC connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F606>
<F607 desc="Execute a SQL statement through R2DBC." displaystr="" majortype="102" name="r2dbc_exec" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(A SQL statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F607>
<F608 desc="Connect to R2DBC and return a cursor." displaystr="" majortype="102" name="r2dbc_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(The URL for accessing a database, whose format is r2dbc:dbtype://&lt;host&gt;:port/&lt;database&gt;)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F608>
<F609 desc="Query a database through R2DBC." displaystr="" majortype="102" name="r2dbc_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Databae connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql(The SQL statement to be queried, such as select * from table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F609>
<F610 desc="Get the integers from 0 to n-1." displaystr="" majortype="102" name="rand" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Set the seed value for generating random number." optionchar="s"/>
</options>
<params>
<P1 desc="n (Integer,by default, the result is a random float number between 0 and 1.0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F610>
<F611 desc="Get a random character string" displaystr="" majortype="102" name="rands" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Character string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="l (Integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F611>
<F612 desc="Get the beginning members of the specified segment and its next segment" displaystr="" majortype="101" name="range" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s (Starting data)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (Ending data)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k (The kth segment whose beginning member is to be returned)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="n (The number of segments data is divided)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F612>
<F613 desc="Divide a sequence into a specified number of equal segments according to its length and returns the kth segment." displaystr="" majortype="101" name="range" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="k(An integer, which is the ordinal number of a specified segment)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(An integer representing the total number of segments)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F613>
<F614 desc="Compute the ranking of a specified value in a sequence" displaystr="" majortype="101" name="rank" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order (in ascending order by default). Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A before getting y’s ranking. " optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="y (A member of sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F614>
<F615 desc="Get the ranking of a certain value among members of a sequence." displaystr="" majortype="101" name="rank" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order (in ascending order by default). Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A.(x) before getting y’s ranking." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="y (A member of sequence A or it is used to compare with values of sequence A.(x))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression computed according to sequence A)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F615>
<F616 desc="An interative loop for numbering records according to the values of certain fields." displaystr="" majortype="102" name="rank" postfix="" returntype="101">
<options/>
<params>
<P1 desc="F (Field name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F616>
<F617 desc="An interative loop for numbering records according to the values of certain fields." displaystr="" majortype="102" name="ranki" postfix="" returntype="101">
<options/>
<params>
<P1 desc="F (Field name; under same Gi field value, records with same F field value have same sequence number; add 1 to the sequence number if F field value changes)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Gi (Field name; in a loop function, number records under same Gi field value by the changes of F field value; renumber a record when Gi field value changes. )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F617>
<F618 desc="Get the rankings of members of sequence A.(x)" displaystr="" majortype="101" name="ranks" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order. Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A.(x) before getting the rankings." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params>
<P1 desc="x (An expression computed according to sequence A)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F618>
<F619 desc="Compute the ranking of each member in a sequence." displaystr="" majortype="101" name="ranks" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a ranking according to members sorted in descending order. Here “z” is in lowercase." optionchar="z"/>
<O2 defaultselect="false" description="Deduplicate sequence A before getting the rankings." optionchar="i"/>
<O3 defaultselect="false" description="Perform average operation for each of the duplicate ranking and return the result, which could contain non-integers. Take the sequence [3,2,6,6,9] for example, a default ranking is [2,1,3,3,5]; but with @s option, the ranking becomes [2.0,1.0,(3+4)/2,(3+4)/2,5.0] after we get averages for the two duplicates." optionchar="s"/>
</options>
<params/>
</F619>
<F620 desc="Read contents from a file object" displaystr="" majortype="2" name="read" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Return the contents of the file object f as a string sequence; each row is corresponding to a member." optionchar="n"/>
<O2 defaultselect="false" description="Interpret the returned string as the corresponding data type. The combined use of this option and @n is acceptable" optionchar="v"/>
<O3 defaultselect="false" description="Read the file once and return the total number of bytes in it; used for test" optionchar="0"/>
</options>
<params>
<P1 desc="b(A byte number beginning from 0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e(A byte number beginning from 0)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F620>
<F621 desc="Make the members of a sequence the new field values of records of a table sequence." displaystr="" majortype="101" name="record" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="insert new records before the specified position k" optionchar="i"/>
<O2 defaultselect="false" description="Return the newly-inserted or -modified records or record sequences" optionchar="n"/>
</options>
<params>
<P1 desc="A (a sequence whose members will be used as field values of T)" filtertype="1" identifieronly="true" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (an integer, which indicates the record position from which the records will be modified        If k==0 or k is omitted, then append new records to T )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F621>
<F622 desc="Modify field values of a record with members of a sequence." displaystr="" majortype="101" name="record" postfix="r." returntype="101">
<options/>
<params>
<P1 desc="A (A sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F622>
<F623 desc="Connect to a Redis database under the single machine model" displaystr="" majortype="102" name="redis" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort   (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F623>
<F624 desc="Close a Redis database connection" displaystr="" majortype="102" name="redis_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F624>
<F625 desc="Connect to Redis Cluster" displaystr="" majortype="102" name="redis_cluster" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="maxRedirections  (The maximum number of allowed redirections; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F625>
<F626 desc="Get the values of all the given keys" displaystr="" majortype="102" name="redis_get" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F626>
<F627 desc="Get a substring of the string stored at a key" displaystr="" majortype="102" name="redis_getrange" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="start  (The beginning of the substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="end  (The end of the substring)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F627>
<F628 desc="Get all the fields in a hash" displaystr="" majortype="102" name="redis_hkeys" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F628>
<F629 desc="Get the number of fields in a hash" displaystr="" majortype="102" name="redis_hlen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F629>
<F630 desc="Get the values of all the given hash fields" displaystr="" majortype="102" name="redis_hmget" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="field  (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F630>
<F631 desc="Get the values of all hash fields" displaystr="" majortype="102" name="redis_hvals" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl  (Hash table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F631>
<F632 desc="Find all keys matching the specified pattern" displaystr="" majortype="102" name="redis_keys" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pattern  (A matching string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F632>
<F633 desc="Get a member from a list by its index" displaystr="" majortype="102" name="redis_lindex" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="index  (Index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F633>
<F634 desc="Get the length of a list" displaystr="" majortype="102" name="redis_llen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F634>
<F635 desc="Get a range of members in a list with indexes within the given offset values start and stop." displaystr="" majortype="102" name="redis_lrange" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (List name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="start  (Starting index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="stop  (Ending index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F635>
<F636 desc="Connect to Redis database in buffer pool mode" displaystr="" majortype="102" name="redis_pool" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="database  (Database indexes, which within the range of 0~15; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="clientName  (Client name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F636>
<F637 desc="Get the the number of members in a set" displaystr="" majortype="102" name="redis_scard" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F637>
<F638 desc="Get members of the difference set of all the given sets" displaystr="" majortype="102" name="redis_sdiff" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F638>
<F639 desc="Change the selected database for the current connection; the database index is a number that starts from 0" displaystr="" majortype="102" name="redis_select" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="index  (Index number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F639>
<F640 desc="Connect to distributed Redis cluster" displaystr="" majortype="102" name="redis_sentinel" postfix="" returntype="102">
<options/>
<params>
<P1 desc="master  (Master node name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="password  (The Redis database’s authentication password.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F640>
<F641 desc="Connect to a Redis database in shared pool mode" displaystr="" majortype="102" name="redis_shared" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="pattern  (Key pattern by which the user-defined sharding algorithm is implemented; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F641>
<F642 desc="Connect to a Redis database in a mode of both buffer pool and shared pool" displaystr="" majortype="102" name="redis_sharedpool" postfix="" returntype="102">
<options/>
<params>
<P1 desc="hostAndPort  (The Redis database’s IP and port number, which is a string in the format of ip:port)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password  (The Redis database’s authentication password)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="connectionTimeout  (Timeout value when trying to connect to the database (in seconds); can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="soTimeout  (Timeout value when trying to read data(in seconds))" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="pattern  (Key pattern by which the user-defined sharding algorithm is implemented; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="poolConfig  (Connection property configuration, which is a string in the format of “key:value[,key1:value1,…]”; can be omitted)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F642>
<F643 desc="Get members of the intersection of all the given sets" displaystr="" majortype="102" name="redis_sinter" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F643>
<F644 desc="Determine if a given value is a member of a set" displaystr="" majortype="102" name="redis_sismember" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Set element)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F644>
<F645 desc="Get all members of a set" displaystr="" majortype="102" name="redis_smembers" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F645>
<F646 desc="Get one or multiple random members from a set" displaystr="" majortype="102" name="redis_srandmember" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="count  (The number of returned members; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F646>
<F647 desc="Get the length of the string value stored in the key" displaystr="" majortype="102" name="redis_strlen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F647>
<F648 desc="Get the members of the union of all the given sets" displaystr="" majortype="102" name="redis_sunion" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Set name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F648>
<F649 desc="Get the data type of the value stored in the key" displaystr="" majortype="102" name="redis_type" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Key name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F649>
<F650 desc="Get the number of members in a sorted set" displaystr="" majortype="102" name="redis_zcard" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F650>
<F651 desc="Count the number of members in a sorted set with scores between a given interval" displaystr="" majortype="102" name="redis_zcount" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="min  (The starting score)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="max  (The ending score)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F651>
<F652 desc="Return a range of members in a sorted set, by index" displaystr="" majortype="102" name="redis_zrange" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Arrange members in a descending order" optionchar="z"/>
</options>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="start  (Starting index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="stop  (Ending index)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="withscores  (Also return the scores; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F652>
<F653 desc="Return a range of members in sorted set, by score" displaystr="" majortype="102" name="redis_zrangebyscore" postfix="" returntype="102">
<options/>
<params>
<P1 desc=" con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="min  (The smallest score; can be –inf, meaning infinitely small)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="max  (The greatest score; can be +inf, meaning inifinitely large)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="offset  (Offset interval; can be omitted along with the parameter n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="n  (Offset value; can be omitted along with the parameter offset)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="withscores  (Also return the scores; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F653>
<F654 desc="Determine the index of a member in a sorted set" displaystr="" majortype="102" name="redis_zrank" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Arrange sorted set members in descending order" optionchar="z"/>
</options>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Sorted set member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F654>
<F655 desc="Get the score associated with the given member in a sorted set" displaystr="" majortype="102" name="redis_zscore" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con  (Database connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key  (Sorted set name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="member  (Sorted set member)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F655>
<F656 desc="If no extracting item is specified in rs which represents regular expressions, match field Fi of the string data type with rs. Then return the new RSeq after RSeq A is filtered. Use the current record to match with rs if omitting Fi" displaystr="" majortype="101" name="regex" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode to match" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expressions. The specified regular expressions will be separated from each other by separators and each will be surrounded with the parentheses. They will match the corresponding fields respectively. For example, &quot;(.*),(a.*)&quot; are two specified regular expressions separated by a comma. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Resulting field names of string type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F656>
<F657 desc="Split the string members of sequence A according to specified regular expressions in rs, the series of regular expressions, and return the results as a TSeq whose fields are Fi " displaystr="" majortype="101" name="regex" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode to match" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expressions. The specified regular expressions will be separated from each other by separators and each will be surrounded with the parentheses. They will match the corresponding fields respectively. For example, &quot;(.*),(a.*)&quot; are two specified regular expressions separated by a comma. )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Resulting field names of string type)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="..." filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F657>
<F658 desc="Match the character string with regular expression" displaystr="" majortype="101" name="regex" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode" optionchar="u"/>
<O3 defaultselect="false" description="Replace all matching characters" optionchar="a"/>
<O4 defaultselect="false" description="Find whether the regular expression matches with the whole string" optionchar="w"/>
</options>
<params>
<P1 desc="rs (Regular expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="rpls(A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F658>
<F659 desc="Attach the action of matching the regular expression to a cursor and return the original cursor." displaystr="" majortype="101" name="regex" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Case is insensitive" optionchar="c"/>
<O2 defaultselect="false" description="Use Unicode" optionchar="u"/>
</options>
<params>
<P1 desc="rs (Regular expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Result field name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F659>
<F660 desc="Register a .dfx/.splx file as a function to be called." displaystr="" majortype="102" name="register" postfix="" returntype="101">
<options/>
<params>
<P1 desc="f(Function name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="spl(.dfx/splx file path, which can be an absolute path or a relative path; a relative path is relative to the main directory)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F660>
<F661 desc="Calculate remainder for degree to radian conversion" displaystr="" majortype="102" name="remainder" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x(An integer or a real number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(An integer or a real number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F661>
<F662 desc="Rename the fields in a table sequence/(multi-zone) entity table" displaystr="" majortype="101" name="rename" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="F (Field name; ignore the parameter if the field name does not exist in T)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F662>
<F663 desc="Rename a field of a cursor" displaystr="" majortype="101" name="rename" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="F(Field name/index name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="F1 (New name of the field; If omitted, delete the original names and name the fields _1,2...)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F663>
<F664 desc="Change the substring of a source string" displaystr="" majortype="102" name="replace" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Quoted characters need not to be replaced" optionchar="q"/>
<O2 defaultselect="false" description="Enble to replace the first-found specified substring only" optionchar="1"/>
<O3 defaultselect="false" description="Case-insensitive" optionchar="c"/>
<O4 defaultselect="false" description="Split content of a and b respectively into a sequence and perform the replacement correspondingly" optionchar="s"/>
</options>
<params>
<P1 desc="src (Source string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="a (A substring of the source string, or a sequence of substrings)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (The string or a sequence of strings with which the specified substring will be replaced)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F664>
<F665 desc="Read information from the report configuration file. " displaystr="" majortype="101" name="report_config" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filePath(A file path, which is either an absolute path or a relative path, or a class path; for a relative path, its base directory is the application root directory； esProc default is the root  directory )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="funfile(The path of the configuration file of a user-defined function, which is either an absolute path or a relative path, or a class path; for a relative path, its base directory is the same as explained above)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F665>
<F666 desc="Export a report  file. " displaystr="" majortype="101" name="report_export" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Export as a pdf file, paginated by default" optionchar="p"/>
<O2 defaultselect="false" description="Export as a docx file" optionchar="d"/>
<O3 defaultselect="false" description="Export as an xlsx file, paginated by default" optionchar="x"/>
<O4 defaultselect="false" description="Export as an html file" optionchar="h"/>
<O5 defaultselect="false" description="Export as a non-paginated file; need to work with @p or @x" optionchar="n"/>
<O6 defaultselect="false" description="Export as an xlsx file; need to work with @x" optionchar="s"/>
<O7 defaultselect="false" description="Export as an mht file; need to work with @h" optionchar="m"/>
<O8 defaultselect="false" description="Export as an Excel file with formulas; need to work with @x or @xs" optionchar="f"/>
</options>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filePath (The URL through which a report is exported, which can be an absolute path or a relative path; when it is the relative path, the base directory is the path specified in the &lt;home&gt; node in the configuration file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F666>
<F667 desc="Read a report file. " displaystr="" majortype="101" name="report_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filePath(.The URL through which a report is exported, which can be an absolute path or a relative path; when it is the relative path, the base directory is the path specified in the &lt;home&gt; node in the configuration file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F667>
<F668 desc="Compute a report file." displaystr="" majortype="101" name="report_run" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rpt(A report object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="paramValue(Report parameter value; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="paramName(Parameter name; by default, write values in the order of parameters in the report.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="ds(A table sequence object; can be absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="dsName(Dataset name; by default, correspond table sequence objects and the original data sets in the report file one by one; the colon dsName before should not be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F668>
<F669 desc="Read information from the ReportLite configuration file" displaystr="" majortype="102" name="reportlite_config" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filePath (A file path, which is an absolute path or a relative path, or a class path; for a relative path, its base directory is the application root directory; esProc default is the root directory)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F669>
<F670 desc="Export a ReportLite file." displaystr="" majortype="102" name="reportlite_export" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Export as a pdf file, paginated by default" optionchar="p"/>
<O2 defaultselect="false" description="Export as a docx file" optionchar="d"/>
<O3 defaultselect="false" description="Export as an xlsx file, paginated by default" optionchar="x"/>
<O4 defaultselect="false" description="Export as an html file" optionchar="h"/>
<O5 defaultselect="false" description="Export as a non-paginated file; need to work with @p or @x" optionchar="n"/>
<O6 defaultselect="false" description="Export as an xls file; need to work with @x" optionchar="s"/>
<O7 defaultselect="false" description="Export as an mht file; need to work with @h" optionchar="m"/>
<O8 defaultselect="false" description="Export as an Excel file with formulas; need to work with @x or @xs" optionchar="f"/>
</options>
<params>
<P1 desc="rpt (ReportObject object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="filePath (The URL through which a report is exported, which can be an absolute path or a relative path; when it is the relative path, the base directory is the path specified in the &lt;home&gt; node in the configuration file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F670>
<F671 desc="Read a ReportLite file" displaystr="" majortype="102" name="reportlite_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="filePath (The URL through which a report is exported, which can be an absolute path or a relative path; when it is the relative path, the base directory is the path specified in the &lt;home&gt; node in the configuration file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F671>
<F672 desc="Compute a ReportLite file" displaystr="reportlite_run(rpt, paramValue: paramName,....; ds: dsName,....)" majortype="102" name="reportlite_run" postfix="" returntype="101">
<options/>
<params>
<P1 desc="rpt (ReportObject object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="paramValue (Parameter value; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="paramName (Parameter name; by default, write values in the order of parameters in the report)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="ds (A table sequence object; can be absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="dsName (Dataset name; by default, correspond table sequence objects and the original data sets in the report file one by one; the colon dsName before should not be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
</params>
</F672>
<F673 desc="Reset a cursor by moving it back to the beginning" displaystr="" majortype="102" name="reset" postfix="cs." returntype="102">
<options/>
<params/>
</F673>
<F674 desc="Rearrange a composite table file or a homo-name files group to a new one." displaystr="" majortype="2" name="reset" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Write the file as an uncompressed one; perform the write as usual if the parameter is omitted" optionchar="u"/>
<O2 defaultselect="false" description="Write the file as a compressed one; won’t perform compression if the option is absent" optionchar="z"/>
<O3 defaultselect="false" description="Write the file by row; perform the write as usual if the parameter is omitted" optionchar="r"/>
<O4 defaultselect="false" description="Write the file by column" optionchar="c"/>
<O5 defaultselect="false" description="Used on multizone composite tables for performing update merge; ignore the record in the zone table with the smaller number when same key values appear in two zone tables; Refer to the deletion mark at the same time and won’t write records marked by the deletion mark to the new composite table file; when key value of the record having a deletion mark is unique in its zone table, just retain it " optionchar="w"/>
<O6 defaultselect="false" description="When parameter f is a homo-name files group and parameter f’ is a composite table file, use this option to perform a simple concatenation instead of a merge while ignoring parameters x and cs" optionchar="q"/>
<O7 defaultselect="false" description="Force to overwrite the file when the target already exists; by default error will be reported and the file rearrangement fails if the target file exist." optionchar="y"/>
</options>
<params>
<P1 desc="f’(A composite table file or a homo-name files group)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b(Block size, whose unit is byte; by default, it uses value of “Composite table block size” set in the configuration options; when esProc is integrated into a third-party application, the parameter’s value is by default is blockSize value configure in raqsoftConfig.xml file)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(Zone table expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="cs(A cursor/table sequence)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F674>
<F675 desc="Clear the members of a table sequence" displaystr="" majortype="101" name="reset" postfix="T." returntype="101">
<options/>
<params/>
</F675>
<F676 desc="Get result of an operation performed in a channel." displaystr="" majortype="101" name="result" postfix="ch." returntype="101">
<options/>
<params/>
</F676>
<F677 desc="Convert the red, green, blue, and transparency value to the corresponding color value" displaystr="" majortype="102" name="rgb" postfix="" returntype="101">
<options/>
<params>
<P1 desc="redIntExp      (The integer expression to indicate the red, of which the value is between 0-255)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="greenIntExp (The integer expression to indicate the green, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="blueIntExp    (The integer expression to indicate the blue, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="alphaIntExp  (The integer expression to indicate the transparency, of which the value is between 0-255 )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F677>
<F678 desc="Build models and perform predictions using the ridge regression method." displaystr="" majortype="102" name="ridge" postfix="" returntype="102">
<options/>
<params>
<P1 desc="X(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A vector having the same number of rows as matrix X)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="learning_rate(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="iterations(Learning rate that is a decimal between 0 and 1; default value is 0.01)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F678>
<F679 desc="Get the substring from the right of a string" displaystr="" majortype="102" name="right" postfix="" returntype="101">
<options/>
<params>
<P1 desc="s(The source string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(The nth-to-last character of source string s; return an empty string when the absolute value of n is greater than the length of s)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F679>
<F680 desc="Delete missing values from a vector." displaystr="" majortype="101" name="rmmiss" postfix="A." returntype="101">
<options/>
<params/>
</F680>
<F681 desc="Delete rows or columns containing missing values from a matrix." displaystr="" majortype="101" name="rmmissdim" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="dim (Specifies a dimension)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="minnum (The minimum number of missing items)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F681>
<F682 desc="Roll back a database transaction." displaystr="" majortype="1" name="rollback" postfix="db." returntype="102">
<options/>
<params>
<P1 desc="spn (Savepoint name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F682>
<F683 desc="Restore a composite table file to the previous state when update error happens" displaystr="" majortype="101" name="rollback" postfix="f." returntype="101">
<options/>
<params/>
</F683>
<F684 desc="Truncate the data at the specified position, and round off the remaining part" displaystr="" majortype="102" name="round" postfix="" returntype="101">
<options/>
<params>
<P1 desc="numberExp (Data to be intercepted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nExp (Integer to specify the position at which to intercept ,＞0: Move the decimal point to the right for nExp places,＜0: Move the decimal point to the left for nExp places,=0: Indicate the current decimal places)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F684>
<F685 desc="Find the record where the key value(s) is/are the specified one(s)." displaystr="" majortype="101" name="row" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T (A record sequence/a table sequence/a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F685>
<F686 desc="Find records from a memory table according to the specified primary key value(s)." displaystr="" majortype="101" name="row" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="T (A memory table)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F686>
<F687 desc="Compute an expression against a record and return the modified record.  The function computes the expression x against record r and return the modified record. Usually it is used to change the field values of r, for example, when x is col1=col2+1, it will change the field value of col1." displaystr="" majortype="101" name="run" postfix="r." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set" optionchar="m"/>
<O2 defaultselect="false" description="Perform the inverse operation; only apply to non-pure sequences" optionchar="z"/>
</options>
<params>
<P1 desc="xi (An expression, which is generally a field name or a legal expression composed of field names, and in which &quot;~&quot; references the current record.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F687>
<F688 desc="Compute expressions against each member of a sequence. Set the field value of Fi to xi." displaystr="" majortype="101" name="run" postfix="P." returntype="101">
<options/>
<params>
<P1 desc="xi    (The new value of Fi field )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi    (A field of A)" filtertype="1" identifieronly="true" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F688>
<F689 desc="Compute one or more expressions against each member in a sequence/record sequence and return a sequence composed of values of the expression." displaystr="" majortype="101" name="run" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set." optionchar="m"/>
</options>
<params>
<P1 desc="x (An expression, which is generally a field name or a legal expression that is composed of field names, and in which &quot;~&quot; is used to reference the current record. ) " filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F689>
<F690 desc="Compute an expression against each of the records in a channel and return the channel with new field values." displaystr="" majortype="101" name="run" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (New values of Fi field)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi  (Field name in the given channel)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F690>
<F691 desc="Attach the action of computing expression on each record to a cursor and return the original cursor." displaystr="" majortype="101" name="run" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="xi (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (A field of cs)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F691>
<F692 desc="Generate a new sequence by reversing the members in a sequence" displaystr="" majortype="101" name="rvs" postfix="A." returntype="101">
<options/>
<params/>
</F692>
<F693 desc="Manage AWS S3 storage buckets." displaystr="" majortype="102" name="s3_bucket" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Create a storage bucket; won’t create it if a namesake bucket already exists." optionchar="c"/>
<O2 defaultselect="false" description="Delete storage bucket; cannot delete it if the bucket isn’t empty." optionchar="d"/>
</options>
<params>
<P1 desc="fd(S3 connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="bucket(Bucket name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="pool(The storage pool a bucket belongs to (with Cloud macro storage); not configured for other cloud storage services)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F693>
<F694 desc="Close connection to AWS S3." displaystr="" majortype="102" name="s3_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd(S3 connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F694>
<F695 desc="Copy a file in the storage bucket  object to local, or a local file to a bucket." displaystr="" majortype="102" name="s3_copy" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Copy a local file into AWS S3 bucket; when the local path is a relative one, it is relative to the main directory" optionchar="u"/>
</options>
<params>
<P1 desc="fd(S3 connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="bucket(Bucket name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="key(Name of a file in the storage bucket)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="localFile(Local file name, which is located in the main directory if the name is omitted; its path is [main directory]/ storeType/bucket/object)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F695>
<F696 desc="Get the specified object from a bucket." displaystr="" majortype="102" name="s3_file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(S3 connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="bucket(Bucket name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="key(Name of a file in the storage bucket)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="cs(Character set used to save or open an object)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F696>
<F697 desc="List file in the storage bucket or the specified bucket." displaystr="" majortype="102" name="s3_list" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(S3 connection object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="bucket(Bucket name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F697>
<F698 desc="Connect to AWS S3." displaystr="" majortype="102" name="s3_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="accessKey(Amazon Access Key ID)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="secretKey(Secret Access Key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="region(Name of the Region where a bucket is located)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="endpoint(The specified endpoint used to search for the bucket to be accessed, whose format is https://s3.xxx.amazonaws.com )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F698>
<F699 desc="Connect to an SAP server" displaystr="" majortype="102" name="sap_client" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="filename (Connection configuration file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F699>
<F700 desc="Connect to an SAP server" displaystr="" majortype="102" name="sap_client" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="filename (Connection configuration file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="charset (Character set of the connection configuration file)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F700>
<F701 desc="Connect to an SAP server" displaystr="" majortype="102" name="sap_client" postfix="" returntype="101">
<options>
<O1 defaultselect="true" description="" optionchar="f"/>
</options>
<params>
<P1 desc="FileObject (Connection configuration file object handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F701>
<F702 desc="Connect to an SAP server" displaystr="" majortype="102" name="sap_client" postfix="" returntype="101">
<options/>
<params>
<P1 desc="user (SAP user name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="passwd (SAP password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="hostname" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="sysnc (SAP server’s IP)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="client (System number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="lang (Language)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F702>
<F703 desc="Exit an SAP server connection" displaystr="" majortype="102" name="sap_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="client (SAP connection file handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F703>
<F704 desc="Return the list of table-valued result set as a cursor" displaystr="" majortype="102" name="sap_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (SAP server connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="functionName The to-be-called function)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F704>
<F705 desc="Get a function object according to the import parameter(s)" displaystr="" majortype="102" name="sap_execute" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (SAP server connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="functionName (The to-be-called function)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="paramName (Function parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="paramValue (Function parameter value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F705>
<F706 desc="Get data records according to the import parameter(s)" displaystr="" majortype="102" name="sap_getparam" postfix="" returntype="101">
<options/>
<params>
<P1 desc="excutefunction (The execute function handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="paramName (Function parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F706>
<F707 desc="Return a list according to the import table-valued parameter" displaystr="" majortype="102" name="sap_table " postfix="" returntype="101">
<options/>
<params>
<P1 desc="excutefunction (The execute function handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tableName (Table name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F707>
<F708 desc="Set the savepoint to which you can later rollback" displaystr="" majortype="102" name="savepoint" postfix="db." returntype="101">
<options/>
<params>
<P1 desc="spn (Savepoint name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F708>
<F709 desc="Get an integer consisting of certain bytes of a serial byte key" displaystr="" majortype="101" name="sbs" postfix="k." returntype="101">
<options/>
<params>
<P1 desc="a (The ath byte of serial byte k; begin from the first byte when this parameter is absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The bth byte of serial byte k; stop at he last byte when this parameter is absent, and get the ath byte only when :b is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F709>
<F710 desc="The function gets multiple substrings from string s to form a new string" displaystr="" majortype="101" name="sbs" postfix="s." returntype="101">
<options/>
<params>
<P1 desc="a (The start position for getting the future substrings; default is 1)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The end position for getting the future substrings, whose defaut is s.len(); let b=a when :b is absent)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F710>
<F711 desc="Calculate the standard error of a numeric sequence" displaystr="" majortype="102" name="se" postfix="A." returntype="102">
<options/>
<params/>
</F711>
<F712 desc="Get the second from a time" displaystr="" majortype="102" name="second" postfix="" returntype="101">
<options/>
<params>
<P1 desc="datetimeExp    (Expression whose result is a time or date time)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F712>
<F713 desc="Return the member in a sequence corresponding to a certain interval number" displaystr="" majortype="101" name="segp" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Use left-open and right-closed intervals" optionchar="r"/>
</options>
<params>
<P1 desc="x(A field expression or a legal expression made up of field names, in which “~” can be used to reference the current record and which can be absent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y(An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F713>
<F714 desc="Return members of a sequence which satisfy a condition." displaystr="" majortype="101" name="select" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="return the first member that fulfills the conditions." optionchar="1"/>
<O2 defaultselect="false" description="search the members from back to front" optionchar="z"/>
<O3 defaultselect="false" description="Use binary search, which requires that A is an ascendingly ordered sequence and that parameters are separated by colon or they are expressions returning numeric values; the eligible members are found when result of expressions are 0" optionchar="b"/>
<O4 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; it can’t be used with @1bz options." optionchar="m"/>
<O5 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
<O6 defaultselect="false" description="Enable getting the first ineligible member from left to right beginning from the first member" optionchar="c"/>
<O7 defaultselect="false" description="Enable searching for the first eligible members from left to right and getting all members after it (inclusive)" optionchar="r"/>
<O8 defaultselect="false" description="Return result as a pure table sequence when sequence A is a pure table sequence; return a pure sequence when this option is absent" optionchar="v"/>
</options>
<params>
<P1 desc="x (an Boolean expression, which may be null. when using option @b, x should be an expression  whose return value is a number )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F714>
<F715 desc="Pick out members from a sequence which satisfied a condition. The simplified syntax used for the combining query with multiple conditions using &quot;&amp;&amp;&quot;, which is equal to A.select(x1== y1 &amp;&amp; x2== y2 &amp;&amp;...... xi==yi). While using option @b in case of multiple conditions, cmp() is not needed in this syntax and A.select@b(x1:y1, x2:y2, ......xi:yi) is enough" displaystr="" majortype="101" name="select" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="return the first member that fulfills the conditions. " optionchar="1"/>
<O2 defaultselect="false" description="search the members from back to front" optionchar="z"/>
<O3 defaultselect="false" description="A is a sorted sequence by default, so dichotomizing search will be used. Increasing and decreasing  are all applicable. Note: If A is not a sorted sequence, then option @b should not be used, or it may  bring about the incorrect result. When option @b is used in A.select(x1:y1, x2:y2, ......xi:yi), that  is to find out the members whose &quot;Return value&quot; are 0 in cmp(x,y), cmp() is not needed in this  syntax, A.select@b(x1:y1, x2:y2, ......xi:yi) is enough. " optionchar="b"/>
<O4 defaultselect="false" description="Use parallel algorithm to handle data-intensive or computation-intensive tasks; no definite order for the records in the result set; it can’t be used with @1bz options." optionchar="m"/>
<O5 defaultselect="false" description="Return an empty table sequence with data structure if the grouping and aggregate operation over the sequence returns null" optionchar="t"/>
</options>
<params>
<P1 desc="xi   (an expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="yi   (a comparing value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F715>
<F716 desc="Return members of a table sequence which satisfy a condition" displaystr="" majortype="101" name="select" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Reuse T’s index, which may disrupt the order of the result set" optionchar="i"/>
</options>
<params>
<P1 desc="x(Filtering expression; can be null)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F716>
<F717 desc="Return a channel with records that meet the given condition." displaystr="" majortype="101" name="select" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x  (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F717>
<F718 desc="Send records in a channel that can’t meet the given condition into another channel." displaystr="" majortype="101" name="select" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="x  (A boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ch1  (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F718>
<F719 desc="Attach the record filtering action to a cursor and return the original cursor." displaystr="" majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x  (A boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F719>
<F720 desc="Send records in a cursor that can’t meet the given condition into a channel." displaystr="" majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (A boolean value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ch1 (Channel)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F720>
<F721 desc="Attach the record filtering action to a cursor and return the original cursor while writing records that not satisfy the specified expression to a bin file." displaystr="" majortype="101" name="select" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="x (Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f (BIN file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F721>
<F722 desc="Select records from a pseudo table according to a specified condition." displaystr="" majortype="101" name="select" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="x (A Boolean expression that is a filter condition, which can be null)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F722>
<F723 desc="Write pseudo table records that cannot meet the specified condition into a fin file." displaystr="" majortype="101" name="select" postfix="T." returntype="101">
<options/>
<params>
<P1 desc="x(A Boolean expression)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="f(A bin file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F723>
<F724 desc="An interative loop for numbering records in which a certain field contains same values." displaystr="" majortype="102" name="seq" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers Return value: " optionchar="n"/>
</options>
<params>
<P1 desc="Gi (Field name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F724>
<F725 desc="Remove outliers from a sequence type numeric variable during modeling" displaystr="" majortype="101" name="sert" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Outliers are removed from the original data after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(A sequence of removing process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F725>
<F726 desc="Remove outliers from a table sequence/record sequence numeric variable during modeling" displaystr="" majortype="101" name="sert" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Outliers are removed from the original data after execution" optionchar="c"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of removing process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F726>
<F727 desc="Map enumerated values as integers" displaystr="" majortype="101" name="setenum" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Change original data into mapping result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(A sequence of mapping process records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F727>
<F728 desc="Map enumerated variable values as integers" displaystr="" majortype="101" name="setenum" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Change original data into mapping result after execution" optionchar="c"/>
</options>
<params>
<P1 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of mapping process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F728>
<F729 desc="Close Salesforce cloud server connected through the way of rest api." displaystr="" majortype="102" name="sf_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd(restclient object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F729>
<F730 desc="Connect to Salesforce cloud server through the way of rest api." displaystr="" majortype="102" name="sf_open" postfix="" returntype="102">
<options/>
<params>
<P1 desc="jsonFile(The JSON file name; by default call user.json in the directory containing SalesforcCli external library)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F730>
<F731 desc="Query data and return result." displaystr="" majortype="102" name="sf_query" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(The service domain path preceded by /services)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="params(The parameter corresponding to url)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F731>
<F732 desc="Close the cloud server Salesforce server connected through soap api." displaystr="" majortype="102" name="sf_wsdlclose" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fd(restclient object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F732>
<F733 desc="Connect to Salesforce server cloud service through soap api." displaystr="" majortype="102" name="sf_wsdlopen" postfix="" returntype="102">
<options/>
<params>
<P1 desc="username(User name)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="password(Password)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F733>
<F734 desc="Query data and return query result." displaystr="" majortype="102" name="sf_wsdlquery" postfix="" returntype="102">
<options/>
<params>
<P1 desc="sql(A SQL statement; does not support select * from table. Users can refer to the value returned by sf_wsdlview() to write corresponding fields)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F734>
<F735 desc="Query data in an Sobject object and return a table sequence made up of field names and field types." displaystr="" majortype="102" name="sf_wsdlview" postfix="" returntype="102">
<options/>
<params>
<P1 desc="sobject(The Soobject data object to be queried)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F735>
<F736 desc="Perform SG smoothing on each row of a vector or a matrix." displaystr="" majortype="102" name="sg" postfix="" returntype="102">
<options/>
<params>
<P1 desc="A(A vector or a matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Degree of a polynomial that satisfies n&lt;m-1)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="m(A set of data points, which is an odd number greater than 1 and will automatically plus 1 if it isn’t an odd number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="d(The nth order derivative, which satisfies d&lt;n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F736>
<F737 desc="Perform a shift operation." displaystr="" majortype="102" name="shift" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="When shifting right, shift a sign into the leftmost position and shif a zero to this position by default" optionchar="s"/>
</options>
<params>
<P1 desc="x (The expression based on which you perform the shift operation)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (An integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F737>
<F738 desc="Get a shuffled sequence." displaystr="" majortype="101" name="shift" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="i (The starting position, which is a positive integer; 1 is the default value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (The offset value, which is a positive integer; 1 is the default value)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F738>
<F739 desc="Judge whether the parameter is a positive number, a negative number or 0." displaystr="" majortype="102" name="sign" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Data for which you want to judge whether it is positive or negative)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F739>
<F740 desc="Compute the sine value." displaystr="" majortype="102" name="sin" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Radians for which you want to compute the sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F740>
<F741 desc="Return the hyperbolic sine" displaystr="" majortype="102" name="sinh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (The real number for which you want to find the hyperbolic sine)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F741>
<F742 desc="Get the length of a file." displaystr="" majortype="2" name="size" postfix="f." returntype="101">
<options/>
<params/>
</F742>
<F743 desc="Calculate the skewness of a sequence of numeric data" displaystr="" majortype="101" name="skew" postfix="A." returntype="101">
<options/>
<params/>
</F743>
<F744 desc="To skip records while fetching records from a database cursor" displaystr="" majortype="101" name="skip" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (Grouping expression, by which cs is sorted. With x, n will be ignored.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F744>
<F745 desc="Make esProc program sleep." displaystr="" majortype="102" name="sleep" postfix="" returntype="102">
<options/>
<params>
<P1 desc="n (Millisecond)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F745>
<F746 desc="Perform smoothing on a sequence type variable during modeling" displaystr="" majortype="101" name="smooth" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the smoothing result after execution" optionchar="c"/>
<O2 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(A sequence of target variable values)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(A sequence of smoothing process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F746>
<F747 desc="Perform smoothing on a table sequence/record sequence variable of a table sequence/ record sequence during modeling" displaystr="" majortype="101" name="smooth" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the smoothing result after execution" optionchar="c"/>
<O2 defaultselect="false" description="Each option specifies a target type, and options are mutual-exclusive; automatically judge the type when no option is used; the order of priorities of the options is binary, numeric, integer and enumerated" optionchar="bnie"/>
</options>
<params>
<P1 desc="T(A sequence of target variable values)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cn(A string/number, which is the name of column (or the column number starting from 1) – the to-be-pre-processed variable – in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Rec(A sequence of smoothing process records)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F747>
<F748 desc="Generate a new sequence by sorting the members of a sequence" displaystr="" majortype="101" name="sort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Create multi-level sorting based on specified fields and according to the original order in which records first appear. " optionchar="u"/>
<O2 defaultselect="false" description="Use parallel algorithm to enhance performance to handle data-intensive and computation-intensive tasks." optionchar="m"/>
<O3 defaultselect="false" description="Sorting in descending order" optionchar="z"/>
<O4 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers" optionchar="n"/>
<O5 defaultselect="false" description="Put a null-value member or ecords with null values at the end" optionchar="0"/>
<O6 defaultselect="false" description="Return result as a pure table sequence when sequence A is a pure table sequence; return a pure sequence by default" optionchar="v"/>
</options>
<params>
<P1 desc="x (an expression, according to which the members of sequence A will be sorted ascendingly)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="loc (Language name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F748>
<F749 desc="Generate a new sequence by sorting the members of a sequence" displaystr="" majortype="101" name="sort" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Create multi-level sorting based on specified fields and according to the original order in which records first appear. " optionchar="u"/>
<O2 defaultselect="false" description="Use parallel algorithm to enhance performance to handle data-intensive and computation-intensive tasks." optionchar="m"/>
<O3 defaultselect="false" description="Sorting in descending order" optionchar="z"/>
<O4 defaultselect="false" description="The option can increase the numbering efficiency, but can only be used when the specified expression returns a positive integer; support using sequence numbers" optionchar="n"/>
<O5 defaultselect="false" description="Put a null-value member or ecords with null values at the end" optionchar="0"/>
<O6 defaultselect="false" description="Return result as a pure table sequence when sequence A is a pure table sequence; return a pure sequence by default" optionchar="v"/>
</options>
<params>
<P1 desc="xi (An expression, which is a member of sequence A and which will be sorted in ascending order. If there are multiple expressions, they can be written as a compound expression in the form of xi:di,.., according to which the sorting will be performed)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="di (Sorting order: &gt;0 represents ascending order, which is the default, and &lt;0 descending order)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F749>
<F750 desc="Sort records in a channel." displaystr="" majortype="101" name="sortx" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="xi  (An expression, according to which the records in a given channel is sorted in acending order)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F750>
<F751 desc="Sort data of a cursor." displaystr="" majortype="101" name="sortx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Put records with null values at the end; @0 and @n can’t work together." optionchar="0"/>
<O2 defaultselect="false" description="It can only be used to make the calculation faster when the value of expression x is a positive integer over which group of records can be directly numbered. @0 and @n can’t work together." optionchar="n"/>
<O3 defaultselect="false" description="Treat parameter n as the segmentation expression by which records are first segmented and then grouped and sorted" optionchar="g"/>
</options>
<params>
<P1 desc="x (An expression to sort members of cursor cs in ascending order )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value will be n times of the default if it is less than 1; by default esProc will uto-compute the value  )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F751>
<F752 desc="Sort a cluster cursor." displaystr="" majortype="101" name="sortx" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Won’t merge result sets returned by the nodes but return a cluster cursor segmented in the same way " optionchar="c"/>
</options>
<params>
<P1 desc="x(An expression to sort members of cursor cs in ascending order )" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n(Number of buffer rows; if the number of groups reaches n, write the grouping result to a temporary file; its value will be n times of the default if it is less than 1; by default esProc will uto-compute the value )" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F752>
<F753 desc="Sort a bin file or a sequence of bin files and generate a new bin file" displaystr="" majortype="102" name="sortx" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Sort in descending order; default is ascending" optionchar="z"/>
</options>
<params>
<P1 desc="Fi(Name(s) of f field(s) by which the file is sorted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="fn(Bin file object(s); generate a temporary file and return its cursor when this parameter is absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F753>
<F754 desc="Close a Spark database connection." displaystr="" majortype="102" name="spark_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="con(Spark database connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F754>
<F755 desc="Query a Spark database, and return the result as a cursor." displaystr="" majortype="102" name="spark_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F755>
<F756 desc="Create a Spark database connection." displaystr="" majortype="102" name="spark_open" postfix="" returntype="1">
<options/>
<params>
<P1 desc="hdfsUrl (HDFS file connection information; the format is hdfs://ip:port, which represents the HDFS file’s IP and port number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="thriftUrl (Thrift file connection information; the format is thrift://ip:port, which represents the Thrift file’s IP and port number)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="dbname (A database name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F756>
<F757 desc="Query a Spark database, and return the result as a sequence." displaystr="" majortype="102" name="spark_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="con (Database connection string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sql (A SQL query statement, like select * from table.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F757>
<F758 desc="Read a file stored in Spark database." displaystr="" majortype="102" name="spark_read" postfix="" returntype="102">
<options>
<O1 defaultselect="false" description="Read content of a file and return result as a cursor" optionchar="c"/>
<O2 defaultselect="false" description="Read the first row of a text file as field names, which is equivalent to &quot;header&quot;:&quot;true&quot;; by default, use the automatically generated field names c0, _c1…" optionchar="t"/>
<O3 defaultselect="false" description="Close Spark database connection" optionchar="x"/>
</options>
<params>
<P1 desc="con(Local or HDFS connection string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="sfile(File name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="k:v(Parameters that can be omitted. When sfile is a text file separated by “；”, set the pair as ”sep”:”;”; and when the text file is separated by “#”, set the pair as ”sep”:”#”)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F758>
<F759 desc="Calculate Spearman’s correlation coefficient between two vectors" displaystr="" majortype="102" name="spearman" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A vector)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F759>
<F760 desc="Split a string by delimiter so as to form a new sequence" displaystr="" majortype="101" name="split" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="It splits string into 2 parts by the first d found" optionchar="1"/>
<O2 defaultselect="false" description="Parse members into corresponding data types after the splitting. That is to say, numbers shall be handled as numeric values, members enclosed by [] shall be recognized as sequences, dates like 2001-01-01 shall be treated as date type data, and so on. The parsing of the sign [] also involves the same handling of a sub-sequence. In addition, parentheses matching needs to be handled." optionchar="p"/>
<O3 defaultselect="false" description="It parses members into corresponding data types without handling quotation marks matching and parentheses matching" optionchar="b"/>
<O4 defaultselect="false" description="Perform trim operation to remove blank characters from the front and end of each string member, and split the original string according to continuous blank characters when d==&quot;&quot;" optionchar="t"/>
<O5 defaultselect="false" description="Treat parameter d as a regular expression" optionchar="r"/>
<O6 defaultselect="false" description="Spit a string using the carriage return \n, and split each substring according to the other options if there are any, and return a sequence of sequences" optionchar="n"/>
<O7 defaultselect="false" description="Split string into two parts at the position of the last d found" optionchar="z"/>
</options>
<params>
<P1 desc="d  (The delimiter; if it is omitted, split the string into a sequence of single characters.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F760>
<F761 desc="Start or stop an SPL process on the current machine." displaystr="" majortype="102" name="splserver" postfix="" returntype="101">
<options/>
<params>
<P1 desc="port(The port number)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cfg(XML configuration file name; stop the process at the specified port when it is absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F761>
<F762 desc="Split a SQL query into a sequence." displaystr="" majortype="101" name="sqlparse" postfix="sql." returntype="101">
<options>
<O1 defaultselect="false" description="SELECT statement" optionchar="s"/>
<O2 defaultselect="false" description="FROM clause, including the JOIN" optionchar="f"/>
<O3 defaultselect="false" description="WHERE clause" optionchar="w"/>
<O4 defaultselect="false" description="GROUP BY statement" optionchar="g"/>
<O5 defaultselect="false" description="HAVING clause" optionchar="h"/>
<O6 defaultselect="false" description="ORDER BY statement" optionchar="o"/>
<O7 defaultselect="false" description="Split each statement/clause into smaller parts; separate WHERE and HAVING clauses according to AND" optionchar="a"/>
</options>
<params>
<P1 desc="part (A SQL string for replacing a statement/clause in the original SQL query; need to work with a certain option)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F762>
<F763 desc="Translates standard SQL functions into functions a specified database defines." displaystr="" majortype="101" name="sqltranslate" postfix="sql." returntype="101">
<options/>
<params>
<P1 desc="dbtype (Database type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F763>
<F764 desc="Find the square root of a number" displaystr="" majortype="102" name="sqrt" postfix="" returntype="101">
<options/>
<params>
<P1 desc="x (Data for which you want to find the square root)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="n (The n)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F764>
<F765 desc="Close connection to the Cassandra database" displaystr="" majortype="102" name="stax_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient (Cassandra database connection)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F765>
<F766 desc="Query the Cassandra database and return result as a cursor" displaystr="" majortype="102" name="stax_cursor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient(The database connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cql(A CQL query statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args(A parameter value; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F766>
<F767 desc="Create connection to the Cassandra database" displaystr="" majortype="102" name="stax_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="nodes (The to-be-connected database’s IP address)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="port (Port number; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="user:pwd (User name and password; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="keyspace (The keyspace name; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="compressor (A compression algorithm, which is LZ4, Snappy and none; default is none)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
<P6 desc="version(Protocol version information; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
<P7 desc="queryOptions(A query option, which includes ANY, ONE, TOW, THREE, ALL and QUORUM; there are details in Cssandra documentation)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P7>
</params>
</F767>
<F768 desc="Query a Cassandra database and return the query result as a table sequence" displaystr="" majortype="102" name="stax_query" postfix="" returntype="101">
<options/>
<params>
<P1 desc="staxClient (Database connection handle)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cql (The query statement)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="args (Parameter values; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F768>
<F769 desc="Create a sequence by getting members from a sequence according to the specified starting position and a step." displaystr="" majortype="101" name="step" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="m  (a positive integer used to specify the span)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ki  (the starting serial number, 1≤ki.The default is 1.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F769>
<F770 desc="Convert the object of other type to the string type and format it" displaystr="" majortype="102" name="string" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enclosed the string expression in double quotes and ignore parameter format" optionchar="q"/>
<O2 defaultselect="false" description="Escape the undisplayable character. Represent the tab, carriage return, line break in the string expression with the escape characters. Add an escape character before the single quotes, double quotes or an escape character if there is any in the string. Ignore parameter format" optionchar="e"/>
<O3 defaultselect="false" description="With the use of @e option, if there is large character set in the string expression, convert it to Unicode characters" optionchar="u"/>
</options>
<params>
<P1 desc="expression (The constant object or expression to be converted to string.)" filtertype="0" identifieronly="true" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format  (A format string used to format the result of expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F770>
<F771 desc="Get structure information of a composite table." displaystr="" majortype="101" name="structure" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Means f is an index file" optionchar="i"/>
<O2 defaultselect="false" description="Means f is a preaggregation file" optionchar="c"/>
</options>
<params/>
</F771>
<F772 desc="Find a substring and return the string after the substring" displaystr="" majortype="101" name="substr" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Return the string before s2; return null if there is nothing before s2" optionchar="l"/>
<O2 defaultselect="false" description="Skip the quoted string" optionchar="q"/>
<O3 defaultselect="false" description="Case-insensitive" optionchar="c"/>
</options>
<params>
<P1 desc="s1 (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s2 (A string)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F772>
<F773 desc="Compute x with each member of the sequence and compute the summary value of the members of the new sequence, Equivalent to A.(x).sum()" displaystr="" majortype="101" name="sum" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names. The data type of the computed result of the expression is numerical value.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F773>
<F774 desc="Compute the sum of members of a sequence.  Equivalent to sum(x1,…,xn)" displaystr="" majortype="101" name="sum" postfix="A." returntype="101">
<options/>
<params/>
</F774>
<F775 desc="Solve binary classification problems and regression problems using SVM algorithm" displaystr="" majortype="101" name="svm" postfix="" returntype="101">
<options/>
<params>
<P1 desc="X(A sequence representing the training set independent variable)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Y(A sequence representing the training set objective variable)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="param(A sequence of SVM model parameters)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="R(A sequence, which is result returned by syntax svm(X,Y,param))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="XPre(A sequence representing the scoring data set)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F775>
<F776 desc="Generate a new sequence by swapping the member positions of two specified intervals of a sequence" displaystr="" majortype="101" name="swap" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="p  (an integer sequence interval composed of positive integers, for example [1,2,3 ], to (1,3))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="q  (an integer sequence interval composed of positive integers and does not have intersection with p, for example [ 4,5,6], to(4,6))" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F776>
<F777 desc="Switch the reference field between the field value and the referenced record" displaystr="" majortype="101" name="switch" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Remove this record if no value corresponding to F is found in the procedure." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F; with the option do not populate F with nulls. " optionchar="d"/>
<O3 defaultselect="false" description="If the specified F field value of a specified record in sequence P doesn’t exist in sequence B, generate a record of the same structure as one in B with F field as the primary key" optionchar="1"/>
</options>
<params>
<P1 desc="Fi  (The key of P. When Ai:x;… is omitted, Fi stores the records of the referenced table Ai. They can be replaced by Ai’s primary key values through the function.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai  (When Ai is available, Fi is the reference field of P, which stores corresponding primary key values. The function is used to switch them to the referenced records. The ma. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x  (When both parameter Ai and the primary key x are available, get the first record from Ai in which value x is equal to Fi and make it the value of Fi field. If x is #, locate the records directly through the sequence numbers.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F777>
<F778 desc="Switch the values of a reference field in a channel between the corresponding primary key values and the referenced records, or, sometimes switch between them in a reverse direction. " displaystr="" majortype="101" name="switch" postfix="ch." returntype="101">
<options>
<O1 defaultselect="false" description="If no value corresponding to F is found, then remove this record." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F." optionchar="d"/>
<O3 defaultselect="false" description="If the F field value of a record in channel ch doesn’t exist in Ai , then generate a record of the same structure as Ai with expression x being the primay key" optionchar="1"/>
</options>
<params>
<P1 desc="Fi  (The reference field of A. When Ai:x;… is omitted, Fi stores the records of the referenced table Ai . They can be replaced by Ai’s primary key values through the function.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai  (When Ai is available, Fi is the reference field of A, which stores corresponding primary key values. The function is used to switch them to the referenced records in Ai.The matching condition is that Fi is equal to the primary key value of Ai. )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x  (When both Ai and x are available, get the first record from Ai in which value x is equal to Fi and make it the value of Fi field.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F778>
<F779 desc="Attach the action of switching specified field values to the referencing record field values to a cursor and return the original cursor." displaystr="cs.switch(Fi,Ai:x;…)" majortype="101" name="switch" postfix="cs." returntype="101">
<options>
<O1 defaultselect="false" description="Connect on condition that the values are equal. By default, start connecting from the left. If no value corresponding to F is found, then remove this record." optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i, which obtains the records that have no value corresponding to F" optionchar="d"/>
<O3 defaultselect="false" description="If the F field value of a record in channel ch doesn’t exist in Ai, then generate a record of the same structure as Ai with expression x being the primary key. Here is number 1." optionchar="1"/>
</options>
<params>
<P1 desc="Fi (A field of a cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai (A table sequence/A record sequence.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x (The primary key or logical primary key of Ai; the parameter can be omitted if primary key is already set for Ai.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F779>
<F780 desc="Replace values of a specified field in a cluster cursor with the referencing field values of the corresponding record in another table" displaystr="" majortype="102" name="switch" postfix="cs." returntype="102">
<options>
<O1 defaultselect="false" description="With a distributed cluster memory table, the operation won’t involve a cross-node reference but it assumes that the referenced records are local" optionchar="c"/>
</options>
<params>
<P1 desc="Fi (A field in the cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai (A cluster memory table)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x (The primary key or logical of Ai; the parameter can be omitted if Ai has the primary key)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F780>
<F781 desc="Replace values of specified fields in an in-memory table with the corresponding referencing field values" displaystr="" majortype="101" name="switch" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Delete a record from T if its Fi value does not have a match in Ai" optionchar="i"/>
<O2 defaultselect="false" description="Opposite to @i option, it enables to retain only the non-matching records in T; and in this case, Fi won’t be recorded as null" optionchar="d"/>
<O3 defaultselect="false" description="Generate a record of same structure as Ai if the Fi value of a record of T does not have a match in Ai; the primary key of the new record will be Fi" optionchar="1"/>
</options>
<params>
<P1 desc="Fi(A field of T)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai(An in-memory table or a table squence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="x(The (logical) primary key of Ai; if a specific primary is set for Ai, the parameter can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F781>
<F782 desc="Replace values of a specified field in a pseudo table with the corresponding referencing values in another table." displaystr="" majortype="101" name="switch" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="If no value corresponding to F is found, remove the pseudo table record" optionchar="i"/>
<O2 defaultselect="false" description="Perform the inverse operation of @i to obtain pseudo table records that have no matching value in Ai for F field" optionchar="d"/>
<O3 defaultselect="false" description="If the F field value of a pseudo table record doesn’t exist in Ai , then generate a record of the same structure as Ai with expression x being the primary key" optionchar="l"/>
</options>
<params>
<P1 desc="Fi(A pseudo table field)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Ai(A table sequence/record sequence)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x(The primary key or logical key of Ai; the parameter can be omitted if primary key is already set for Ai)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F782>
<F783 desc="Synchronize a local path onto a sequence of nodes." displaystr="" majortype="102" name="syncfile" postfix="" returntype="101">
<options/>
<params>
<P1 desc="hs(A node sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="p(A local path)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F783>
<F784 desc="It is used to call the system command, and return the result once completed. " displaystr="" majortype="102" name="system" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Proceed with the execution without pause" optionchar="p"/>
<O2 defaultselect="false" description="Return the result of stdout" optionchar="o"/>
<O3 defaultselect="false" description="Return the sequence of [exit,stdout,stderr]" optionchar="a"/>
</options>
<params>
<P1 desc="cmd (A system command, whose type can be cmd, sh or powershell; Its format is fixed, which is “cmd /c + command, “powershell -c + command” or “sh -c + command” )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F784>
<F785 desc="Compute the tangent value" displaystr="" majortype="102" name="tan" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number (Radians for which you want to compute the tangent value)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F785>
<F786 desc="Return the hyperbolic tangent" displaystr="" majortype="102" name="tanh" postfix="" returntype="101">
<options/>
<params>
<P1 desc="number  (The real number for which you want to find the hyperbolic tangent)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F786>
<F787 desc="Correct skewness of a sequence of numeric target variables" displaystr="" majortype="101" name="tarcorskew" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the corrected values after execution" optionchar="c"/>
</options>
<params>
<P1 desc="Rec(The sequence of correction and handling records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F787>
<F788 desc="Correct skewness of a table sequence/record sequence numeric variable" displaystr="" majortype="101" name="tarcorskew" postfix="P." returntype="101">
<options>
<O1 defaultselect="false" description="Modify the original data to the corrected values after execution" optionchar="c"/>
</options>
<params>
<P1 desc="tn(A string/number, which is the alias of the target variable (or the column number starting from 1) in a table sequence or record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Rec(The sequence of correction and handling records)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F788>
<F789 desc="Get the time part from the datetime value" displaystr="" majortype="102" name="time" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Measure to minute" optionchar="m"/>
<O2 defaultselect="false" description="Measure to second" optionchar="s"/>
</options>
<params>
<P1 desc="datetimeExp (datetime data )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F789>
<F790 desc="Convert the string stringExp to time data type according to the format specified by format and return null if the conversion fails. If there is no parameter format, format of stringExp must be in consistent with the time format in the configuration information. Parameter loc is the language used in stringExp; default is the system language." displaystr="" majortype="102" name="time" postfix="" returntype="101">
<options/>
<params>
<P1 desc="stringExp    (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="format (A string specifying data format)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="loc (Language name, which is case insensitive. The most commonly used languages are Chinese (zh) and English (en); see A.sort() to know other languages supported in esProc)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F790>
<F791 desc="Convert h,m,s of integer type to time data type" displaystr="" majortype="102" name="time" postfix="" returntype="101">
<options/>
<params>
<P1 desc="H  (integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="m (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="s  (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F791>
<F792 desc="T inverse cumulative distribution function." displaystr="" majortype="102" name="tinv" postfix="" returntype="102">
<options/>
<params>
<P1 desc="P(Probability within the interval (0,1))" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="nu(Degrees of freedom corresponding to probabilities)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F792>
<F793 desc="From sequence A, generate a sequence composed of the first a members; when a&lt;0, get members from the (A.len()+1+a)th one to the (A.len())th one." displaystr="" majortype="101" name="to" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="a (the integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F793>
<F794 desc="From the sequence A, generate a sequence composed of the members from the ath to the bth. If omitting a, then start from the first member by default; if omitting b, get all members of A, that is A.len(), by default, and in this case the comma must not be omitted; if a&gt;b, find the members backwards; members of the newly-generated sequence are ordered in an opposite direction relative to their original order." displaystr="" majortype="101" name="to" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="@z(i,n)  Split a sequence into a number of segments (the number is n), and get and return the ith segment. If the number of members in the sequence can’t be evenly divided, the additional members will be returned along with the last segment" optionchar="z"/>
</options>
<params>
<P1 desc="a (The integer specifying the starting position.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (The integer specifying the ending position.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F794>
<F795 desc="Generate a sequence composed of continuous integers between a and b." displaystr="" majortype="102" name="to" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Generate a sequence composed of continuous b integers starting from a. If b is less than 0, generate the sequence backward sequentially in descending order." optionchar="s"/>
</options>
<params>
<P1 desc="start (the starting integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="end (the ending integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F795>
<F796 desc="Generate a sequence composed of continuous integers from 1 to n." displaystr="" majortype="102" name="to" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Generate a sequence composed of continuous b integers starting from a. If b is less than 0, generate the sequence backward sequentially in descending order." optionchar="s"/>
</options>
<params>
<P1 desc="n (n&gt;0)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F796>
<F797 desc="Compute expression x over each member of the sequence A, sort the resulting members, and return a sequence consisting of the first n values of x" displaystr="" majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Return result as a pure table sequence when sequence A is a pure table sequence; return a pure sequence by default" optionchar="0"/>
<O3 defaultselect="false" description="Use standard competition ranking, where members having equal values are given equal rank and the next member is given the next highest rank" optionchar="r"/>
<O4 defaultselect="false" description="Use dense ranking, where members having equal values are given equal rank and the next members are given the immediately following ranking number" optionchar="i"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F797>
<F798 desc="Compute expression x,…x over each member of the sequence A, sort the resulting members, and return a sequence consisting of the first n smallest members of sequence A" displaystr="" majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Return result as a pure table sequence when sequence A is a pure table sequence; return a pure sequence by default" optionchar="0"/>
<O3 defaultselect="false" description="Use standard competition ranking, where members having equal values are given equal rank and the next member is given the next highest rank" optionchar="r"/>
<O4 defaultselect="false" description="Use dense ranking, where members having equal values are given equal rank and the next members are given the immediately following ranking number" optionchar="i"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (An expression)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="..." filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F798>
<F799 desc="Loop members of sequence A to compute expression x, then loop the results to compute expression y, and finally return a sequence of x’s results that correspond to the top n smallest values of yCompute expression x over each member of the sequence A and then expression y over results of computing expression x, sort values of x according to the values of y, and return a sequence consisting of the first n values of x" displaystr="" majortype="101" name="top" postfix="A." returntype="101">
<options>
<O1 defaultselect="false" description="Return a single value if n is ±1; and null if n is 0" optionchar="1"/>
<O2 defaultselect="false" description="Return result as a pure table sequence when sequence A is a pure table sequence; return a pure sequence by default" optionchar="0"/>
<O3 defaultselect="false" description="Use standard competition ranking, where members having equal values are given equal rank and the next member is given the next highest rank" optionchar="r"/>
<O4 defaultselect="false" description="Use dense ranking, where members having equal values are given equal rank and the next members are given the immediately following ranking number" optionchar="i"/>
</options>
<params>
<P1 desc="n (An integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="y (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="x (An expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F799>
<F800 desc="Perform aggregatgion over records in a cursor" displaystr="" majortype="101" name="total" postfix="cs." returntype="101">
<options/>
<params>
<P1 desc="y (Aggregate function, only support sum/count/max/min/top/avg/iterate; Parameter Gi should not be present when the function works with iterate(x,a;Gi,…) function)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F800>
<F801 desc="Perform aggregatgion over records in a channel" displaystr="" majortype="101" name="total" postfix="ch." returntype="101">
<options/>
<params>
<P1 desc="y (Aggregate function, only support sum/count/max/min/top/avg/iterate; Parameter Gi should not be present when the function works with iterate(x,a;Gi,…) function)" filtertype="0" identifieronly="false" presign=" " repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F801>
<F802 desc="Transpose a matrix." displaystr="" majortype="101" name="transpose" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Enter null as member values if the matrix has empty members " optionchar="n"/>
</options>
<params>
<P1 desc="A(A matrix)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F802>
<F803 desc="Remove the space on both ends of a string" displaystr="" majortype="102" name="trim" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Remove the spaces on the left of the string s, and the option is letter l" optionchar="l"/>
<O2 defaultselect="false" description="Remove the spaces on the right of string s" optionchar="r"/>
<O3 defaultselect="false" description="Remove all extra whitespaces. If there is one or continuous whitespaces within the string, retain only one whitespace; remove the whitespaces between a character and a word, but retain the whitespaces within the quotation marks." optionchar="a"/>
</options>
<params>
<P1 desc="s      (Source string from which you want to remove the space)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F803>
<F804 desc="Try to continue with the execution of a code block by ignoring the error. " displaystr="" majortype="101" name="try" postfix="" returntype="101">
<options/>
<params/>
</F804>
<F805 desc="Calculate t-test’s p-value" displaystr="" majortype="101" name="ttest_p" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A(A sequence of numeric targets or binary targets )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="B(A sequence of binary variables or numeric variables )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F805>
<F806 desc="Get data type of the specified variable" displaystr="" majortype="102" name="typeof" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="When x is number type or date type, it has multiple subtypes: number type: int, long, float, decimal； date type: date, time, datetime. " optionchar="x"/>
</options>
<params>
<P1 desc="x(A variable)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F806>
<F807 desc="Compute the union of members in a sequence whose members are sequences" displaystr="" majortype="101" name="union" postfix="A." returntype="101">
<options/>
<params/>
</F807>
<F808 desc="Compute x with each member of the sequence whose members are sequences, and then perform union operation on members of the new sequence" displaystr="" majortype="101" name="union" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x (Generally an expression of a single field name, or a legal expression composed of multiple field names)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F808>
<F809 desc="Update a database table based on a sequence/record sequence" displaystr="" majortype="1" name="update" postfix="db." returntype="102">
<options>
<O1 defaultselect="false" description="Compare primary keys between the database table and A1 to generate an UPDATE statement; skip the comparison and directly upadate the database table with A if A1 is absent." optionchar="u"/>
<O2 defaultselect="false" description="Compare primary keys between the database table with A1 generate INSERT statement; skip the comparison and directly insert records into the database table with A if A1 is absent." optionchar="i"/>
<O3 defaultselect="false" description="Clear the target table before the update is executed; empty the database table before executing db.update(A:A1,tbl,Fi:xi,...;P,...)." optionchar="a"/>
<O4 defaultselect="false" description="After the execution is completed, the transaction won not be committed. If this option is omitted, the transaction will be committed." optionchar="k"/>
<O5 defaultselect="false" description="The first field is an auto-increment field with no corresponding expression." optionchar="1"/>
<O6 defaultselect="false" description="Only perform delete operation and A1 must be in place. " optionchar="d"/>
</options>
<params>
<P1 desc="A  (A sequence / record sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="A1 (The original sequence/record sequence, whose data is considered consistent with the database table. )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="tbl (The name of a table in the database)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="Fi  (A field in tbl)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="xi (An expression which will be computed against A and then will be used as the new value of Fi.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P5>
<P6 desc="P (The primary key of tbl.If omitted, these keys will be retrieved from tbl. If retrival is failed, then use A)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P6>
</params>
</F809>
<F810 desc="Update a database table based on a cursor" displaystr="" majortype="1" name="update" postfix="db." returntype="101">
<options>
<O1 defaultselect="false" description="Generate UPDATE statement" optionchar="u"/>
<O2 defaultselect="false" description="Generate INSERT statement" optionchar="i"/>
<O3 defaultselect="false" description="Clear the target table before the update is executed; empty the database table before executing db.update()" optionchar="a"/>
<O4 defaultselect="false" description="After the execution is completed, the transaction won not  be committed. If this option is omitted, the transaction will be committed." optionchar="k"/>
<O5 defaultselect="false" description="The first field is an auto-increment field with no corresponding expression." optionchar="l"/>
</options>
<params>
<P1 desc="cs (A cursor)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="tbl (The name of a database table )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (A field in tbl)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="xi (An expression which will be computed based on A and its value will be the new value of Fi.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="P (The key of tbl. If omitted, it will be retrieved from tbl; if the retrieval fails, then use A’s)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F810>
<F811 desc="Update records in an entity table." displaystr="" majortype="101" name="update" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Update the records that can be inserted and ignore those whose values exist in the memory table" optionchar="i"/>
<O2 defaultselect="false" description="Update the records that can be modified and ignore those whose values don’t exist in the memory table" optionchar="u"/>
<O3 defaultselect="false" description="Return updated, inserted and deleted records" optionchar="n"/>
<O4 defaultselect="false" description="When parameter P is a cursor having same order as the original entity table, update the latter’s fields that P has; only valid when T is stored in column-wise format and no records should be added" optionchar="w"/>
<O5 defaultselect="false" description="Keep table sequences/record sequences P and D in the memory and perform the MERGE when computation begins without writing the updated result set to the external memory" optionchar="y"/>
</options>
<params>
<P1 desc="P (Data to be updated to T, which is a table sequence/record sequence having same structure as T; can be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="D(Data to be deleted from T, which is a table sequence/record sequence having same structure as T; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F811>
<F812 desc="Update records in a pseudo table" displaystr="" majortype="101" name="update" postfix="T." returntype="101">
<options>
<O1 defaultselect="false" description="Only append or insert non-matching records and ignore the matching ones" optionchar="i"/>
<O2 defaultselect="false" description="Only update the matching records and ignore the non-matching ones" optionchar="u"/>
<O3 defaultselect="false" description="Return updated, inserted and deleted records" optionchar="n"/>
<O4 defaultselect="false" description="Only invalid when entity table T is stored column-wise; when P is a cursor having same order as its corresponding table sequence/record sequence; re-write fields of P to entity table T; does not supporting adding records to T" optionchar="w"/>
<O5 defaultselect="false" description="Keep table sequences/record sequences P and D in the memory and perform the MERGE when computation begins without writing the updated result set to the external memory" optionchar="y"/>
</options>
<params>
<P1 desc="P (Data to be updated to T, which is a table sequence/record sequence having same structure as T; can be omitted)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="D(Data to be deleted from T, which is a table sequence/record sequence having same structure as T; can be omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
</params>
</F812>
<F813 desc="Convert all characters to upper case" displaystr="" majortype="102" name="upper" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The quoted strings won’t be converted" optionchar="q"/>
</options>
<params>
<P1 desc="s     (Source string to be converted to upper case)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F813>
<F814 desc="Convert a URL string into an encoded string" displaystr="" majortype="102" name="urlencode" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Decode, which is the inverse operation of the urlencode function" optionchar="r"/>
</options>
<params>
<P1 desc="s (A URL string to be encoded)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="cs (Character set)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F814>
<F815 desc="Generate a unique string." displaystr="" majortype="101" name="uuid" postfix="" returntype="101">
<options/>
<params/>
</F815>
<F816 desc="Get the primary key value of the record pointed by a referencing field." displaystr="" majortype="101" name="v" postfix="v." returntype="101">
<options/>
<params>
<P1 desc="v  (a record, a sequence or a number.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F816>
<F817 desc="Calculate the generalized variance of a vector (sequence)." displaystr="" majortype="101" name="var" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Calculate sample variance of a vector by dividing by n-1" optionchar="s"/>
</options>
<params>
<P1 desc="V(A vector)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F817>
<F818 desc="Implement an operation on file data, such as download and upload." displaystr="" majortype="102" name="webhdfs" postfix="" returntype="102">
<options/>
<params>
<P1 desc="url(URL of the target file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="localFile(The target file; can be omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F818>
<F819 desc="Implement file read and write." displaystr="" majortype="102" name="webhdfs_file" postfix="" returntype="102">
<options/>
<params>
<P1 desc="fileUrl(URL of the target file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="params(Parameter in the file URL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F819>
<F820 desc="Select the English words out of a string" displaystr="" majortype="101" name="words" postfix="s." returntype="101">
<options>
<O1 defaultselect="false" description="Select the numbers out of the string s" optionchar="d"/>
<O2 defaultselect="false" description="Select both the English words and the numbers out of the string s" optionchar="a"/>
<O3 defaultselect="false" description="Extract all characters from a string; extract a string in Chinese /a sign as inidvidual characters and a string of English letters/a number as what they are" optionchar="w"/>
<O4 defaultselect="false" description="Use with @w option to identify the preceder of a number or a datetime data as a part of it" optionchar="p"/>
<O5 defaultselect="false" description="Treat English letters in a row and continuous English letters plus numbers as a whole" optionchar="i"/>
</options>
<params/>
</F820>
<F821 desc="Compute a date time of n workdays from the specified date." displaystr="" majortype="102" name="workday" postfix="" returntype="101">
<options/>
<params>
<P1 desc="t (date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="k (integer)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (time sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F821>
<F822 desc="Return a sequence of workdays between two dates inclusive" displaystr="" majortype="102" name="workdays" postfix="" returntype="101">
<options/>
<params>
<P1 desc="b (Date)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="e (Date)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="h (A sequence composed of data of date type)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F822>
<F823 desc="Write string or a sequence into a file object. The write-in string can be binary data." displaystr="" majortype="2" name="write" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Append contents into a file, instead of overwritting. If contents exist in the file before appending, then new a line (carriage return) and append." optionchar="a"/>
<O2 defaultselect="false" description="Write a binary file" optionchar="b"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
</options>
<params>
<P1 desc="s  (A string)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F823>
<F824 desc="Convert every member in the sequence A to a string and write to the file f; each member occupies one row" displaystr="" majortype="2" name="write" postfix="f." returntype="102">
<options>
<O1 defaultselect="false" description="Append contents into a file, instead of overwritting. If contents exist in the file before appending, then new a line (carriage return) and append." optionchar="a"/>
<O2 defaultselect="false" description="Write a binary file" optionchar="b"/>
<O3 defaultselect="false" description="Use Windows-style \r\n line break; by default the line break is specified by the operating system." optionchar="w"/>
</options>
<params>
<P1 desc="A (a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F824>
<F825 desc="Send a query request to the web service server to get the returned data" displaystr="" majortype="102" name="ws_call" postfix="" returntype="101">
<options/>
<params>
<P1 desc="client (Web service client object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="service_name (Service name; the parameter can be omitted when the WSDL URL contains only one service)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="service_port (Service port; the parameter can be omitted when the specified service has only one port )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="operation_name (Query operation name)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
<P5 desc="value: paramName (Parameter value&amp;Parameter name; multiple pairs are allowed. If the name part is omitted, names defined in WDSL message will be referenced in order)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F825>
<F826 desc="Create a web service client" displaystr="" majortype="102" name="ws_client" postfix="" returntype="101">
<options/>
<params>
<P1 desc="wsdl_url (The WSDL URL provided by the server)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F826>
<F827 desc="Cross-join multiple sequences together." displaystr="" majortype="102" name="xjoin" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform left join (Note: here is the number 1). Use null to participate in the cross join if there is no matching members in sequence Ai" optionchar="1"/>
</options>
<params>
<P1 desc="Ai (The sequence on which cross-join is to be performed)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Field names of the resulting TSeq)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (Criterion of filtering expression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F827>
<F828 desc="Perform cross join over table sequences represented by cursors and return a multicursor." displaystr="" majortype="102" name="xjoinx" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Perform left join (Note: here is the number 1). Use null to participate in the cross join if there is no matching members in cursors csi" optionchar="1"/>
<O2 defaultselect="false" description="If field values of the sequences to be joined are records, the joining values will be unfolded" optionchar="x"/>
</options>
<params>
<P1 desc="csi (Single cursors or table sequences to be joined)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="Fi (Names of fields of the result table sequence)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="xi (Filtering expression)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F828>
<F829 desc="Enter cell values to an Excel file object or read data from it." displaystr="" majortype="101" name="xlscell" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="Insert-row style export; by default, enter the specified data in a row next to the row containing cell a" optionchar="i"/>
<O2 defaultselect="false" description="Enable returning a sequence of sequences of cell values at read-in" optionchar="w"/>
<O3 defaultselect="false" description="Parameter :b will be absent and parameter t is blob type when using this option to read in or configure an image; support jpg an pnag only" optionchar="g"/>
<O4 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O5 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null when @w option is also present" optionchar="n"/>
</options>
<params>
<P1 desc="a (Cell a)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="b (Cell b; when omitted, it is the last non-empty cell)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="s (Sheet number, which should not exceed 31 characters and contain special characters []:/\?*, or sheet name; it is the first page when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="t (The to-be-populated string; can be omitted; it can be separated by the carriage return “\r”(which means the content will be entered into the next row) or tab“\t” (which means the content will be entered into the next column); t can be a string, a single value, a sequence or a sequence of sequences)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F829>
<F830 desc="Close an Excel file object." displaystr="" majortype="101" name="xlsclose" postfix="xo." returntype="102">
<options/>
<params/>
</F830>
<F831 desc="Write a table sequence or a cursor to an Excel file." displaystr="" majortype="101" name="xlsexport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Write the first record as the header into a file; when a namesake file with content already exists, the last non-empty row will be treated as the header row" optionchar="t"/>
<O2 defaultselect="false" description="Import a whole big file (but shouldn’t be too big) with stream style" optionchar="c"/>
<O3 defaultselect="false" description="Write data after the last row according to the current format if the target Excel file or/and the target sheet exists; if sheet s exists in the original file but it doesn’t exist in the target Excel file, automatically create a sheet with name s in the Excel file" optionchar="a"/>
<O4 defaultselect="false" description="Use this option when parameter A is a sequence of sequences or a string delimited by /tab; it cannot work with both @t and @c, and requires the absence of parameters x:F" optionchar="w"/>
<O5 defaultselect="false" description="If the table sequence/cursor to be exported is a sequence of sequence, use this option to transpose rows to columns before writing data to a target Excel file; the option must work with @w option" optionchar="p"/>
<O6 defaultselect="false" description="If the target Excel file exists, retain it and replace the target sheet only. If parameter s is absent, replace the first sheet of the target Excel file; if s is present, replace sheet s" optionchar="k"/>
<O7 defaultselect="false" description="If the content of A being written to Excel reaches the maximum number of rows an Excel worksheet is allowed, automatically add a new sheet to hold the data" optionchar="m"/>
</options>
<params>
<P1 desc="A(Table sequence/cursor to be exported)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x(Fields to be exported. If omitted, then export all fields which can be textualized in the record sequence A/cursor. The sign # is used to represent a field with a sequence number)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="F(Resulting field name; if omitted, then use the original field names)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s(Sheet name, which should not exceed 31 characters and contain special characters []:/\?*, or sheet number; when omitted, the exported data will be appended to the first sheet)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="p(The password for opening the exported Excel file)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F831>
<F832 desc="Write a sequence into an Excel file object." displaystr="" majortype="101" name="xlsexport" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="Export headers; headers will overwrite the last row if there is data already " optionchar="t"/>
</options>
<params>
<P1 desc="A (A cursor/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="x (To-be-entered field names; all fields will be populated when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="Fi (The alias of the Excel file; use the original name when omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="s (Sheet name, which should not exceed 31 characters and contain special characters []:/\?*, or sheet number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F832>
<F833 desc="Retrieve contents as record from Excel file object, and return in the form of TSeq" displaystr="" majortype="2" name="xlsimport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export the first row in f as the field names; if not supplied, then use _1, and _2,… as the field names; with parameter b supplied, row b is treated as the header row." optionchar="t"/>
</options>
<params/>
</F833>
<F834 desc="From f, retrieve the data of entire rows from contents of b to e, and return in the form of TSeq. The &quot;e&lt;0&quot; represents the reciprocal number, and &quot;Fi&quot; represents the retrieved fields. By default, all fields will be retrieved. s is the name or sequence number of sheet." displaystr="" majortype="2" name="xlsimport" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Export the first row in f as the field names; if not supplied, then use _1, and _2,… as the field names; with parameter b supplied, row b is treated as the header row." optionchar="t"/>
<O2 defaultselect="false" description="Remove blank rows before and after the Excel data when reading content in; it becomes invalid when @c option is also present" optionchar="b"/>
<O3 defaultselect="false" description="Enable returning a sequence of sequences where members of sub-sequences are cell values; it cannot work with @t, @c and @b options" optionchar="w"/>
<O4 defaultselect="false" description="Enable returning a string delimited by /tab" optionchar="s"/>
<O5 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O6 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null" optionchar="n"/>
</options>
<params>
<P1 desc="Fi (To-be-retrieved fields; by default all fields will be retrieved.The sign # is used to represent a field with a sequence number.)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (sheet name or sequence number. If s is omitted, use the first Excel sheet.)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (The starting row. If b is omitted, the data from the first row to the row e will be retrieved. In this case, &quot;:&quot; can be omitted.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="e (The ending row. If e is omitted, the data will be retrieved from the row b to the last row. In this case, &quot;:&quot; cannot be omitted. If e is greater than the actual number of rows, then the actual number of rows shall prevail.         If both b and e are omitted, the data will be retrieved from the first row to the last row. )" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F834>
<F835 desc="Retrieve a table sequence from an Excel file object." displaystr="" majortype="101" name="xlsimport" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="The first row is the header row; when parameter b is present, the header row is row b" optionchar="t"/>
<O2 defaultselect="false" description="Return the retrieved table sequence as a cursor; here the Excel file object must be read with @r option" optionchar="c"/>
<O3 defaultselect="false" description="Remove blank rows before and after the Excel data when reading content in; it becomes invalid when @c option is also present" optionchar="b"/>
<O4 defaultselect="false" description="Enable returning a string delimited by /tab" optionchar="s"/>
<O5 defaultselect="false" description="Work with @w to return a sequence of sequences; each sub-sequence is made up of column values" optionchar="p"/>
<O6 defaultselect="false" description="Remove blanck spaces on both sides of a string; read an empty string as null" optionchar="n"/>
</options>
<params>
<P1 desc="Fi (Excel column name; retrieve all fields when omitted)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s (Page name/page number)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="b (Row number; the first row by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="e (Row number; when e &lt; 0, it is the row counted backwards; retrieve data to the last row when omitted)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F835>
<F836 desc="Read an Excel file and return an Excel file object." displaystr="" majortype="101" name="xlsopen" postfix="f." returntype="101">
<options>
<O1 defaultselect="false" description="Read data in a stream style; support only xlsx files" optionchar="r"/>
<O2 defaultselect="false" description="Write data in a stream style; doesn’t support returning the index and support only xlsx files; the option and @r option are mutually exclusive" optionchar="w"/>
</options>
<params>
<P1 desc="p (The password for opening an Excel file; can be omitted if no password is set for the to-be-opened file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F836>
<F837 desc="Save an Excel file object into an Excel file." displaystr="" majortype="101" name="xlswrite" postfix="f." returntype="101">
<options/>
<params>
<P1 desc="xo (An Excel object read in non-@r@w way)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="p (The password for opening an Excel file; by default there isn’t one)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F837>
<F838 desc="Parse an XML string/a table sequence and return result." displaystr="" majortype="102" name="xml" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The options enables parsing an XML string in the format of K F=v F=v …&gt;D&lt;/K&gt; into records made up of fields K,F,… Three situations: If K’s value is D and D is multilevel XML data, the parsing result is a record sequence; if &lt;K …./K&gt;, D is parsed into null; if &lt;K…&gt;&lt;/K&gt;, D is parsed into an empty string." optionchar="s"/>
</options>
<params>
<P1 desc="x(An XML string/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="s(An XML string/a table sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F838>
<F839 desc="Perform XOR operation on integers" displaystr="" majortype="102" name="xor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="xi (The numerical expresion based on which you perform the XOR operation)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F839>
<F840 desc="Perform XOR operation on integers" displaystr="" majortype="102" name="xor" postfix="" returntype="101">
<options/>
<params>
<P1 desc="A (Sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F840>
<F841 desc="Generate a new sequence by uniting and rearranging distinct members in each of a sequence’s sub-sequences" displaystr="" majortype="101" name="xunion" postfix="A." returntype="101">
<options/>
<params/>
</F841>
<F842 desc="Calculate an expression with each member of every sub-sequence of a sequence to generate a new sequence by uniting and rearranging distinct members in each of the resulting sub-sequences" displaystr="" majortype="101" name="xunion" postfix="A." returntype="101">
<options/>
<params>
<P1 desc="x(An expression whose value is a sequence)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F842>
<F843 desc="Get the year from a date" displaystr="" majortype="102" name="year" postfix="" returntype="101">
<options/>
<params>
<P1 desc="dateExp   (Expression whose result is a date or date time; it can be an integer, which we can regard as the value of computing days@o())" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F843>
<F844 desc="Perform model building operation" displaystr="" majortype="102" name="ym_build_model" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD model)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mdfile(A model file with the extension pcf)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F844>
<F845 desc="Release resource usage." displaystr="" majortype="102" name="ym_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="env(An env object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F845>
<F846 desc="Initialize the environment by setting an environment variable.      ym_env(1) forces a restart of Python service." displaystr="" majortype="102" name="ym_env" postfix="" returntype="101">
<options/>
<params/>
</F846>
<F847 desc="Execute a Python file to define a data file and the target variable for data scoring." displaystr="" majortype="101" name="ym_exec" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pyfile(A Python module file that implements def apply(lists) interface; parameter lists is the list data type)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(A data file)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="jsonstr(A JSON string like: {target:0,n_components:3,deflation_mode:'regression',                 mode:'A',norm_y_weights:False,                  scale:False,algorithm:'nipals',                 max_iter:500,tol:0.000001,copy:True} In which target specifies the column holding the target variable  )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F847>
<F848 desc="List the degrees of importance for model building variables" displaystr="" majortype="102" name="ym_importance" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F848>
<F849 desc="Return model information as a JSON string." displaystr="" majortype="101" name="ym_json" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pd(The model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="ps(The scoring result object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F849>
<F850 desc="Generate a model object based on the model building file." displaystr="" majortype="101" name="ym_load_pcf" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pdfile(A model building file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F850>
<F851 desc="Load data for model building" displaystr="" majortype="102" name="ym_model" postfix="" returntype="101">
<options/>
<params>
<P1 desc="env(An env object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(Data for model building)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F851>
<F852 desc="Get information about the performance of a model" displaystr="" majortype="102" name="ym_performance" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(A PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F852>
<F853 desc="Perform data scoring.    Return a table sequence of scoring results when the data to be scored is a single record or concurrent records;     Return scoring result object when the data to be scored contains multiple records or it is a file. " displaystr="" majortype="102" name="ym_predict" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="The function @m(pd,data;duration) performs data scoring with a parallel processing. Parameter duration defines a time period (Unit: millisecond) during which the data is to be scored." optionchar="m"/>
</options>
<params>
<P1 desc="pd(A model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="data(To-be-scored data)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F853>
<F854 desc="Get model description data" displaystr="" majortype="102" name="ym_present" postfix="" returntype="101">
<options/>
<params>
<P1 desc="pd(A PD model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F854>
<F855 desc="Get data from the scoring result object." displaystr="" majortype="102" name="ym_result" postfix="" returntype="101">
<options/>
<params>
<P1 desc="ps(The scoring result object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F855>
<F856 desc="Generate a model file according to a model object." displaystr="" majortype="101" name="ym_save_pcf" postfix="" returntype="102">
<options/>
<params>
<P1 desc="pd(A model object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="pdfile(A model file with the extension pcf)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F856>
<F857 desc="Close Python service." displaystr="" majortype="102" name="ym_server_quit" postfix="" returntype="102">
<options/>
<params/>
</F857>
<F858 desc="Set model building parameter" displaystr="" majortype="102" name="ym_setparam" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="key(A parameter name)" filtertype="0" identifieronly="false" presign="," repeatable="true" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="value(A parameter value)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
</params>
</F858>
<F859 desc="Get a series of information about a specified variable" displaystr="" majortype="102" name="ym_statistics" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="field(Variable name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F859>
<F860 desc="Set a target variable for model building" displaystr="" majortype="102" name="ym_target" postfix="" returntype="101">
<options/>
<params>
<P1 desc="md(An MD object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="targetName(Target variable name)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F860>
<F861 desc="Create a multidimensional matrix where all the elements are zero." displaystr="" majortype="102" name="zeros" postfix="" returntype="102">
<options/>
<params>
<P1 desc="ni(A positive integer)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F861>
<F862 desc="Perform file compression operations" displaystr="" majortype="102" name="zip" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Decompression" optionchar="u"/>
<O2 defaultselect="false" description="Append a new compressed file to an existing compressed file" optionchar="a"/>
<O3 defaultselect="false" description="Delete a file in a compressed file" optionchar="d"/>
<O4 defaultselect="false" description="Won’t perform recursive compression over subdirectories, only compress files of the current level" optionchar="n"/>
<O5 defaultselect="false" description="List files in a compressed file" optionchar="f"/>
<O6 defaultselect="false" description="List directories in a compressed file" optionchar="p"/>
</options>
<params>
<P1 desc="zipfile(A compressed file)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="encoding(Charset; default is utf-8)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P2>
<P3 desc="password (A password; can be absent)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="path(The root directory holding a to-be-compressed file; it is the directory holding zipfile when the parameter is null or absent. The comma (“,”) after the parameter should be retained even the parameter is absent)" filtertype="0" identifieronly="false" presign=";" repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
<P5 desc="files(A file or a sequence of files. Wildcard characters * and ? are allowed in a file name; the former represents any string and the latter represents a single character. With wildcard characters and if the name of the directory where the to-be-compressed file(s) are located isn’t the same with that of the directory holding the future compressed file(s), then the function will also compressed the directory, which contains the absolute path. In that case, the directory list generated via @p option is empty )" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P5>
</params>
</F862>
<F863 desc="Add one or more files to a zip file" displaystr="" majortype="102" name="zip_add" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(Name of a to-be-compressed file or FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F863>
<F864 desc=" Close a zip file." displaystr="" majortype="102" name="zip_close" postfix="" returntype="102">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F864>
<F865 desc="Set compression mode and level for a would-be zip file" displaystr="" majortype="102" name="zip_compress" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mode(Compression mode 0: Won’t compress 1: Standard compression  2: AES_ENC mode compression Other values: Standard compression)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="level(Compression level 1: DEFLATE_LEVEL_FASTEST 2: DEFLATE_LEVEL_FAST 3: DEFLATE_LEVEL_NORMAL 4: DEFLATE_LEVEL_MAXIMUM 5: DEFLATE_LEVEL_ULTRA Other values: DEFLATE_LEVEL_NORMAL)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
</params>
</F865>
<F866 desc=" Delete one or more files from a zip file" displaystr="" majortype="102" name="zip_del" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file ovject)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(A compressed file or a FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F866>
<F867 desc="Set encryption mode for a zip file" displaystr="" majortype="102" name="zip_encrypt" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object )" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="mode(0: Won’t encrypt 1: Standard encryption 2: AES encryption with key length 128 3: AES encryption with key length 192 4: AES encryption with key length 256 Other values:Won’t encrypt)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F867>
<F868 desc="Extract one or more files from a zip file" displaystr="" majortype="102" name="zip_extract" postfix="" returntype="101">
<options/>
<params>
<P1 desc="zip(A zip file object)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="files(A compressed file or a FileObject; can be a sequence)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F868>
<F869 desc="Access DynamoDB on the cloud" displaystr="" majortype="102" name="dyna_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="region(The AWS service region for use.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="AccessKey(Access Key for accessing DynamoDB.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="SecretKey(Secret Key for accessing DynamoDB.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F869>
<F870 desc="Manage Google cloud storage buckets." displaystr="" majortype="102" name="gcs_bucket" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Create a storage bucket; won’t create anew if the storage bucket having the same name already exists." optionchar="c"/>
<O2 defaultselect="false" description="Delete a storage bucket; cannot delete a non-empty bucket." optionchar="d"/>
</options>
<params>
<P1 desc="fd(GCS connection object.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="bucket(Storage bucket name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F870>
<F871 desc="Close Google Cloud Storage connection." displaystr="" majortype="102" name="gcs_close" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(GCS connection.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F871>
<F872 desc="Copy files in a storage bucket to the local, or local files to a storage bucket." displaystr="gcs_copy(fd,bucket:key, [localFile])" majortype="102" name="gcs_copy" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Copy a local file to a GCS storage bucket; when the local file path is a relative path, it is relative to the main directory." optionchar="u"/>
</options>
<params>
<P1 desc="fd(GCS connection object.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="bucket(Storage bucket name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="key(File name in the storage bucket.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P3>
<P4 desc="localFile(A local file name; save the file in the main directory by default)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P4>
</params>
</F872>
<F873 desc="Get the specified object in a storage bucket." displaystr="gcs_file(fd,bucket,key[:cs])" majortype="102" name="gcs_file" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(GCS connection object.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="bucket(Storage bucket.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
<P3 desc="key(File name in the storage bucket.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P3>
<P4 desc="cs(Encoding name; use this encoding to save or open a file.)" filtertype="0" identifieronly="false" presign=":" repeatable="false" subparam="true" valuestring="">
<options/>
</P4>
</params>
</F873>
<F874 desc="List storage buckets in the Google Cloud Storage platform or files in the specified storage bucket." displaystr="gcs_list(fd,[bucket])" majortype="102" name="gcs_list" postfix="" returntype="101">
<options/>
<params>
<P1 desc="fd(GCS connection object.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2 desc="bucket(Storage bucket name.)" filtertype="0" identifieronly="false" presign="," repeatable="false" subparam="false" valuestring="">
<options/>
</P2>
</params>
</F874>
<F875 desc="Connect to Google Cloud Storage service." displaystr="" majortype="102" name="gcs_open" postfix="" returntype="101">
<options/>
<params>
<P1 desc="json(JSON string.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F875>
<F876 desc="Calculate the overall variance for the aggregation field value." displaystr="" majortype="102" name="var" postfix="" returntype="101">
<options>
<O1 defaultselect="false" description="Calculate the sample variance of aggregation field value x by dividing it by n-1." optionchar="s"/>
</options>
<params>
<P1 desc="x (Aggregation field name, whose data type must be numeric.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
</params>
</F876>
<F877 desc="Move a worksheet in an Excel object." displaystr="" majortype="102" name="xlsmove" postfix="xo." returntype="101">
<options>
<O1 defaultselect="false" description="Copy." optionchar="c"/>
</options>
<params>
<P1 desc="s (Sheet name in Excel object xo.)" filtertype="0" identifieronly="false" presign=" " repeatable="false" subparam="false" valuestring="">
<options/>
</P1>
<P2/>
</params>
</F877>
</normal>
</funcs>
