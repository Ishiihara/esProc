package com.esproc.jdbc;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.Ref;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Calendar;

import com.scudata.common.Logger;
import com.scudata.dm.Sequence;

/**
 * Implementation of java.sql.PreparedStatement
 */
public abstract class InternalPStatement extends InternalStatement implements
		java.sql.PreparedStatement {
	/**
	 * 参数列表
	 */
	protected ArrayList<Object> parameters = new ArrayList<Object>();

	/**
	 * 参数列表的列表
	 */
	protected ArrayList<ArrayList<?>> paramsList = new ArrayList<ArrayList<?>>();

	/**
	 * CALLS用到的参数序列的列表
	 */
	protected ArrayList<Sequence> callsParameters = new ArrayList<Sequence>();

	/**
	 * Constructor
	 * 
	 * @param con
	 *            The connection object
	 * @param id
	 *            The statement ID
	 * @param sql
	 *            The SQL string
	 */
	public InternalPStatement(int id, String sql) {
		super(id);
		this.sql = sql;
		JDBCUtil.log("InternalPStatement-2");
	}

	/**
	 * Get parameter list
	 * 
	 * @return parameter list
	 */
	public ArrayList<Object> getParameters() {
		JDBCUtil.log("InternalPStatement-41");
		return parameters;
	}

	/**
	 * Set parameter list
	 * 
	 * @param parameters
	 *            Parameter list
	 */
	public void setParameters(ArrayList<Object> parameters) {
		JDBCUtil.log("InternalPStatement-42");
		this.parameters = parameters;
	}

	/**
	 * Executes the given SQL statement, which returns a single ResultSet
	 * object.
	 * 
	 * @param sql
	 *            an SQL statement to be sent to the database, typically a
	 *            static SQL SELECT statement
	 * @return a ResultSet object that contains the data produced by the given
	 *         query; never null
	 */
	public java.sql.ResultSet executeQuery(String sql) throws SQLException {
		JDBCUtil.log("InternalPStatement-3");
		InternalConnection connt = getConnection();
		if (connt == null || connt.isClosed())
			throw new SQLException(JDBCMessage.get().getMessage(
					"error.conclosed"));
		if (sql.startsWith(">"))
			throw new SQLException(JDBCMessage.get().getMessage(
					"error.cantreturnrs"));
		this.sql = sql;
		this.parameters.clear();
		return this.executeQuery();
	}

	/**
	 * Executes the given SQL statement, which may return multiple results. In
	 * some (uncommon) situations, a single SQL statement may return multiple
	 * result sets and/or update counts. Normally you can ignore this unless you
	 * are (1) executing a stored procedure that you know may return multiple
	 * results or (2) you are dynamically executing an unknown SQL string.
	 * 
	 * 
	 * @param sql
	 *            any SQL statement
	 * @return true if the first result is a ResultSet object; false if it is an
	 *         update count or there are no results
	 */
	public boolean execute(String sql) throws SQLException {
		JDBCUtil.log("InternalPStatement-4");
		InternalConnection connt = getConnection();
		if (connt == null || connt.isClosed())
			throw new SQLException(JDBCMessage.get().getMessage(
					"error.conclosed"));
		this.sql = sql;
		this.parameters.clear();
		return execute();
	}

	/**
	 * Executes the SQL statement in this PreparedStatement object, which may be
	 * any kind of SQL statement. Some prepared statements return multiple
	 * results; the execute method handles these complex statements as well as
	 * the simpler form of statements handled by the methods executeQuery and
	 * executeUpdate.
	 * 
	 * 
	 * @return true if the first result is a ResultSet object; false if the
	 *         first result is an update count or there is no result
	 */
	public boolean execute() throws SQLException {
		JDBCUtil.log("InternalPStatement-5");
		InternalConnection connt = getConnection();
		if (connt == null || connt.isClosed())
			throw new SQLException(JDBCMessage.get().getMessage(
					"error.conclosed"));
		boolean isSucc;
		if (JDBCUtil.isCallsStatement(sql)) {
			isSucc = executeJDBC(callsParameters);
		} else {
			isSucc = executeJDBC(parameters);
		}
		if (!isSucc)
			return false;
		getMoreResults();
		set = null;
		return result != null;
	}

	/**
	 * Executes the SQL query in this PreparedStatement object and returns the
	 * ResultSet object generated by the query.
	 * 
	 * 
	 * @return a ResultSet object that contains the data produced by the query;
	 *         never null
	 */
	public java.sql.ResultSet executeQuery() throws SQLException {
		JDBCUtil.log("InternalPStatement-6");
		InternalConnection connt = getConnection();
		if (connt == null || connt.isClosed())
			throw new SQLException(JDBCMessage.get().getMessage(
					"error.conclosed"));
		if (sql.startsWith(">"))
			throw new SQLException(JDBCMessage.get().getMessage(
					"error.cantreturnrs"));
		boolean isSucc;
		if (JDBCUtil.isCallsStatement(sql)) {
			if (callsParameters.isEmpty()) {
				if (!parameters.isEmpty()) {
					for (int i = 0; i < parameters.size(); i++) {
						if (callsParameters.size() <= i) {
							callsParameters.add(new Sequence());
						}
						Sequence seq = callsParameters.get(i);
						seq.add(parameters.get(i));
					}
				}
			}
			isSucc = executeJDBC(callsParameters);
		} else {
			isSucc = executeJDBC(parameters);
		}
		if (!isSucc)
			return null;
		set = null;
		if (this.getMoreResults())
			return this.getResultSet();
		else
			return null;
	}

	/**
	 * Executes the SQL statement in this PreparedStatement object, which must
	 * be an SQL Data Manipulation Language (DML) statement, such as INSERT,
	 * UPDATE or DELETE; or an SQL statement that returns nothing, such as a DDL
	 * statement.
	 * 
	 * @return either (1) the row count for SQL Data Manipulation Language (DML)
	 *         statements or (2) 0 for SQL statements that return nothing
	 */
	public int executeUpdate() throws SQLException {
		JDBCUtil.log("InternalPStatement-7");
		InternalConnection connt = getConnection();
		if (connt == null || connt.isClosed())
			throw new SQLException(JDBCMessage.get().getMessage(
					"error.conclosed"));
		updateCount = executeUpdateJDBC(parameters);
		return updateCount;
	}

	/**
	 * Sets the designated parameter to the given java.sql.Array object. The
	 * driver converts this to an SQL ARRAY value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            an Array object that maps an SQL ARRAY value
	 */
	public void setArray(int parameterIndex, Array x) throws SQLException {
		JDBCUtil.log("InternalPStatement-8");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the designated parameter to the given input stream, which will have
	 * the specified number of bytes. When a very large ASCII value is input to
	 * a LONGVARCHAR parameter, it may be more practical to send it via a
	 * java.io.InputStream. Data will be read from the stream as needed until
	 * end-of-file is reached. The JDBC driver will do any necessary conversion
	 * from ASCII to the database char format.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the Java input stream that contains the ASCII parameter value
	 * @param length
	 *            the number of bytes in the stream
	 */
	public void setAsciiStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-9");
		Logger.debug(JDBCMessage
				.get()
				.getMessage("error.methodnotimpl",
						"setAsciiStream(int parameterIndex, InputStream x, int length)"));
	}

	/**
	 * Sets the designated parameter to the given java.math.BigDecimal value.
	 * The driver converts this to an SQL NUMERIC value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setBigDecimal(int parameterIndex, BigDecimal x)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-10");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the designated parameter to the given input stream, which will have
	 * the specified number of bytes. When a very large binary value is input to
	 * a LONGVARBINARY parameter, it may be more practical to send it via a
	 * java.io.InputStream object. The data will be read from the stream as
	 * needed until end-of-file is reached.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the java input stream which contains the binary parameter
	 *            value
	 * @param length
	 *            the number of bytes in the stream
	 */
	public void setBinaryStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-11");
		try {
			byte[] bs = new byte[length];
			x.read(bs);
			if (parameters.size() > parameterIndex - 1)
				parameters.set(parameterIndex - 1, bs);
			else {
				while (parameters.size() < parameterIndex - 1)
					parameters.add(null);
				parameters.add(parameterIndex - 1, bs);
			}
		} catch (IOException e) {
			throw new SQLException(e.getMessage());
		}
	}

	/**
	 * Sets the designated parameter to the given java.sql.Blob object. The
	 * driver converts this to an SQL BLOB value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            a Blob object that maps an SQL BLOB value
	 */
	public void setBlob(int parameterIndex, Blob x) throws SQLException {
		JDBCUtil.log("InternalPStatement-12");
		byte[] bs = x.getBytes(1, (int) x.length());
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, bs);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, bs);
		}
	}

	/**
	 * Sets the designated parameter to the given Java boolean value. The driver
	 * converts this to an SQL BIT or BOOLEAN value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setBoolean(int parameterIndex, boolean x) throws SQLException {
		JDBCUtil.log("InternalPStatement-13");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, new Boolean(x));
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, new Boolean(x));
		}
	}

	/**
	 * Sets the designated parameter to the given Java byte value. The driver
	 * converts this to an SQL TINYINT value when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setByte(int parameterIndex, byte x) throws SQLException {
		JDBCUtil.log("InternalPStatement-14");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, new Byte(x));
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, new Byte(x));
		}
	}

	/**
	 * Sets the designated parameter to the given Java array of bytes. The
	 * driver converts this to an SQL VARBINARY or LONGVARBINARY (depending on
	 * the argument's size relative to the driver's limits on VARBINARY values)
	 * when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setBytes(int parameterIndex, byte[] x) throws SQLException {
		JDBCUtil.log("InternalPStatement-15");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the designated parameter to the given Reader object, which is the
	 * given number of characters long. When a very large UNICODE value is input
	 * to a LONGVARCHAR parameter, it may be more practical to send it via a
	 * java.io.Reader object. The data will be read from the stream as needed
	 * until end-of-file is reached. The JDBC driver will do any necessary
	 * conversion from UNICODE to the database char format.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param reader
	 *            the java.io.Reader object that contains the Unicode data
	 * @param length
	 *            the number of characters in the stream
	 */
	public void setCharacterStream(int parameterIndex, Reader reader, int length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-16");
		try {
			char[] cs = new char[length];
			reader.read(cs);
			String s = new String(cs);
			if (parameters.size() > parameterIndex - 1)
				parameters.set(parameterIndex - 1, new String(s));
			else {
				while (parameters.size() < parameterIndex - 1)
					parameters.add(null);
				parameters.add(parameterIndex - 1, s);
			}
		} catch (IOException e) {
			throw new SQLException(e.getMessage());
		}
	}

	/**
	 * Sets the designated parameter to the given java.sql.Clob object. The
	 * driver converts this to an SQL CLOB value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            a Clob object that maps an SQL CLOB value
	 */
	public void setClob(int parameterIndex, Clob x) throws SQLException {
		JDBCUtil.log("InternalPStatement-17");
		String s = JDBCUtil.clobToString(x);
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, s);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, s);
		}
	}

	/**
	 * Sets the designated parameter to the given java.sql.Date value using the
	 * default time zone of the virtual machine that is running the application.
	 * The driver converts this to an SQL DATE value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setDate(int parameterIndex, Date x) throws SQLException {
		JDBCUtil.log("InternalPStatement-18");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the designated parameter to the given java.sql.Date value, using the
	 * given Calendar object. The driver uses the Calendar object to construct
	 * an SQL DATE value, which the driver then sends to the database. With a
	 * Calendar object, the driver can calculate the date taking into account a
	 * custom timezone. If no Calendar object is specified, the driver uses the
	 * default timezone, which is that of the virtual machine running the
	 * application.
	 * 
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 * @param cal
	 *            the Calendar object the driver will use to construct the date
	 */
	public void setDate(int parameterIndex, Date x, Calendar cal)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-19");
	}

	/**
	 * Sets the designated parameter to the given Java double value. The driver
	 * converts this to an SQL DOUBLE value when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setDouble(int parameterIndex, double x) throws SQLException {
		JDBCUtil.log("InternalPStatement-20");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, new Double(x));
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, new Double(x));
		}
	}

	/**
	 * Sets the designated parameter to the given Java float value. The driver
	 * converts this to an SQL REAL value when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setFloat(int parameterIndex, float x) throws SQLException {
		JDBCUtil.log("InternalPStatement-21");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, new Float(x));
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, new Float(x));
		}
	}

	/**
	 * Sets the designated parameter to the given Java int value. The driver
	 * converts this to an SQL INTEGER value when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setInt(int parameterIndex, int x) throws SQLException {
		JDBCUtil.log("InternalPStatement-21");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, new Integer(x));
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, new Integer(x));
		}
	}

	/**
	 * Sets the designated parameter to the given Java long value. The driver
	 * converts this to an SQL BIGINT value when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setLong(int parameterIndex, long x) throws SQLException {
		JDBCUtil.log("InternalPStatement-22");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, new Long(x));
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, new Long(x));
		}
	}

	/**
	 * Sets the designated parameter to SQL NULL.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param sqlType
	 *            the SQL type code defined in java.sql.Types
	 */
	public void setNull(int parameterIndex, int sqlType) throws SQLException {
		JDBCUtil.log("InternalPStatement-23");
	}

	/**
	 * Sets the designated parameter to SQL NULL. This version of the method
	 * setNull should be used for user-defined types and REF type parameters.
	 * Examples of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT,
	 * and named array types.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param sqlType
	 *            a value from java.sql.Types
	 * @param typeName
	 *            the fully-qualified name of an SQL user-defined type; ignored
	 *            if the parameter is not a user-defined type or REF
	 */
	public void setNull(int parameterIndex, int sqlType, String typeName)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-24");
	}

	/**
	 * Sets the value of the designated parameter using the given object.
	 * 
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the object containing the input parameter value
	 */
	public void setObject(int parameterIndex, Object x) throws SQLException {
		JDBCUtil.log("InternalPStatement-25");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the value of the designated parameter with the given object. This
	 * method is similar to setObject(int parameterIndex, Object x, int
	 * targetSqlType, int scaleOrLength), except that it assumes a scale of
	 * zero.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the object containing the input parameter value
	 * @param targetSqlType
	 *            the SQL type (as defined in java.sql.Types) to be sent to the
	 *            database
	 */
	public void setObject(int parameterIndex, Object x, int targetSqlType)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-26");
		/* The targetSqlType parameter is not used */
		setObject(parameterIndex, x, Types.OTHER);
	}

	/**
	 * Sets the value of the designated parameter with the given object. If the
	 * second argument is an InputStream then the stream must contain the number
	 * of bytes specified by scaleOrLength. If the second argument is a Reader
	 * then the reader must contain the number of characters specified by
	 * scaleOrLength. If these conditions are not true the driver will generate
	 * a SQLException when the prepared statement is executed.
	 * 
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the object containing the input parameter value
	 * @param targetSqlType
	 *            the SQL type (as defined in java.sql.Types) to be sent to the
	 *            database
	 * @param scaleOrLength
	 *            for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
	 *            this is the number of digits after the decimal point. For Java
	 *            Object types InputStream and Reader, this is the length of the
	 *            data in the stream or reader. For all other types, this value
	 *            will be ignored.
	 */
	public void setObject(int parameterIndex, Object x, int targetSqlType,
			int scaleOrLength) throws SQLException {
		JDBCUtil.log("InternalPStatement-27");
		/* The scaleOrLength parameter is not used */
		setObject(parameterIndex, x, targetSqlType);
	}

	/**
	 * Sets the designated parameter to the given REF(<structured-type>) value.
	 * The driver converts this to an SQL REF value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            an SQL REF value
	 */
	public void setRef(int parameterIndex, Ref x) throws SQLException {
		JDBCUtil.log("InternalPStatement-28");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the designated parameter to the given Java short value. The driver
	 * converts this to an SQL SMALLINT value when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setShort(int parameterIndex, short x) throws SQLException {
		JDBCUtil.log("InternalPStatement-29");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, new Short(x));
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, new Short(x));
		}
	}

	/**
	 * Sets the designated parameter to the given Java String value. The driver
	 * converts this to an SQL VARCHAR or LONGVARCHAR value (depending on the
	 * argument's size relative to the driver's limits on VARCHAR values) when
	 * it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setString(int parameterIndex, String x) throws SQLException {
		JDBCUtil.log("InternalPStatement-30");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the designated parameter to the given java.sql.Time value. The
	 * driver converts this to an SQL TIME value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setTime(int parameterIndex, Time x) throws SQLException {
		JDBCUtil.log("InternalPStatement-31");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the designated parameter to the given java.sql.Time value, using the
	 * given Calendar object. The driver uses the Calendar object to construct
	 * an SQL TIME value, which the driver then sends to the database. With a
	 * Calendar object, the driver can calculate the time taking into account a
	 * custom timezone. If no Calendar object is specified, the driver uses the
	 * default timezone, which is that of the virtual machine running the
	 * application.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 * @param cal
	 *            the Calendar object the driver will use to construct the time
	 */
	public void setTime(int parameterIndex, Time x, Calendar cal)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-32");
		/* The cal parameter is not used */
		setTime(parameterIndex, x);
	}

	/**
	 * Sets the designated parameter to the given java.sql.Timestamp value. The
	 * driver converts this to an SQL TIMESTAMP value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setTimestamp(int parameterIndex, Timestamp x)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-33");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Sets the designated parameter to the given java.sql.Timestamp value,
	 * using the given Calendar object. The driver uses the Calendar object to
	 * construct an SQL TIMESTAMP value, which the driver then sends to the
	 * database. With a Calendar object, the driver can calculate the timestamp
	 * taking into account a custom timezone. If no Calendar object is
	 * specified, the driver uses the default timezone, which is that of the
	 * virtual machine running the application.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 * @param cal
	 *            the Calendar object the driver will use to construct the
	 *            timestamp
	 */
	public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-34");
		/* The cal parameter is not used */
		setTimestamp(parameterIndex, x);
	}

	/**
	 * Sets the designated parameter to the given java.net.URL value. The driver
	 * converts this to an SQL DATALINK value when it sends it to the database.
	 * 
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the java.net.URL object to be set
	 */
	public void setURL(int parameterIndex, URL x) throws SQLException {
		JDBCUtil.log("InternalPStatement-35");
		if (parameters.size() > parameterIndex - 1)
			parameters.set(parameterIndex - 1, x);
		else {
			while (parameters.size() < parameterIndex - 1)
				parameters.add(null);
			parameters.add(parameterIndex - 1, x);
		}
	}

	/**
	 * Adds a set of parameters to this PreparedStatement object's batch of
	 * commands.
	 */
	public void addBatch() throws SQLException {
		JDBCUtil.log("InternalPStatement-36");
		if (JDBCUtil.isCallsStatement(sql)) {
			for (int i = 0; i < parameters.size(); i++) {
				if (callsParameters.size() <= i) {
					callsParameters.add(new Sequence());
				}
				Sequence seq = callsParameters.get(i);
				seq.add(parameters.get(i));
			}
		} else {
			addBatch(sql);
		}
		parameters.clear();
	}

	/**
	 * Adds the given SQL command to the current list of commands for this
	 * Statement object. The commands in this list can be executed as a batch by
	 * calling the method executeBatch.
	 * 
	 * @param sql
	 *            typically this is a SQL INSERT or UPDATE statement
	 */
	public void addBatch(String sql) throws SQLException {
		JDBCUtil.log("InternalPStatement-70");
		splList.add(sql);
		ArrayList<Object> cloneParams = new ArrayList<Object>();
		cloneParams.addAll(parameters);
		paramsList.add(cloneParams);
	}

	/**
	 * Empties this Statement object's current list of SQL commands.
	 */
	public void clearBatch() throws SQLException {
		JDBCUtil.log("InternalPStatement-71");
		splList.clear();
		paramsList.clear();
	}

	/**
	 * Submits a batch of commands to the database for execution and if all
	 * commands execute successfully, returns an array of update counts. The int
	 * elements of the array that is returned are ordered to correspond to the
	 * commands in the batch, which are ordered according to the order in which
	 * they were added to the batch. The elements in the array returned by the
	 * method executeBatch may be one of the following:
	 * 
	 * @return an array of update counts containing one element for each command
	 *         in the batch. The elements of the array are ordered according to
	 *         the order in which commands were added to the batch.
	 */
	public int[] executeBatch() throws SQLException {
		JDBCUtil.log("InternalPStatement-72");
		if (splList.isEmpty()) {
			throw new SQLException("No statements to execute.");
		}
		return executeBatch(paramsList);
	}

	/**
	 * Clears the current parameter values immediately.
	 */
	public void clearParameters() throws SQLException {
		JDBCUtil.log("InternalPStatement-37");
		this.parameters.clear();
	}

	/**
	 * Retrieves a ResultSetMetaData object that contains information about the
	 * columns of the ResultSet object that will be returned when this
	 * PreparedStatement object is executed.
	 * 
	 * @return the description of a ResultSet object's columns or null if the
	 *         driver cannot return a ResultSetMetaData object
	 */
	public ResultSetMetaData getMetaData() throws SQLException {
		JDBCUtil.log("InternalPStatement-38");
		if (set == null)
			return null;
		return set.getMetaData();
	}

	/**
	 * Retrieves the number, types and properties of this PreparedStatement
	 * object's parameters.
	 * 
	 * @return a ParameterMetaData object that contains information about the
	 *         number, types and properties for each parameter marker of this
	 *         PreparedStatement object
	 */
	public ParameterMetaData getParameterMetaData() throws SQLException {
		JDBCUtil.log("InternalPStatement-39");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"getParameterMetaData()"));
		return null;
	}

	/**
	 * Deprecated. Use setCharacterStream
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            a java.io.InputStream object that contains the Unicode
	 *            parameter value
	 * @param length
	 *            the number of bytes in the stream
	 */
	public void setUnicodeStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-40");
		Logger.debug(JDBCMessage
				.get()
				.getMessage("error.methodnotimpl",
						"setUnicodeStream(int parameterIndex, InputStream x, int length)"));
	}

	/**
	 * Sets the designated parameter to the given input stream. When a very
	 * large ASCII value is input to a LONGVARCHAR parameter, it may be more
	 * practical to send it via a java.io.InputStream. Data will be read from
	 * the stream as needed until end-of-file is reached. The JDBC driver will
	 * do any necessary conversion from ASCII to the database char format.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the Java input stream that contains the ASCII parameter value
	 */
	public void setAsciiStream(int parameterIndex, InputStream x)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-43");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setAsciiStream(int parameterIndex, InputStream x)"));
	}

	/**
	 * Sets the designated parameter to the given input stream, which will have
	 * the specified number of bytes. When a very large ASCII value is input to
	 * a LONGVARCHAR parameter, it may be more practical to send it via a
	 * java.io.InputStream. Data will be read from the stream as needed until
	 * end-of-file is reached. The JDBC driver will do any necessary conversion
	 * from ASCII to the database char format.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the Java input stream that contains the ASCII parameter value
	 * @param length
	 *            the number of bytes in the stream
	 */
	public void setAsciiStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-44");
		Logger.debug(JDBCMessage
				.get()
				.getMessage("error.methodnotimpl",
						"setAsciiStream(int parameterIndex, InputStream x, long length)"));
	}

	/**
	 * Sets the designated parameter to the given input stream. When a very
	 * large binary value is input to a LONGVARBINARY parameter, it may be more
	 * practical to send it via a java.io.InputStream object. The data will be
	 * read from the stream as needed until end-of-file is reached.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the java input stream which contains the binary parameter
	 *            value
	 */
	public void setBinaryStream(int parameterIndex, InputStream x)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-45");
		try {
			byte[] bs = inputStream2Bytes(x);
			if (parameters.size() > parameterIndex - 1)
				parameters.set(parameterIndex - 1, bs);
			else {
				while (parameters.size() < parameterIndex - 1)
					parameters.add(null);
				parameters.add(parameterIndex - 1, bs);
			}
		} catch (Exception e) {
			throw new SQLException(e.getMessage());
		}
	}

	/**
	 * 获得输入流中的字节数组
	 * 
	 * @param is
	 *            输入流对象
	 * @throws Exception
	 *             输入输出错误
	 * @return 字节数组
	 */
	private byte[] inputStream2Bytes(InputStream is) throws Exception {
		if (is == null) {
			return new byte[] {};
		}
		byte[] bytes = new byte[64 * 1024];
		int len;
		ByteArrayOutputStream baos = null;
		try {
			baos = new ByteArrayOutputStream();
			while ((len = is.read(bytes)) != -1) {
				baos.write(bytes, 0, len);
			}
		} finally {
			if (baos != null)
				try {
					baos.close();
				} catch (Exception e1) {
				}
		}
		return baos.toByteArray();
	}

	/**
	 * Sets the designated parameter to the given input stream, which will have
	 * the specified number of bytes. When a very large binary value is input to
	 * a LONGVARBINARY parameter, it may be more practical to send it via a
	 * java.io.InputStream object. The data will be read from the stream as
	 * needed until end-of-file is reached.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the java input stream which contains the binary parameter
	 *            value
	 * @param length
	 *            the number of bytes in the stream
	 */
	public void setBinaryStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-46");
		Logger.debug(JDBCMessage
				.get()
				.getMessage("error.methodnotimpl",
						"setBinaryStream(int parameterIndex, InputStream x, long length)"));
	}

	/**
	 * Sets the designated parameter to a InputStream object. This method
	 * differs from the setBinaryStream (int, InputStream) method because it
	 * informs the driver that the parameter value should be sent to the server
	 * as a BLOB. When the setBinaryStream method is used, the driver may have
	 * to do extra work to determine whether the parameter data should be sent
	 * to the server as a LONGVARBINARY or a BLOB
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param inputStream
	 *            An object that contains the data to set the parameter value
	 *            to.
	 */
	public void setBlob(int parameterIndex, InputStream inputStream)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-47");
		setBinaryStream(parameterIndex, inputStream);
	}

	/**
	 * Sets the designated parameter to a InputStream object. The inputstream
	 * must contain the number of characters specified by length otherwise a
	 * SQLException will be generated when the PreparedStatement is executed.
	 * This method differs from the setBinaryStream (int, InputStream, int)
	 * method because it informs the driver that the parameter value should be
	 * sent to the server as a BLOB. When the setBinaryStream method is used,
	 * the driver may have to do extra work to determine whether the parameter
	 * data should be sent to the server as a LONGVARBINARY or a BLOB
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param inputStream
	 *            An object that contains the data to set the parameter value
	 *            to.
	 * @param length
	 *            the number of bytes in the parameter data.
	 */
	public void setBlob(int parameterIndex, InputStream inputStream, long length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-48");
		Logger.debug(JDBCMessage
				.get()
				.getMessage("error.methodnotimpl",
						"setBlob(int parameterIndex, InputStream inputStream, long length)"));
	}

	/**
	 * Sets the designated parameter to the given Reader object. When a very
	 * large UNICODE value is input to a LONGVARCHAR parameter, it may be more
	 * practical to send it via a java.io.Reader object. The data will be read
	 * from the stream as needed until end-of-file is reached. The JDBC driver
	 * will do any necessary conversion from UNICODE to the database char
	 * format.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param reader
	 *            the java.io.Reader object that contains the Unicode data
	 */
	public void setCharacterStream(int parameterIndex, Reader reader)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-49");
		try {
			String s = reader2String(reader);
			if (parameters.size() > parameterIndex - 1)
				parameters.set(parameterIndex - 1, new String(s));
			else {
				while (parameters.size() < parameterIndex - 1)
					parameters.add(null);
				parameters.add(parameterIndex - 1, s);
			}
		} catch (Exception e) {
			throw new SQLException(e.getMessage());
		}
	}

	/**
	 * 获得输入流中的字节数组
	 * 
	 * @param is
	 *            输入流对象
	 * @throws Exception
	 *             输入输出错误
	 * @return 字节数组
	 */
	private String reader2String(Reader reader) throws Exception {
		if (reader == null) {
			return null;
		}
		char[] chars = new char[64 * 1024];
		int len;
		StringWriter writer = null;
		try {
			writer = new StringWriter();
			while ((len = reader.read(chars)) != -1) {
				writer.write(chars, 0, len);
			}
		} finally {
			if (writer != null)
				try {
					writer.close();
				} catch (Exception e1) {
				}
		}
		return writer.getBuffer().toString();
	}

	/**
	 * Sets the designated parameter to the given Reader object, which is the
	 * given number of characters long. When a very large UNICODE value is input
	 * to a LONGVARCHAR parameter, it may be more practical to send it via a
	 * java.io.Reader object. The data will be read from the stream as needed
	 * until end-of-file is reached. The JDBC driver will do any necessary
	 * conversion from UNICODE to the database char format.
	 * 
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param reader
	 *            the java.io.Reader object that contains the Unicode data
	 * @param length
	 *            the number of characters in the stream
	 */
	public void setCharacterStream(int parameterIndex, Reader reader,
			long length) throws SQLException {
		JDBCUtil.log("InternalPStatement-50");
		Logger.debug(JDBCMessage
				.get()
				.getMessage("error.methodnotimpl",
						"setCharacterStream(int parameterIndex, Reader reader, long length)"));
	}

	/**
	 * Sets the designated parameter to a Reader object. This method differs
	 * from the setCharacterStream (int, Reader) method because it informs the
	 * driver that the parameter value should be sent to the server as a CLOB.
	 * When the setCharacterStream method is used, the driver may have to do
	 * extra work to determine whether the parameter data should be sent to the
	 * server as a LONGVARCHAR or a CLOB
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param reader
	 *            An object that contains the data to set the parameter value
	 *            to.
	 */
	public void setClob(int parameterIndex, Reader reader) throws SQLException {
		JDBCUtil.log("InternalPStatement-51");
		setCharacterStream(parameterIndex, reader);
	}

	/**
	 * Sets the designated parameter to a Reader object. The reader must contain
	 * the number of characters specified by length otherwise a SQLException
	 * will be generated when the PreparedStatement is executed. This method
	 * differs from the setCharacterStream (int, Reader, int) method because it
	 * informs the driver that the parameter value should be sent to the server
	 * as a CLOB. When the setCharacterStream method is used, the driver may
	 * have to do extra work to determine whether the parameter data should be
	 * sent to the server as a LONGVARCHAR or a CLOB
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param reader
	 *            An object that contains the data to set the parameter value
	 *            to.
	 * @param length
	 *            the number of characters in the parameter data.
	 */
	public void setClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-52");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setClob(int parameterIndex, Reader reader, long length)"));
	}

	/**
	 * Sets the designated parameter to a Reader object. The Reader reads the
	 * data till end-of-file is reached. The driver does the necessary
	 * conversion from Java character format to the national character set in
	 * the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param value
	 *            the parameter value
	 */
	public void setNCharacterStream(int parameterIndex, Reader value)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-53");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setNCharacterStream(int parameterIndex, Reader value)"));
	}

	/**
	 * Sets the designated parameter to a Reader object. The Reader reads the
	 * data till end-of-file is reached. The driver does the necessary
	 * conversion from Java character format to the national character set in
	 * the database.
	 * 
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param value
	 *            the parameter value
	 * @param length
	 *            the number of characters in the parameter data.
	 */
	public void setNCharacterStream(int parameterIndex, Reader value,
			long length) throws SQLException {
		JDBCUtil.log("InternalPStatement-54");
		Logger.debug(JDBCMessage
				.get()
				.getMessage("error.methodnotimpl",
						"setNCharacterStream(int parameterIndex, Reader value, long length)"));
	}

	/**
	 * Sets the designated parameter to a java.sql.NClob object. The driver
	 * converts this to a SQL NCLOB value when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param value
	 *            the parameter value
	 */
	public void setNClob(int parameterIndex, NClob value) throws SQLException {
		JDBCUtil.log("InternalPStatement-55");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setNClob(int parameterIndex, NClob value)"));
	}

	/**
	 * Sets the designated parameter to a Reader object. This method differs
	 * from the setCharacterStream (int, Reader) method because it informs the
	 * driver that the parameter value should be sent to the server as a NCLOB.
	 * When the setCharacterStream method is used, the driver may have to do
	 * extra work to determine whether the parameter data should be sent to the
	 * server as a LONGNVARCHAR or a NCLOB
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param reader
	 *            An object that contains the data to set the parameter value
	 *            to.
	 */
	public void setNClob(int parameterIndex, Reader reader) throws SQLException {
		JDBCUtil.log("InternalPStatement-56");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setNClob(int parameterIndex, Reader reader)"));
	}

	/**
	 * Sets the designated parameter to a Reader object. The reader must contain
	 * the number of characters specified by length otherwise a SQLException
	 * will be generated when the PreparedStatement is executed. This method
	 * differs from the setCharacterStream (int, Reader, int) method because it
	 * informs the driver that the parameter value should be sent to the server
	 * as a NCLOB. When the setCharacterStream method is used, the driver may
	 * have to do extra work to determine whether the parameter data should be
	 * sent to the server as a LONGNVARCHAR or a NCLOB
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param reader
	 *            An object that contains the data to set the parameter value
	 *            to.
	 * @param length
	 *            the number of characters in the parameter data.
	 */
	public void setNClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-57");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setNClob(int parameterIndex, Reader reader, long length)"));
	}

	/**
	 * Sets the designated parameter to the given String object. The driver
	 * converts this to a SQL NCHAR or NVARCHAR or LONGNVARCHAR value (depending
	 * on the argument's size relative to the driver's limits on NVARCHAR
	 * values) when it sends it to the database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param value
	 *            the parameter value
	 */
	public void setNString(int parameterIndex, String value)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-58");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setNString(int parameterIndex, String value)"));
	}

	/**
	 * Sets the designated parameter to the given java.sql.RowId object. The
	 * driver converts this to a SQL ROWID value when it sends it to the
	 * database
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param x
	 *            the parameter value
	 */
	public void setRowId(int parameterIndex, RowId x) throws SQLException {
		JDBCUtil.log("InternalPStatement-59");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setRowId(int parameterIndex, RowId x)"));
	}

	/**
	 * Sets the designated parameter to the given java.sql.SQLXML object. The
	 * driver converts this to an SQL XML value when it sends it to the
	 * database.
	 * 
	 * @param parameterIndex
	 *            the first parameter is 1, the second is 2, ...
	 * @param xmlObject
	 *            a SQLXML object that maps an SQL XML value
	 */
	public void setSQLXML(int parameterIndex, SQLXML xmlObject)
			throws SQLException {
		JDBCUtil.log("InternalPStatement-60");
		Logger.debug(JDBCMessage.get().getMessage("error.methodnotimpl",
				"setSQLXML(int parameterIndex, SQLXML xmlObject)"));
	}

}
